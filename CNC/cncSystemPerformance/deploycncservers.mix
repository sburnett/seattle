"""
Author: Cosmin Barsan
Description:
This script deploys a set of cnc servers whose topology is determined by the arguments passed in.
Multiple instances of this script should not be run from within the same directory or else common files will be overwritten.

Usage:
See usage for deploycncexperiment
"""
from repyportability import *

include cncdeploylib.mix


#a list of files that need to be uploaded to all the nodes
# "registration_server_list.txt" and "update_query_server_list.txt" are generated by this script.
deploycncserver_FILES_TO_UPLOAD = ["cnc_server_list.txt","cnc_backup_config.txt","cncStandaloneServer.py"]

deploycncserver_LOG_FILE_BASE_NAME = "cncserverlog"
deploycncserver_mycontext = dict()




def startCncServerVessels(vessel_list, server_rules, vessel_cnckey_dict):
  """
  <Purpose>
    Starts the standalone cnc server on vessels specified in the vessel_list

  <Arguments>
    vessel_list: a list of vessels on which to start the update server
      each vessel in the list is represented as a ip_address, vesselname pair, where ip_address and vesselname are strings
    server_rules: a list of entries, where each entry describes the key range of one cnc server that needs to be created.
      each entry in the list is of the form (lower_bound, upper_bound), where both values are integers. A separate update server is 
      allocated for each key range, even if there are duplicates.
    vessel_cnckey_dict: provides a string representation of an rsa key pair ('#' separated instead of 'space') for each vessel
  <Exceptions>
    NMClientException thrown on failure to connect or start vessel

  <Side Effects>
    None

  <Returns>
    None
  """
  
  #here we need to iterate by index because we need data in parallel from vessel_list and server_rules
  for numerical_index in range(0, len(vessel_list)):
    ip_address, vesselname = vessel_list[numerical_index]
    lower_keyrange_bound, upper_keyrange_bound = server_rules[numerical_index]
    
    print "starting cnc server " + ip_address + ":" + vesselname + ", using keyrange " + str(lower_keyrange_bound) + "-" + str(upper_keyrange_bound)
    #get the nmhandle
    vessel_index=ip_address, vesselname
    nmhandle = deploycncserver_mycontext['deploydict'][vessel_index]['nmhandle']
  
    #set up the argument string to start the program
    #the update server takes a port, lower key range, upper key range, public key, and private key as parameters
    #we change the '#' separator to the '%' separator. The cnc server interprets these the same way, but '#' is not compatible with the node manager.
    server_publickey = vessel_cnckey_dict[vessel_index][0].replace('#','-')
    server_privatekey= vessel_cnckey_dict[vessel_index][1].replace('#','-')
    arguments = str(deploycncserver_mycontext['deploydict'][vessel_index]['ports'][0]) + ' ' + str(lower_keyrange_bound) +' '+ str(upper_keyrange_bound) + " " + server_publickey + " " + server_privatekey
    argstring= "cncStandaloneServer.py" + " " + arguments
    #try to start the vessel
    try:
      nmclient_signedsay(nmhandle, "StartVessel", vesselname, argstring)
    except NMClientException, e:
      print "error: " + str(e) + " trying to start the vessel " + vesselname + " on " + ip_address
      raise e
      

#generate an rsa keypair for each vessel and return a dict.
#the result dict is indexed by a (ip_address, vesselname) pair, where both ip_address and vesselname are strings.
#each entry in the result dict is a pair of strings (publickey, privatekey). These strings are basically 
#string representations of rsa keys (using rsa_public/privatekey_to_string), but use the '#' character instead of 'space'
def generateServerKeys():
  result_key_dict=dict()
  
  for ip_address, vesselname in deploycncserver_mycontext['deploydict'].keys():
    vessel_index=ip_address, vesselname
    
    #generate the keys
    generated_keys = rsa_gen_pubpriv_keys(50)
    rsa_public_key = generated_keys[0]
    rsa_private_key = generated_keys[1]
    
    #convert the keys to string format
    string_public_key = rsa_publickey_to_string(rsa_public_key).replace(' ','#')
    string_private_key = rsa_privatekey_to_string(rsa_private_key).replace(' ','#')
    
    result_key_dict[vessel_index] = string_public_key, string_private_key
    
  return result_key_dict


def generateServerInfoFile(filename, vessel_cnckey_dict, vessel_list):
  """
  <Purpose>
    used to generate files such as registration_server_list.txt and update_query_server_list.txt

  <Arguments>
    filename: the name of the file to be generated
    vessel_cnckey_dict: provides a string representation of an rsa key pair ('#' separated instead of 'space') for each vessel
    vessel_list: a list of vessels for which to write the information to the file. For each vessel we write a line consisting of the following ip, port and publickey.
      each vessel in the list is represented as a ip_address, vesselname pair, where ip_address and vesselname are strings
  <Exceptions>
    yes, IOError if there is a problem writing the file.

  <Side Effects>
    None

  <Returns>
    None
  """
  file_writer = open(filename, mode='w')
  
  for ip_address, vesselname in vessel_list:
    vessel_index=ip_address, vesselname
    publickey_string=vessel_cnckey_dict[vessel_index][0]
    
    port_to_use=deploycncserver_mycontext['deploydict'][vessel_index]['ports'][0]
    #we write a line in the format <ip>:<port><space><publickey>
    line_to_write = ip_address +':'+ str(port_to_use) + ' ' + vessel_cnckey_dict[vessel_index][0]
    
    file_writer.write(line_to_write + "\n")
    
  file_writer.close()



def allocate_roles(server_rules):
  """
  <Purpose>
    allocates cnc server roles to vessels
    These roles are assigned to vessels taken from deploycncserver_mycontext['deploydict']

  <Arguments>
    server_rules: a list of entries, where each entry describes the key range of one cnc server that needs to be created.
      each entry in the list is of the form (lower_bound, upper_bound), where both values are integers. A separate update server is 
      allocated for each key range, even if there are duplicates.
    
  <Exceptions>
    Exception is raised if there are insufficient vessels to fill all requested roles.

  <Side Effects>
    cleans deploycncserver_mycontext['deploydict'] of any vessels that remain unassigned

  <Returns>
    assigned_vessel_list: list of vessels assigned to serve as cnc servers
  """
  assigned_vessel_list= []
  total_vessels_needed = len(server_rules)
  vessels_available = deploycncserver_mycontext['deploydict'].keys()
  if total_vessels_needed> len(vessels_available):
    raise Exception, "Insufficient Vessels, " + str(len(vessels_available)) + " available. " + str(total_vessels_needed) + " needed"
  
  #now go through and assign the vessels
  for unassigned_vessel in vessels_available: 
    
    #if we need more update servers assign the vessel to this role
    if len(assigned_vessel_list)<len(server_rules):
      assigned_vessel_list.append(unassigned_vessel)
      continue   

    #remove unassigned vessels
    deploycncserver_mycontext['deploydict'].pop(unassigned_vessel)
    
  return assigned_vessel_list


  

def deploycncservers(ipdeploylist, server_rules, rsa_publickey, rsa_privatekey):
  """
  <Purpose>
    Deploys the specified server topology on the ip addresses listed in serverdeploylist.txt
    Also generates registration_server_list.txt and update_query_server_list.txt files

  <Arguments>
    ipdeploylist: list of ip addresses to deploy on, may include more nodes than actually needed. If this is teh case, it will allow script to tolerate some nodes that fail to be contacted.
    server_rules: a list of entries, where each entry describes the key range of one update server that needs to be created.
      each entry in the list is of the form (lower_bound, upper_bound), where both values are integers. A separate update server is 
      allocated for each key range, even if there are duplicates.
    rsa_publickey: publickey to use when contacting vessels
    rsa_privatekey: privatekey to use when contacting vessels
  <Exceptions>
    NMClientException thrown on failure to connect or start vessel

  <Side Effects>
    None

  <Returns>
    deploy dict structure for the experiment
  """
  
  deploycncserver_mycontext["user_publickey"]= rsa_publickey
  deploycncserver_mycontext["user_privatekey"]= rsa_privatekey
  
  #we need to know information for each vessel
  print "Getting vessel resource information for use in deployment, this may take a few minutes..."
  deploycncserver_mycontext['deploydict'] = cncdeploylib_constructDeployInfo(ipdeploylist, deploycncserver_mycontext["user_publickey"], deploycncserver_mycontext["user_privatekey"] )

  #reset the vessels
  print "resetting deployment vessels, this may take a few minutes..."
  cncdeploylib_resetVessels(deploycncserver_mycontext['deploydict'])
  
  #generate an rsa key pair for every vessel
  print "generating rsa key pairs for each vessel..."
  vessel_cnckey_dict = generateServerKeys()
  
  #allocate roles to each vessel
  assigned_vessel_list = allocate_roles(server_rules)
  
  #generate the neighbor port info file
  print "Writing cnc_server_list.txt file..."
  generateServerInfoFile('cnc_server_list.txt', vessel_cnckey_dict, assigned_vessel_list)
  
  
  
  #upload the files to all the nodes, printing a list of errors if any occur
  print "uploading files to deployment vessels, this may take a few minutes..."
  cncdeploylib_uploadFiles_parallel(deploycncserver_mycontext['deploydict'], deploycncserver_FILES_TO_UPLOAD)
  
  
  print "starting update servers on vessels, this may take a few minutes..."
  startCncServerVessels(assigned_vessel_list, server_rules, vessel_cnckey_dict)
  
  #wait 5 min to make sure the servers have started and are listening for announce messages
  sleep(5*60)
  
  return deploycncserver_mycontext['deploydict']
      

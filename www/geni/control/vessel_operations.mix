"""
<Program Name>
  vessel_operations.repy

<Started>
  February 4th, 2009

<Author>
  Ivan Beschastnikh
  Alper Sarikaya

<Purpose>
  Encapsulate all functionality related to vessel acquisition and release
  through the GENI portal.

<ToDo>
  ....

"""

import random
import time

from django.db import connection
from django.contrib.auth.models import User as DjangoUser

from geni.control.models import Vessel, Donation
import geni.control.resource_operations
from geni.control.repy_dist.changeusers import changeusers

from repyportability import *
include parallelize.repy


def acquire_vessel(vessel, pubkey_list, geni_user):
    """
    <Purpose>
      Responsible for changing the user public keys list on a vessel
    <Arguments>
      pubkey_list:
        list of public keys to associate as user keys with the vessel
      vessel:
        instance of Vessel class on which we need to set the user keys
    <Exceptions>
      None?
    <Side Effects>
      Changes the user public keys of a remote vessel
    <Returns>
      Returns True on success
      Returns (False, explanation) on failure where explanation is a
      string that explains the failure
    """
    # issue the command to remote nodemanager
    userpubkeystringlist = pubkey_list
    nmip = vessel.donation.ip
    nmport = int(vessel.donation.port)
    vesselname = vessel.name
    nodepubkey = vessel.donation.owner_pubkey
    nodeprivkey = vessel.donation.owner_privkey
    # alpers - too much explanation?
    # explanation += " %s:%s:%s - \n\n"%(nmip,nmport,vesselname)
    # explanation += "nodepubkey : %s<br>nodeprivkey: %s<br>"%(nodepubkey,nodeprivkey)
    # explanation += "calling changeusers with: \npubkeystrlist %s\nnmip %s\nnmport %s\nvesselname %s\nnodepubkey %s\nnodeprivkey %s\n"%(userpubkeystringlist, nmip, nmport, vesselname, nodepubkey, nodeprivkey)
    # explanation += " Acquiring %s:%s"%(nmip,nmport)

    # alpers - before changeusers, let's create a vmap entry so we can recover
    #          the vessel if changeusers gets forcefully terminated

    vessel_str = nmip + ":" + str(nmport) + " "

    if not geni.control.resource_operations.create_vmaps([vessel], geni_user, pending_flag=True):
        return False, vessel_str + ": no open ports found for vmap"

    print "changeusers ", time.time(), "on", nmip, ":", nmport, ":", vesselname
    success,msg = changeusers(userpubkeystringlist, nmip, nmport, vesselname, nodepubkey, nodeprivkey)
    print "/changeusers " , time.time()

    if success:
        return True, ""
    
    # alpers - TODO: gotta delete vesselmap here if changeusers failed
    # first find the right vesselport..
    vport = VesselPort.objects.filter(vessel = vessel).filter(
        port = geni_user.port)
    vport = vport[0]

    # then select the vmap object
    vmap = VesselMap.objects.filter(vessel_port = vport, user = geni_user, 
                                    pending = 1)
    if len(vmap) != 1:
        return False, "should have selected just one vmap entry, instead got %d: %s" %(len(vmap), vmap)

    # don't actually remove object, let's try to inspect list instead.
    # delete the vmap object from the db
    vmap.delete()
    
    

    explanation = vessel_str + msg
    return False, explanation


def get_base_vessels(geni_user):
    """
    <Purpose>

      Returns a base QuerySet of vessels that should accomodate a
      user. The QuerySet vessels are filtered based on:
      1) non-extra vessels only
      2) vessels supporting the user's port
      3) vessels are unassigned
      4) vessels are on active donations
    <Arguments>
      geni_user:
        an instance of the User class record for whom the vessels are intended
    <Exceptions>
      None?
    <Side Effects>
      None
    <Returns>
      Returns a django QuerySet object containing the vessel records
      matching the stated requirements
    """
    # consider vessels that are not 'extra vessels'
    v_non_extra = Vessel.objects.filter(extra_vessel=False)
    # consider vessels that match the geni_user's assigned port
    v_right_port = v_non_extra.filter(vesselport__port__exact=geni_user.port)
    # consider unassigned vessels
    v_unacquired = v_right_port.exclude(vesselport__vesselmap__isnull=False)
    # consider vessels on currently active donations
    v_active = v_unacquired.filter(donation__active__exact=True)
    print "v_non_extra", v_non_extra.count()
    print "v_right_port", v_right_port.count()
    print "v_unacquired", v_unacquired.count()
    print "v_active", v_active.count()
    return v_active


def release_vessels(vessels, num_threads=10):
    """
    <Purpose>
      'Releases' a list of vessels by performing a changeusers on each
      vessel and setting the user pubkeys list to [] on each vessel.
    <Arguments>
      vessels:
        a list of vessels to release
      num_threads:
        an optional argument to increase the parallelization of the method
    <Exceptions>
      None -- exceptions triggered by change users are caught and
      ignored. The idea is to release as many vessels as possible.
    <Side Effects>
      Changes the user keys on vessels to [""]
    <Returns>
      A dictionary that has vessels (the key) mapping to a tuple of 
      (success?, msg).  On success, msg will be empty.  Otherwise, 
      msg will contain an debug string for why changeuser failed
    """

    phandle = parallelize_initfunction(vessels, acquire_vessel,
                                       num_threads, [""])

    while not parallelize_isfunctionfinished(phandle):
        sleep(0.1)

    resultdict = parallelize_getresults(phandle)
    returndict = {}
    for vessel, (success, msg) in resultdict['returned']:
        returndict[vessel] = (success, msg)

    for vessel, exception_str in resultdict['exception']:
        returndict[vessel] = (False, "Exception: " + exception_str)
        
    print "release_vessels: ", returndict
    return returndict



def parallel_acquire_vessels(vessel_list, geni_user, num_threads=10):
    """
    <Purpose>
      Acquires the vessels given in parallel.

    <Arguments>
      vessel_list:
        The list of vessel objects to obtain.
      geni_user:
        The user object that is attempting to reserve the vessels.

    <Exceptions>
      This method should strictly return no exceptions; explanations and vessel_list -
      acquired should explain failures in this function.

    <Side Effects>
      None.

    <Returns>
      Returns a (acquired, explanation) tuple:
        acquired:
          The list of vessel objects successfully acquired by the function.
        summary:
          Any verbose output describing the success and/or failure of vessel acquisition.

    """

    # start acquisition
    phandle = parallelize_initfunction(vessel_list, acquire_vessel,
                                       num_threads, [geni_user.pubkey], 
                                       geni_user)

    # wait until all acquisitions have been attempted
    while not parallelize_isfunctionfinished(phandle):
        sleep(0.1)

    # get the results, create a list of all vessels successfully acquired
    acquired = []
    explanation = ""
    resultdict = parallelize_getresults(phandle)
    print "parallel_acquire_resultdict: ", resultdict
    for vessel, (success, msg) in resultdict['returned']:
        if success:
            acquired.append(vessel)
        else:
            explanation += " " + msg

    # return the list of acquired vessels, along with an explanation of failed
    # acquisitions
    return acquired, explanation



def acquire_lan_vessels(geni_user, num):
    """
    <Purpose>
      Acquires num number of LAN vessels for user geni_user. All the
      acquired vessels are quaranteed to be in the same IP subnet. If
      there is no large enough subset of vessels that have the same
      subnet, this function fails and does not acquire any vessels for
      the user.
    <Arguments>
      geni_user:
        instance of User class for whom we are acquiring vessels
      num:
        number of vessels to acquire for the user
    <Exceptions>
      Not sure.
    <Side Effects>
      Performs a change users to geni_user on vessels acquired for the
      user.
    <Returns>
      On success, returns (True, (summary, explanation, acquired))
      where acquired is a list of vessels acquired for the geni
      user. On failure returns (False, (summary, explanation)). In
      boths cases, summary and explanation are strings that summarize
      and explains the success\failure in less/more detail. On
      failure, vessels that were acquired are released.
    """

    vessels = get_base_vessels(geni_user)

    summary = ""
    explanation = ""
    
    qry = """SELECT count(*) as cnt, subnet
             FROM control_donation
             GROUP BY subnet
             ORDER BY cnt DESC"""
    cursor = connection.cursor()
    cursor.execute(qry)
    rows = cursor.fetchall()
    if len(rows) == 0:
        summary = "No lan subnets"
        return False, (summary, explanation)

    for row in rows:
        cnt, subnet = row
        if cnt < num:
            explanation = summary = "Not enough LAN nodes available to acquire."
            return False, (summary, explanation)
        
        lan_vessels = vessels.filter(donation__subnet__exact=subnet)
        if lan_vessels.count() < num:
            continue
        
        # alpers - this is the start of parallelized acquisition
        # Attempts to acquire the the number of vessels left in each iteration 
        # of the while loop, iterating again if the full number attempted is 
        # not achieved.
        acquired = []
        explanation = ""
        start_index = 0
        end_index = num
        while start_index < len(lan_vessels) and \
              end_index < len(lan_vessels):
            
            print "Trying to acquire " + str(num-len(acquired)) + \
                " vessels starting at index " + str(start_index)
            
            subset = lan_vessels[start_index : end_index]
            new_acquired, new_explanation = parallel_acquire_vessels(subset, geni_user)
            
            acquired.extend(new_acquired)
            explanation += " " + new_explanation
            
            # if all requested vessels have been acquired, flee the function
            if len(acquired) == num:
                return True, (summary, explanation, acquired)
            
            # otherwise, increase the lan_vessel index parameters based on the
            # number of vessels that were able to be acquired 
            # (start_index - end_index will be the number of vessels attempted
            # to be acquired on the next iteration)
            start_index += len(subset)
            end_index = start_index + num - len(acquired)
                
        # release all those vessels that were acquired
        # here and go to next subnet of hosts
        release_vessels(acquired)
                
    summary = str(len(rows)) + " Subnets available. Failed to acquire " + str(num) + " nodes in each subnet."
    return False, (summary, explanation)


def acquire_wan_vessels(geni_user, num):
    """
    <Purpose>
      Acquires num number of WAN vessels for user geni_user. This
      function guarantees that no two acquired vessels are in the same
      subnet. If the diversity of available resources do not permit
      this condition then the function fails and does not acquire any
      vessels for the user.
    <Arguments>
      geni_user:
        instance of User class for whom we are acquiring vessels
      num:
        number of vessels to acquire for the user
    <Exceptions>
      Not sure.
    <Side Effects>
      Performs a change users to geni_user on vessels acquired for the
      user.
    <Returns>
      On success, returns (True, (summary, explanation, acquired))
      where acquired is a list of vessels acquired for the geni
      user. On failure returns (False, (summary, explanation)). In
      boths cases, summary and explanation are strings that summarize
      and explains the success\failure in less/more detail. On
      failure, vessels that were acquired are released.
    """
    vessels = get_base_vessels(geni_user)
    
    qry = """SELECT distinct subnet
             FROM control_donation"""
    cursor = connection.cursor()
    cursor.execute(qry)
    rows = cursor.fetchall()
    summary = ""
    explanation = ""
    if len(rows) == 0:
        summary = "No donated resources are available."
        explanation = summary
        return False, (summary, explanation)

    # randomize data!
    rows = list(rows)
    random.shuffle(rows)

    # alpers - this is the start of parallelized acquisition
    acquired = []
    cnt = 0

    vessel_subnets = {}
    for row in rows:
        [subnet] = row
        print "working on populating subnet: " + str(subnet)
        donations = Donation.objects.filter(subnet=subnet)

        # try to grab all vessels (limit 10 artificially) in this subnet
        vessel_subnets[subnet] = []
        subnet_vessel_limit = 10
        for d in donations:
            subnet_vessels = vessels.filter(donation=d)
            if subnet_vessels.count() == 0:
                # a donation without any vessels -- strange?
                continue
            if len(vessel_subnets[subnet]) > subnet_vessel_limit:
                break
            else:
                vessel_subnets[subnet].extend(subnet_vessels)
            
        # Attempts to prevent function from populating a huge list that it will
        # hardly use. This line is super-suspect, although this saves the time
        # of aggregating a list, it *can* be possible that 4x the number of 
        # vessels requested can all fail.
        if len(vessel_subnets.keys()) > (num * 8):
            break

    # we've collected our collection of vessels, let's try to acquire some 
    while not len(vessel_subnets.keys()) < (num - len(acquired)):
        print "starting acquisition loop"
        vessels_to_submit = {}
        subnets_to_delete = []
        # populate our vessel subset, make another hash so we know which subnet
        # each came from
        for k, v in vessel_subnets.iteritems():
            if len(vessels_to_submit.keys()) < (num - len(acquired)):
                # if a subnet has been exhausted of available vessels, remove 
                # it from the potential vessel source list
                if len(v) == 0:
                    subnets_to_delete.append(k)

                # otherwise, remove the specific vessel from the subnet and
                # save it in the submission queue
                else:
                    vessels_to_submit[v.pop(0)] = k
            else:
                break

        # iteritems() doesn't like when keys are deleted in the middle of a 
        # loop, so vessel_subnets is clean up here
        for key in subnets_to_delete:
            del vessel_subnets[key]

        # submit jobs
        new_acquired, new_explanation = parallel_acquire_vessels(vessels_to_submit.keys(), geni_user)
        acquired.extend(new_acquired)

        if len(acquired) == num:
            print "acquired all num ok"
            return True, (summary, explanation, acquired)

        print "didn't find enough nodes (only " + str(len(acquired)) + "), retrying loop"
        
        # very important to ensure WAN case - remove the subnet from the list
        # of available vessels
        for vessel in new_acquired:
            subnet = vessels_to_submit[vessel]
            del vessel_subnets[subnet]

    # otherwise, fall through
    release_vessels(acquired)
    summary = "Network diversity of available resources canot satisfy your request"
    explanation = "Cannot find diverse WAN resources to satisfy a request for " + str(num) + " vessels"
    return False, (summary, explanation)


def acquire_rand_vessels(geni_user, num):
    """
    <Purpose>
      Acquires num number of random vessels for user geni_user.
    <Arguments>
      geni_user:
        instance of User class for whom we are acquiring vessels
      num:
        number of vessels to acquire for the user
    <Exceptions>
      Not sure.
    <Side Effects>
      Performs a change users to geni_user on vessels acquired for the
      user.
    <Returns>
      On success, returns (True, (summary, explanation, acquired))
      where acquired is a list of vessels acquired for the geni
      user. On failure returns (False, (summary, explanation)). In
      boths cases, summary and explanation are strings that summarize
      and explains the success\failure in less/more detail. On
      failure, vessels that were acquired are released.
    """
    explanation = ""
    summary = ""
    
    # shuffle the base vessels set
    vessels = get_base_vessels(geni_user)
    vessels = list(vessels)
    random.shuffle(vessels)

    # alpers - this is the start of parallelized acquisition
    acquired = []
    explanation = ""
    start_index = 0
    end_index = num
    while start_index < len(vessels) and \
          end_index < len(vessels):
      
        print "Trying to acquire " + str(num-len(acquired)) + \
            " vessels starting at index " + str(start_index)
    
        subset = vessels[start_index : end_index]
        new_acquired, new_explanation = parallel_acquire_vessels(subset, geni_user)
    
        acquired.extend(new_acquired)
        explanation += " " + new_explanation

        # if all requested vessels have been acquired, flee the function
        if len(acquired) == num:
            summary = "Acquired all the nodes."
            return True, (summary, explanation, acquired)
    
        # otherwise, increase the vessel index parameters based on the number
        # of vessels that were able to be acquired and retry
        start_index += len(subset)
        end_index = start_index + num - len(acquired)

    release_vessels(acquired)
    explanation = str(len(vessels)) + " vessels available. In these, failed to acquire " + str(num) + " vessels."
    summary = "Failed to acquire nodes."
    return False, (summary, explanation)


"""
<Program Name>
  key_daemon_parser.repy

<Started>
  April 27, 2009

<Author>
  n2k8000@u.washington.edu
  Konstantin Pik

<Purpose>
  This file is to be imported in whatever file is performing the acquisition
  of keys.  Once imported, the get_keypair method can be used to return a 
  pub/priv keypair.
  
  See function definition for sample usage.
"""

def keydaemon_parser_connection_timeout(socketcomm):
  """
  <Purpose>
    Triggered when the timeout is reached for a response, and so it sets 
    a flag and triggers a false value to be returned by get_keypair
    
  <Arguments>
    socketcomm:   handle of the daemon_socket
    
  <Exceptions>
    None.

  <Side Effects>
    None.

  <Returns>
    None.
  """
  
  mycontext['key_daemon_timer_trigger'] = True
  stopcomm(socketcomm)

  
def get_keypair(ip, port, progress_to_console = True, default_timeout = 300):
  """
  <Purpose>
    This function connects to ip:port and waits until
    a keypair is sent, and then the function returns the public and private
    keys as a list.
    
    TODO: How to set up a timeout for .recv(buffsize)?
    
  <Arguments>
    ip:                     The IP that the key_daemon is running on. 
                            Does not have to be remote, can be local loopback.
    port:                   The port that the key_daemon is running on.
    progress_to_console:    Optinal. Default is True.  This prints out the
                            progress of key acquisition. 
    default_timeout:        Optional. Default is 5 minutes.  Sets the timeout
                            (in seconds) for the function to return False if 
                            no response has been received within a this 
                            amount of time.
  <Exceptions>
    Socket errors on connection.
    Timeout error if no response received in a timely manner (not working
    correctly yet)

  <Side Effects>
    None.

  <Returns>
    A list is returned for both success and failure.
    
    (return_status, string1, string2)
   
    On success:
    (True, public_key, private_key)
    
    On failure:
    (False, error, error_description_string)
    
  <Sample Usage>
    get_keypair('127.0.0.1', 12345)
    get_keypair('1.2.3.4', 3344, False)
    get_keypair('1.2.3.4', 3344, True, 60)
  """
  
  try:
    if progress_to_console:
      print 'Connecting...'
    mycontext['key_daemon_timer_trigger'] = False
    daemon_socket = openconn(ip, int(port))
    timeout_timer = settimer(default_timeout, 
      keydaemon_parser_connection_timeout, (daemon_socket,))
    if progress_to_console:
      print 'Connected! Sending key request...'
    daemon_socket.send('newkey\n')
  except Exception, e:
    if progress_to_console:
      print e
    return (False, 'Socket Error', 'Trouble connecting to host ('+str(ip) + \
      ':'+str(port)+')')
  else:
    newline_counter = 0
    incoming_data = ''
    
    if progress_to_console:
      print 'Waiting for key...'
    
    while newline_counter < 2 and not mycontext['key_daemon_timer_trigger']:
        incoming_data += daemon_socket.recv(512)
        newline_counter = incoming_data.count('\n')        
      
    if mycontext['key_daemon_timer_trigger']:
      return (False, 'Timeout Error', 'A response could not be obtained' + \
        ' in the specified amount of time ('+str(default_timeout)+' minutes).')
    canceltimer(timeout_timer)

    if progress_to_console:
      print 'Key received successfully!'
    
    keypair = incoming_data.splitlines()
    public_key_string = keypair[0]
    private_key_string = keypair[1]
    return (True, public_key_string, private_key_string)
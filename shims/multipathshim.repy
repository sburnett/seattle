#!python
"""
<Purpose>
  A shim that creates several shimstacks underneath it
  and sends and receives data through all its shimstacks.
  It is essentially a multipath shim, which is used in 
  hopes of reducing congestion on a particular shimstack.

<Author>
  Monzur Muhammad
  monzum@cs.washington.edu

<Started>
  April 18th, 2011

<History>
  04-18-11: Initial implementation.
"""

#dy_import_module_symbols("shim_stack")
dy_import_module_symbols("msg_chunk_lib")
import sys
DATA_CHUNK_SIZE = 2**10




class MultiShimSocket():

  def __init__(self, connection_dict):

    # Store the connection dict and create a 
    # new chunk object that will help us send
    # and receive all the data through all the 
    # connections.
    self._connection_dict = connection_dict 
    self._chunk_object = ChunkMessage(DATA_CHUNK_SIZE, DATA_CHUNK_SIZE)
    self._sockets_open = True


  def get_stats(self):
    return self._chunk_object.data_sent_distribution()

  def send(self, msg):
    """
    <Purpose>
      Split the message up into chunks, and send parts of it
      across all the shim stacks.
   
    <Arguments>
      msg - The message to send.

    <Side Effects>
      None

    <Exceptions>
      SocketWouldBlock raised if all sockets raise it.

      SocketClosedRemote or SocketClosedLocal raised if we 
      get socket closed error.

    <Return>
      The amount of data sent.
    """

    # If the close() function has already been called.
    if not self._sockets_open:
      raise SocketClosedLocal("All sockets closed locally.")

    # Retrieve a list of socket objects that has already been 
    # added to the chunk object. Note that these are the string
    # form of the sockets.
    chunk_object_socket_list = self._chunk_object.get_socket_list()

    # If any of the sockets have not been added to the chunk object
    # yet, we do it now.
    for cur_shim in self._connection_dict:
      sockobj = self._connection_dict[cur_shim]['sockobj']
      if repr(sockobj) not in chunk_object_socket_list:
        self._chunk_object.add_socket(sockobj)


    # Send the data.
    data_sent = self._chunk_object.senddata(msg)

    # Return the amount of data sent.
    return data_sent




  def recv(self, bytes):
    """
    <Purpose>
      Return a message of the requested byte size.

    <Arguments>
      bytes - The amount of data to return.

    <Side Effects>
      None

    <Exceptions>
      SocketWouldBlock raised if all sockets raise it.

      SocketClosedRemote or SocketClosedLocal raised if we
      get socket closed error.

    <Return>
      A message of size byte or less.
    """

    # If the close() function has already been called.
    if not self._sockets_open:
      raise SocketClosedLocal("All sockets closed locally.")

    # Retrieve a list of socket objects that has already been
    # added to the chunk object. Note that these are the string
    # form of the sockets.
    chunk_object_socket_list = self._chunk_object.get_socket_list()

    # If any of the sockets have not been added to the chunk object
    # yet, we do it now.
    for cur_shim in self._connection_dict:
      sockobj = self._connection_dict[cur_shim]['sockobj']
      if repr(sockobj) not in chunk_object_socket_list:
        self._chunk_object.add_socket(sockobj)


    # Return the amount of data sent.
    return self._chunk_object.recvdata(bytes)
    





  def close(self):
    """
    <Purpose>
      Close all the sockets that are open for each of the 
      shimstacks. Before we close all the sockets, we add
      all the sockets to the chunk object. This if for the
      case if a new sockobj has been established in 
      _connection_dict since the last call to recv or send.

    <Arguments>
      None

    <Side Effects>
      None

    <Exceptions>
      None

    <Return>
      None
    """

    # Retrieve a list of socket objects that has already been
    # added to the chunk object. Note that these are the string
    # form of the sockets.
    chunk_object_socket_list = self._chunk_object.get_socket_list()

    # If any of the sockets have not been added to the chunk object
    # yet, we do it now.
    for cur_shim in self._connection_dict:
      sockobj = self._connection_dict[cur_shim]['sockobj']
      if repr(sockobj) not in chunk_object_socket_list:
        self._chunk_object.add_socket(sockobj)

    # Mark the sockets as being closed.
    self._sockets_open = False

    # Close all the sockets.
    self._chunk_object.close()
    






class MultiShimTCPSocket():

  def __init__(self, tcpsocket_dict):
    self.tcpsocket_dict = tcpsocket_dict
    self.connection_dict = {}




  def getconnection(self):
    exception_list = []

    # Default remotehost and port
    remoteip = '127.0.0.1' 
    remoteport = '80'

    # We want to do at least one pass to try and see if we can make
    # any connection.
    for cur_tcp_socket in self.tcpsocket_dict.keys():
      try:
        # Call getconnection() on this tcp socket object
        (remoteip, remoteport, sockobj) = self.tcpsocket_dict[cur_tcp_socket]['tcpsockobj'].getconnection()
        
        sys.stdout.flush()
        if cur_tcp_socket not in self.connection_dict.keys():
          self.connection_dict[cur_tcp_socket] = {}

        # Once connection has been made, add the socket object to connection_dict
        self.connection_dict[cur_tcp_socket]['sockobj'] = sockobj
      except Exception, err:
        exception_list.append(err)
        pass

    # If atleast one connection was established.
    if len(self.connection_dict.keys()) > 0:
      createthread(self.multiple_getconnection_thread)
      return (remoteip, remoteport, MultiShimSocket(self.connection_dict))

    elif len(exception_list) > 0:
      raise exception_list[0]

    else:
      raise ShimInternalError("Internal error in MultiShimTCPSocket.getconnection()")




  def multiple_getconnection_thread(self):
    """
    Keep trying to do getconnection on all the tcp socket objects.
    """

    all_connected = False

    while not all_connected:
      all_connected = True

      for cur_tcp_socket in self.tcpsocket_dict.keys():
        # Check to see if we are already connected.
        if cur_tcp_socket in self.connection_dict.keys():
          continue

        try:
          # Try to connect to this tcp socket
          (remoteip, remoteport, sockobj) = self.tcpsocket_dict[cur_tcp_socket]['tcpsockobj'].getconnection()
          
          # This is the first time we have connecte to this tcp socket.
          self.connection_dict[cur_tcp_socket] = {}
          self.connection_dict[cur_tcp_socket]['sockobj'] = sockobj
        except:
          # If there is any exception we don't raise it because we have already made
          # one successful connection.
          # If we have gotten an exception then there is atleast one tcp socket that
          # we haven't been able to connect to.
          all_connected = False



  
  def close(self):
    """
    Closes all the tcp socket objects that it has open.
    """

    for cur_tcp_socket in self.tcpsocket_dict.keys():      
      self.tcpsocket_dict[cur_tcp_socket].close()  

    




class MultiPathShim(BaseShim):


  def __init__(self, shim_stack=ShimStack(), optional_args=None):
    """
    <Purpose>
      Initialize the MultiPathShim. Creates all the different
      shimstacks that it needs to use.

    <Arguments>
      shim_stack - the shim stack that will be initially beneath
          us. If optional_args is provided then it will be used
          to create the shim stacks that will be used, but this
          will be the default shim stack.

      optional_args - If any optional args is provided, then it will
          be used to create shim stacks.
          
    <Side Effects>
      Multiple shim stack objects are created.
      
    <Exceptions>
      ShimArgumentError will be raised if the arguments provided
      is of not the right form or are incorrect.

      Assertion error if optional args is not type of list.

    <Return>
      None
    """

    self.shim_str_list = optional_args
    self.shim_stack_dict = {}
    self.connection_dict = {}
    self.tcpsocket_dict = {}

    # If optional args was provided, make sure it was a list type.
    if optional_args:
      assert(isinstance(optional_args, list))

      for shim_str in optional_args:
        localhost = shim_stack.shim_stack_context['localhost']
        cur_stack = ShimStack(shim_str, localhost)
        self.shim_stack_dict[shim_str] = cur_stack

    else:
      self.shim_stack_dict['default'] = shim_stack

    for cur_shim in self.shim_stack_dict.keys():
      try:
        self.shim_stack_dict[cur_shim].peek()
      except ShimStackError:
        find_and_register_shim('NoopShim')
        shim_object = self.shim_stack_dict[cur_shim].create_shim_object('NoopShim', [], ShimStack())
        self.shim_stack_dict[cur_shim].push(shim_object)
    
    
    BaseShim.__init__(self, shim_stack, optional_args)






  # ========================= TCP Connection ==================================

  def openconnection(self, destip, destport, localip, localport, timeout):
    """
    <Purpose>
      Opens a connection using all the shimstacks that is beneath us.

    <Arguments>
      destip - the destination ip address.
      destport - the destination port number.
      localip - the local ip address.
      localport - the localport number.
      timeout - time before we should timeout.

    <Side Effects>
      Multiple connections are opened.

    <Exceptions>
      AddressBindingError - if the localip can't be bound to.

      DuplicateTupleError - if the args provided are already being
          used. Also if OS prevents the local IP/port from being used.

      AlreadyListeningError - raised if local IP/port is already listening
          a TCP socket.

      ConnectionRefusedError - If connection cannot be made because the
          destination port isn't being listened on.

      InternetConnectivityError - if network is down.
 
    <Return>
      A MultiShimSocket object.
    """

    self._destip = destip
    self._locaip = localip
    self._timeout = timeout

    # Because we are opening up multiple connections. We are going to 
    # use different port number for each.
    port_addition = 0
    
    exception_list = []

    # We want to do at least one pass to try and see if we can make
    # any connection.
    for cur_shim_stack in self.shim_stack_dict.keys():
      try:
        # Increate the port number by the appropriate value.
        # BUG: This is a bad way to do it as if the application layer
        # uses one of the ports that we are trying to use, it will collide.
        # A more elegant way might be to have random port numbers, and 
        # advertise or have a way for the server and client to communicate/
        # agree on which ports to use.
        destport += port_addition
        localport += port_addition
        port_addition += 1

        # Call openconnection on the top shim of this particular shimstack.
        sockobj = self.shim_stack_dict[cur_shim_stack].peek().openconnection(destip, destport, 
                                                                             localip, localport, timeout)

        self.connection_dict[cur_shim_stack] = {}
        self.connection_dict[cur_shim_stack]['destport'] = destport
        self.connection_dict[cur_shim_stack]['localport'] = localport

        # Once connection has been made, add the socket object to connection_dict
        self.connection_dict[cur_shim_stack]['sockobj'] = sockobj

      except Exception, err:
        exception_list.append(err)
        pass

    if len(self.connection_dict.keys()) > 0:
      createthread(self.multiple_openconn_thread)
      return MultiShimSocket(self.connection_dict)  

    elif len(exception_list) > 0:
      raise exception_list[0]

    else:
      raise ShimInternalError("Internal error in openconnection.")





  def multiple_openconn_thread(self):
    """
    Keep trying to do openconnection on all the shimstacks.
    """

    all_connected = False

    while not all_connected:
      all_connected = True      

      for cur_shim_stack in self.shim_stack_dict.keys():
        # Check to see if we are already connected.
        if cur_shim_stack in self.connection_dict.keys():
          continue

        try:
          sockobj = self.shim_stack_dict[cur_shim_stack].peek().openconnection(self._destip,
                        self.connection_dict[cur_shim_stack]['destport'], self._localip,
                        self.connection_dict[cur_shim_stack]['localport'], self._timeout)
      
          self.connection_dict[cur_shim_stack] = {}
          self.connection_dict[cur_shim_stack]['sockobj'] = sockobj
        except:
          # If there is any exception we don't raise it because we have already made
          # one successful connection.
          # If we have gotten an exception then there is atleast one shimstack that
          # we haven't been able to connect to.
          all_connected = False
                                          




  def listenforconnection(self, localip, localport):
    """
    <Purpose>
      Listens for a connection on all shimstacks.

    <Arguments>
      localip - our local IP address.
      localport - the lolcal port to listen on.

    <Side Effects>
      We have multiple TCPServerSockets created to listen on.

    <Exceptions>
      AddressBindingError - if the localip can't be bound to.

      DuplicateTupleError - if the args provided are already being
          used. Also if OS prevents the local IP/port from being used.

      AlreadyListeningError - raised if local IP/port is already listening
          a TCP socket.

    <Return>
      MultiShimTCPSocket object.
    """

    self._localip = localip

    exception_list = []
    port_addition = 0

    for cur_shim_stack in self.shim_stack_dict.keys():
      try:
        # Increate the port number by the appropriate value.
        # BUG: This is a bad way to do it as if the application layer
        # uses one of the ports that we are trying to use, it will collide.
        # A more elegant way might be to have random port numbers, and
        # advertise or have a way for the server and client to communicate/
        # agree on which ports to use.
        localport += port_addition
        port_addition += 1

        # Call listenforconnection on the top shim of this particular shimstack.
        tcpsockobj = self.shim_stack_dict[cur_shim_stack].peek().listenforconnection(localip, localport)

        if cur_shim_stack not in self.tcpsocket_dict.keys():
          self.tcpsocket_dict[cur_shim_stack] = {}

        self.tcpsocket_dict[cur_shim_stack]['localport'] = localport
        self.tcpsocket_dict[cur_shim_stack]['tcpsockobj'] = None

        # Once connection has been made, add the tcpsocket object to connection_dict
        self.tcpsocket_dict[cur_shim_stack]['tcpsockobj'] = tcpsockobj
      except Exception, err:
        exception_list.append(err)
        pass

    if len(self.tcpsocket_dict.keys()) > 0:
      createthread(self.multiple_listenforconnection_thread)
      return MultiShimTCPSocket(self.tcpsocket_dict)

    else:
      raise exception_list[0]
    pass





  def multiple_listenforconnection_thread(self):
    """
    Keep trying to do openconnection on all the shimstacks.
    """

    all_connected = False

    # While everything is not connected, keep trying to connect.
    # Note that once close() is called on the tcpsocket object,
    # tcpsocket_dict will become empty, which will cause this loop
    # to end and thus terminate this thread as its supposed to.
    while not all_connected:
      all_connected = True  

      for cur_shim_stack in self.shim_stack_dict.keys():
        if cur_shim_stack not in self.tcpsocket_dict.keys():
          tcpsocket_dict[cur_shim_stack] = {}
          tcpsocket_dict[cur_shim_stack]['tcpsockobj'] = None
          tcpsocket_dict[cur_shim_stack]['localport'] = 0

        # Check to see if we are already connected.
        if self.tcpsocket_dict[cur_shim_stack]['tcpsockobj']:
          continue

        try:
          tcpsockobj = self.shim_stack_dict[cur_shim_stack].peek().listenforconnection(self._localip,
                           self.tcpsocket_dict[cur_shim_stack]['localport'])

          self.tcpsocket_dict[cur_shim_stack]['tcpsockobj'] = tcpsockobj
        except:
          # If there is any exception we don't raise it because we have already made
          # one successful connection.
          # If we have gotten an exception then there is atleast one shimstack that
          # we haven't been able to connect to.
          all_connected = False






  # ============= Required Public Methods =========================
  def copy(self):
    """
    Make and return a copy of self.
    """

    mycopy = MultiPathShim()

    mycopy.connection_dict = self.connection_dict.copy()
    mycopy.tcpsocket_dict = self.tcpsocket_dict.copy()
    mycopy.shim_stack_dict = self.shim_stack_dict.copy()
    mycopy.shim_str_list = self.shim_str_list[:]

    return mycopy




  def get_advertisement_string(self):
    """
    Return the advertisement string for this shim.
    """
    my_name = '(MultiPathShim,%s)' % ','.join(self.shim_str_list)
    return my_name + self.get_next_shim_layer().get_advertisement_string()



  
  
    

#!python
"""
<Program Name>
  msg_chunk_lib.repy

<Author>
  Monzur Muhammad (monzum@cs.washington.edu)
  Originally written by Danny Y. Huang (yh1@cs.williams.edu)

<Purpose>
  Helps chunk out a message for sending and receiving
  message across a network.
"""

dy_import_module_symbols("shim_exceptions")


MIN_BLK_SIZE = 2**8
MAX_BLK_SIZE = 2**18


class ChunkMessage():

  def __init__(self, send_blk_size = 2**11, recv_blk_size = 2**11):
    
    # The size of each block in which the original message is
    # broken up into initially.
    self._SEND_BLOCK_SIZE = send_blk_size
    self._RECV_BLOCK_SIZE = recv_blk_size

    # Assume that the header in the msg we send and receive is at
    # most of lenght 20 characters.
    self.max_header_size = 20

    # Each socket will have its own block size for receiving and
    # sending. The sockets that work better will have bigger block
    # sizes, and the sockets that don't work as well have smaller
    # block sizes. Every time a socket blocks, its block size is
    # halfed, and every time it succeeds, its block size is doubled.
    self.sock_send_blk_size = {}
    self.sock_recv_blk_size = {}


    # A dictionary that maps a socket to its receive buffer, which stores
    # the TCP message stream.
    # for the recv buffer.
    self._recv_buf_dict = {}

    # Global chunk id values for both recv and send. 
    self._send_chunk_id = 0
    self._recv_chunk_id = 0

    # A dictionary that holds the result stream of TCP message.
    self._result_buf_dict = {}

    # A string that holds all the incoming TCP messages that have been
    # received in order. The buffer has data that can be returned.
    self.global_recv_buffer = ''

    # A set that keeps track of all the sockets that are active
    # currently. If a socket is 'open' it is considered active.
    self._active_socket_set = set()

    # Keep a set of all the sockets.
    self._complete_socket_set = set()

    # Keeps track of how much data each socket sent and received.
    self._data_sent_dict = {}
    self._data_recv_dict = {}

    self.total_sent = 0
    self.total_recv = 0


    # Keeps track of weather close() was called locally.
    self._closed_local = False
    self._closed_remote = False

    # The send buffer that holds everything that will be send.
    self.send_buffer = ""



      



  def get_socket_list(self):
    """
    Returns the set of sockets that have been added so far.
    """
    return self._complete_socket_set

  

  def get_recv_buffer(self):
    """
    Returns the local recv buffer for all the sockets.
    """
    return self._recv_buf_dict.copy()


  def get_send_buffer(self):
    """
    Returns the local send buffer for all the sockets.
    """
    return self._send_buf_dict.copy()


  def get_data_sent_distribution(self):
    """
    Return the dictionary that keeps track of how
    much data was sent through each of the sockets.
    """
    return self._data_sent_dict.copy()


  def get_data_recv_distribution(self):
    """
    Return the dictionary that keeps track of how 
    much data was received through each of the sockets.
    """
    return self._data_recv_dict.copy()



  def get_total_block_size(self):
    """
    Return the total block size of all the sockets added
    together.
    """
    total_size = 0

    for cur_sockobj in self._active_socket_set:
      total_size += self.sock_send_blk_size[repr(cur_sockobj)]

    return 2 * total_size




  def add_socket(self, socket):
    """
    <Purpose>
      We are going to add a new socket to this object.
      In doing so we will create an entry for it in 
      _recv_buf_dict and _active_recv_socket_set.

    <Arguments>
      socket - a socketlike object.

    <Side Effects>
      None

    <Exceptions>
      None

    <Return>
      None
    """

    # Initialize the receive buffer that stores the raw TCP stream, from which
    # we reconstruct the blocks. Also we assume that this is an active socket
    # so we add it to the active set.
    if not self._recv_buf_dict.has_key(repr(socket)):
      self._recv_buf_dict[repr(socket)] = ''

    
    # If its a new socket then we create a data sent dict and add it
    # to the complete socket list.
    if socket not in  self._complete_socket_set:
      self._complete_socket_set.add(socket)

    # Initialize the data sent dictionary for this new
    # socket.
    if repr(socket) not in self._data_sent_dict.keys():
      self._data_sent_dict[repr(socket)] = 0

    # Initialize the data recv dictionary for this new
    # socket.
    if repr(socket) not in self._data_recv_dict.keys():
      self._data_recv_dict[repr(socket)] = 0
    
    # Add the socket in the active list.
    self._active_socket_set.add(socket)
    

    # Initialize the sock_send_blk and sock_recv_blk dictionaries.
    if repr(socket) not in self.sock_send_blk_size.keys():
      self.sock_send_blk_size[repr(socket)] = self._SEND_BLOCK_SIZE
    
    if repr(socket) not in self.sock_recv_blk_size.keys():
      self.sock_recv_blk_size[repr(socket)] = self._RECV_BLOCK_SIZE
 

    # If the length of active socket set is now 1, then we have to start
    # up the send msg thread and recv message thread as it hasn't been
    # started yet, since the lenght of active socket set would have been
    # 0 before.
    if len(self._active_socket_set) == 1:
      createthread(self.send_msg_thread)
      createthread(self.recv_msg_thread)





  def close(self):
    """
    Close all the active sockets and take them
    out of the active socket set.
    """
    if self._closed_local:
      return False

    while self.send_buffer:
      sleep(0.001)

    self._closed_local = True
    for socket in self._active_socket_set.copy():
      try:
        socket.close()
      except:
        pass
    self._active_socket_set.clear()

    return True




  def senddata(self, msg):
    """
    <Purpose>
      Appends the data to the send buffer, if the send buffer is empty.
      Otherwise we raise a SocketWouldBlockError.
    
    <Arguments>
      Same as repy v2 socket API.

    <Exceptions>
      Same as repy v2 socket API.

    <Side Effects>
      Same as repy v2 socket API.

    <Returns>
      Same as repy v2 socket API.

    """

    if self._closed_local:
      # If socket has already been closed, then we raise SocketClosedLocal
      raise SocketClosedLocal("Socket has been closed locally.")
    elif self._closed_remote:
      # If socket has been closed remotely, then we raise SocketClosedRemote
      raise SocketClosedRemote("Socket has been closed remotely.")
    elif self.send_buffer:
      # If the send buffer is not empty then we raise SocketWouldBlockError
      raise SocketWouldBlockError("Send will block, send buffer full.")

    # We only want to send a message that is as big as the maximum block
    # size, that is the size of all the blocksizes for each socket added
    # together. This is to prevent a user calling send with a giant msg and
    # then having to wait a long time for it to complete.
    msg_send_size = self.get_total_block_size()

    # Append the message in order to send it.
    msg_to_send = msg[:msg_send_size]

    self.send_buffer = self.send_buffer + msg_to_send

    while self.send_buffer:
      sleep(0.001)

    # Assume that the entire message has been sent.
    return len(msg_to_send)





  def recvdata(self, bytes):
    """
    <Purpose>


    <Arguments>
      Same as repy v2 socket API.

    <Exceptions>
      Same as repy v2 socket API.

    <Side Effects>
      Same as repy v2 socket API.

    <Returns>
      Same as repy v2 socket API.

    """
    if self._closed_local:
      # If socket has already been closed, then we raise SocketClosedLocal
      raise SocketClosedLocal("Socket has been closed locally.")
    elif self._closed_remote:
      # If socket has been closed remotely, then we raise SocketClosedRemote
      raise SocketClosedRemote("Socket has been closed remotely.")
    elif len(self.global_recv_buffer) == 0:
      # If the send buffer is not empty then we raise SocketWouldBlockError
      raise SocketWouldBlockError("Send will block, send buffer full.")

    # If we have enough data in the buffer we just return it.
    requested_data = self.global_recv_buffer[ : bytes]
    self.global_recv_buffer = self.global_recv_buffer[bytes : ]
    return requested_data






  def send_chunk(self, sockobj, data):
    """
    <Purpose>
      The purpose of this function is to send data in 
      a sudo blocking fashion. This method works similarly
      to the session library. Except we raise a 
      SocketWouldBlockError if we block in the beginning.
      If we block in the middle then we just note it and 
      notify the sending thread that we blocked once.
    """
    started_sending_msg = False
    blocked_atleast_once = False

    # The header will contain the length of the message as well
    # as the current chunk id.
    header = "%d,%d\n" % (len(data), self._send_chunk_id)
    fulldata = header + data

    total_sent= 0
    # While we have data, keep sending.
    while fulldata:
      try:
        bytes_sent = sockobj.send(fulldata)
      except SocketWouldBlockError:

        if started_sending_msg:
          # If we get a SocketWouldBlockError but have
          # already started sending data, then we keep 
          # sending until we finish.
          blocked_atleast_once = True
          sleep(0.001)
          continue
        else:
          # If this is the first send call and we block,
          # then we raise SocketWouldBlockError.
          raise SocketWouldBlockError("Socket blocked!")
      else:
        fulldata = fulldata[bytes_sent:]
        started_sending_msg = True

    # Increase the chunk id after we have successfully sent the data.
    self._send_chunk_id += 1

    # Keep track of how much data we sent.
    self._data_sent_dict[repr(sockobj)] += len(data)
    
    return blocked_atleast_once
    
  



  def send_msg_thread(self):
    """
    <Purpose>
      This purpose of this method is to send the data across. This
      thread checks the send buffer to see if anything needs to be
      sent, and if there is then we send it all.

    <Arguments>
      None

    <Side Effects>
      None

    <Exceptions>
      None

    <Return>
      None
    """
    
    # Make a copy of the complete socket set so we don't distrupt
    # with other methods when we change it.
    complete_sock_copy = self._complete_socket_set.copy()


    # Keep running this thread as long as the "close" call hasn't been
    # called locally and there is at least one active socket.
    while not self._closed_local and len(self._active_socket_set) > 0:
      # Check to see if there is anything in the buffer for us to send.
      # MMM: Do we need a lock for this? After thinking about it, I decided
      # that we are going to be storing the message in a buffer which is
      # a string, and the operations we perform on it are atomic.
      sleep(0.0001)
      while self.send_buffer:
        # If any new socket connections have been made since we started this
        # thread, then we add them to our local copy.
        for new_sockobj in (self._complete_socket_set - complete_sock_copy):
          complete_sock_copy.add(new_sockobj)

        # We will send the data through the sockets in a round
        # robin fashion. This is to ensure that no one socket
        # gains advantage because of its order. We will look
        # at all the sockets. So we pop the socket from the head
        # and append it to the tail.
        cur_socket = complete_sock_copy.pop()
        complete_sock_copy.add(cur_socket)

        # If the socket is not active anymore then we move on
        # to the  next socket.
        if cur_socket not in self._active_socket_set:
          continue

        
        # Create a block of data from the original message.
        # Then reduce the message size since we took out the 
        # beginning chunk.
        blk_size = self.sock_send_blk_size[repr(cur_socket)]
        block_body = self.send_buffer[ : blk_size]

        # Try sending the chunk through the current socket.
        try:
          socket_blocked = self.send_chunk(cur_socket, block_body)
        except SocketWouldBlockError:
          # If we block then we want to reduce the block size
          # of the current socket.
          blk_size = blk_size/2
            
          # Makes sure that the minimum block size isn't too small.
          if blk_size < MIN_BLK_SIZE:
            blk_size = MIN_BLK_SIZE

          self.sock_send_blk_size[repr(cur_socket)] = blk_size
        except (SocketClosedLocal, SocketClosedRemote), err:
          # If we get a socket closed remote error, we remove it
          # from the active socket list.
          self._active_socket_set.discard(cur_socket)
        else:
          # Update the send buffer.
          self.send_buffer = self.send_buffer[blk_size : ]

          # If we successfully send the data, then we double the
          # block size if we did not block at all.
          if socket_blocked:
            blk_size = blk_size/2
            # Makes sure that the minimum block size isn't too small.
            if blk_size < MIN_BLK_SIZE:
              blk_size = MIN_BLK_SIZE
          else:
            blk_size = blk_size*2
            if blk_size > MAX_BLK_SIZE:
              blk_size = MAX_BLK_SIZE

          # Update the block size accordingly.
          self.sock_send_blk_size[repr(cur_socket)] = blk_size
       

    # If there are no more active sockets, we assume that the socket has
    # been closed remotely.
    if len(self._active_socket_set) == 0:
      self._closed_remote = True






  def recv_msg_thread(self):
    """
    <Purpose>
      Receives as much as possible into the receive buffer until the socket
      blocks.

      Then, from the receive buffer, we reconstruct all the completely received
      blocks. A complete block is a string in the form of "n,msg", where n is
      the length of msg.
   
    <Arguments>
      None

    <Side Effects>
      None

    <Exceptions>
      None

    <Return>
      None
    """
    
    # Make a copy of the complete socket set so we don't distrupt
    # with other methods when we change it.
    complete_sock_copy = self._complete_socket_set.copy()


    # Keep running this thread as long as the "close" call hasn't been
    # called locally and there is at least one active socket.
    while not self._closed_local and len(self._active_socket_set) > 0:
      # If any new socket connections have been made since we started this
      # thread, then we add them to our local copy.
      for new_sockobj in (self._complete_socket_set - complete_sock_copy):
        complete_sock_copy.add(new_sockobj)

      # We are going to go in circle and try to receive on all the
      # sockets.
      cur_socket = complete_sock_copy.pop()
      complete_sock_copy.add(cur_socket)
      
      # If the socket is not active anymore then we move on
      # to the  next socket.
      if cur_socket not in self._active_socket_set:
        continue

      # The amount of data to be received on this socket.
      blk_size = self.sock_recv_blk_size[repr(cur_socket)]
      


      try:
        # Receive the amount of data specified by the block size
        # of this particular socket.
        received_data = cur_socket.recv(blk_size)
      except SocketWouldBlockError:
        # If we block then we reduce the block size of this socket.
        blk_size = blk_size/2

        # Makes sure that the minimum block size isn't too small.
        if blk_size < MIN_BLK_SIZE:
          blk_size = MIN_BLK_SIZE

        self.sock_recv_blk_size[repr(cur_socket)] = blk_size
        continue
      # If a different exception occur, we save it first. We will raise it later
      # when we run out of data to return (i.e. empty result buffer). The socket
      # is now considered inactive. We remove it from the active socket set.
      except (SocketClosedLocal, SocketClosedRemote), err:
        self._active_socket_set.discard(cur_socket)
      else:     
        # If we have successfully received data on this socket, then 
        # we double the block size.
        blk_size = blk_size*2

        if blk_size > MAX_BLK_SIZE:
          blk_size = MAX_BLK_SIZE
        self.sock_recv_blk_size[repr(cur_socket)] = blk_size
        
        # Now that we have received data on this block, we are going
        # to add it to the buffer. We use a lock to ensure that there
        # isn't any conflict.
        self._recv_buf_dict[repr(cur_socket)] += received_data
        self._reconstruct_blocks(cur_socket)
      self._construct_result_buf()

    # End while loop

    # If there are no more active sockets, we assume that the socket has
    # been closed remotely.
    if len(self._active_socket_set) == 0:
      self._closed_remote = True




  def _reconstruct_blocks(self, sockobj):
    """
    Helper method that helps reconstruct blocks that were received by a socket.
    The buffer should have blocks in the form of msg_length,chunk_id\nMSG.
    We greedily try to reconstruct as many blocks as we can.
    """

    # We keep trying to reconstruct blocks while our recv buffer is not empty 
    # and/or we are unable to reconstruct a block because the entire chunk has
    # not arrived yet.
    while True:
      if not self._recv_buf_dict[repr(sockobj)]:
        return
      
      
      # Get the receive buffer.
      recv_buf = self._recv_buf_dict[repr(sockobj)][:]
 
      # Stores the header of the message.
      header = ''
      msg_len = 0
      chunk_id = -1

      # Go through the header until we find the end of the header.
      while recv_buf:
        # Read one byte at a time.
        currentbyte = recv_buf[0]
        recv_buf = recv_buf[1:]
        
        if currentbyte == '\n':
          break
        else:
          header += currentbyte

      
      # Try to break up the header. If we are unable to do this
      # then we must not have received the entire header for the
      # message yet. So we just return.
      try:
        msg_len_str, chunk_id_str = header.split(',')
      except ValueError:
        return

      # This is the case where the chunk id hasn't been fully 
      # transmitted yet. (Example header: '1024,' )
      if not chunk_id_str:
        return

      msg_len = int(msg_len_str)
      chunk_id = int(chunk_id_str)
      
      # If the receive buffer lenght is less then the expected message
      # lenght, then we must not have the entire chunk.
      if len(recv_buf) < msg_len:
        return

      msg_body = recv_buf[ : msg_len]
      recv_buf = recv_buf[msg_len : ]

      # Add the message chunk to the result buf dictionary and update
      # the receiver buffer with the new receiver buffer.
      self._result_buf_dict[chunk_id] = msg_body
      self._recv_buf_dict[repr(sockobj)] = recv_buf
      self.total_recv += len(msg_body)
      self._data_recv_dict[repr(sockobj)] += len(msg_body)
            





  def _construct_result_buf(self):
    """
    Used to construct the global recv buffer.
    """
    
    # Try to read as many chunks as possible in a row that is available
    # and construct the global buffer.
    # Note that if we have so far extracted the chunks 1,2,3,5,7,8,9 then
    # we will take out the chunks 1,2,3 and add them to the global recv
    # buffer. We will wait until chunk 4 has arrived before we continue
    # filling up the global buffer. Once we have extracted a chunk from 
    # the result dictionary, we are going to delete the chunk from the 
    # result dictionary and increase the chunk id number (the id of the
    # next chunk that we expect to see).
    while self._result_buf_dict.has_key(self._recv_chunk_id):
      result_buf_msg = self._result_buf_dict[self._recv_chunk_id]     
      self.global_recv_buffer += result_buf_msg
      try:
        self._result_buf_dict.pop(self._recv_chunk_id)
      except:
        # In case something went wrong and the key doesn't exist anymore.
        pass
      # Increment the recv chunk id.
      self._recv_chunk_id += 1

    





"""
<Program Name>
  coordinationshim.repy

<Author>
  Danny Y. Huang, yh1@cs.williams.edu
  Monzur Muhammad, monzum@cs.washington.edu

<Date Started>
  March 24, 2011

<Purpose>
  Advertises the server's string representation of its shim stack. When a client
  is about to connect to this server, the coordination shim looks up the string
  representation and constructs the same shims. At this point, both the server
  and the client have the same shims. As their shim stacks are balanced, the
  connection is established and ready to be returned to the application.

  The advertisement key for a server is "host,port,protocol", where host is the
  hostname of the server and protocol can be either UDP or TCP. The
  advertisement value is the string representation of the CoordinationShim's
  shim stack.

  The coordination shim should always sit on top of an application's shim stack,
  so that it can see the content of the rest of the stack.

"""

dy_import_module_symbols("advertise_objects")
dy_import_module_symbols("shim_exceptions")




class CoordinationShim(BaseShim):



  # A dictionary that maps a server socket object to the corresponding
  # advertisement handle. We need to save all the handles that are created as
  # the listener starts, so that, when the server socket's close() is called, we
  # can retrieve these handles and stop the advertisement.
  _adv_handle_dict = {}

  # Protects the dictionary above from concurrent modification.
  _adv_handle_dict_lock = createlock()



  def copy(self):
    return CoordinationShim(self.shim_context['shim_stack'].copy(), self.shim_context['optional_args'])



  def get_advertisement_string(self):
    return '(CoordinationShim)' + self.get_next_shim_layer().get_advertisement_string()



  # ===================================================================
  # TCP
  # ===================================================================



  def listenforconnection(self, localip, localport):
    """
    <Purpose>
      Listens for incoming connections. Advertises the shim stack when the
      listener is ready.

    <Arguments>
      Same as the network API in repy v2.

    <Side Effects>
      See the documentation of AdvertiseObjects.

    <Exceptions>
      Same as the network API in repy v2.    

    <Returns>      
      Same as the network API in repy v2.    

    """
    # Start listening so we have a complete view of the shim stack below us.
    tcpserversocket = self.get_next_shim_layer().listenforconnection(localip, localport)

    # The underlying shim stack has been built completely. We can advertise the
    # shim stack.
    adv_key = str(localip) + ',' + str(localport) + ',TCP'
    adv_value = self.get_next_shim_layer().get_advertisement_string()
    log('zzzz Advertised', adv_key, adv_value, '\n')
    adv_handle = AdvertisePipe().add(adv_key, adv_value)

    # We need to save the advertisement handle to a global dictionary, so that
    # we can keep a reference to the handle. Later on, when we stop listening,
    # we can conveniently remove this key value pair from the advertisement
    # service by using this handle.
    self._adv_handle_dict_lock.acquire(True)
    self._adv_handle_dict[repr(tcpserversocket)] = adv_handle
    self._adv_handle_dict_lock.release()

    return ShimTCPServerSocket(tcpserversocket, self)
    
    


  def tcpserversocket_close(self, tcpserversocket):
    """
    Stops listening and stops advertising the server.

    """
    close_result = self.get_next_shim_layer().tcpserversocket_close(tcpserversocket)

    # Now that we have closed the listener without any exceptions, we can safely
    # stop the advertisement.
    self._stop_advertisement(tcpserversocket)

    return close_result




  def openconnection(self, destip, destport, localip, localport, timeout):
    """
    <Purpose>
      Looks up the string representation of the server's shim stack. Constructs
      the same shim stack and connects to the server. If the server's shim stack
      is not found or invalid, connects without using shims for backward
      compatibility.

    <Arguments>
      Same as the network API in repy v2.

    <Side Effects>
      See the documentation of AdvertiseObjects.

    <Exceptions>
      Same as the network API in repy v2.    

    <Returns>      
      Same as the network API in repy v2.    

    """
    # Keep track of how much time we have spent to avoid exceeding the timeout.
    start_time = getruntime()

    # Look up the server's shim stack under this key.
    server_key = str(destip) + ',' + str(destport) + ',TCP'
    lookup_result_list = LookupCache().lookup(server_key)

    # Reverse the results as the latest shim advertisement always comes last.
    lookup_result_list.reverse()

    # We remember all the shims that fail to connect, so that we can piggyback
    # this error report along with TimeoutError.
    failed_shim_str = ''

    # We go through all the possible shim stack strings advertised. The list
    # will most likely contain only one value, but it is possible that a shim
    # may advertise two different values under the same key because its shim
    # stack had somehow changed.
    for server_shim_stack_str in lookup_result_list:

      # Build my shim stack
      localhost = self.shim_context['shim_stack'].shim_stack_context['localhost']
      self.shim_context['shim_stack'] = ShimStack(server_shim_stack_str, localhost)
      log('zzzz Trying shim stack', self.get_next_shim_layer(), '\n')
      # Check if we have exceeded the time limit.
      time_taken = getruntime() - start_time
      if time_taken > timeout:
        raise TimeoutError("CoordinationShim: We have spent too much time looking up the server's shim stack.")

      # Since we spent some time contacting the advertisement service, we have
      # less time for the actual openconn.
      try:
        sock = self.get_next_shim_layer().openconnection(destip, destport, localip, localport, timeout - time_taken)
        return ShimSocket(sock, self.copy())

      # We ignore the error here, as we may have been contacting a legacy
      # server. Later, we're going to retry without shims.
      except NetworkError, err:
        failed_shim_str += server_shim_stack_str + '[' + str(err) + ']; '

    # It is possible we're contacting a legacy server that doesn't use shims,
    # because either it doesn't advertise itself, or none of the advertised shim
    # stacks works. Thus, we contact it without shims.
    time_taken = getruntime() - start_time
    if time_taken < timeout:
      sock = openconnection(destip, destport, localip, localport, timeout - time_taken)
      return ShimSocket(sock, self.copy())

    # Piggyback the failure information on the TimeoutError.
    else:
      raise TimeoutError("CoordinationShim: Failed to connect with shims - " + failed_shim_str)




  # ===================================================================
  # UDP
  # ===================================================================


  def listenformessage(self, localip, localport):
    """
    <Purpose>
      Listens for incoming connections. Advertises the shim stack when the
      listener is ready.

    <Arguments>
      Same as the network API in repy v2.

    <Side Effects>
      See the documentation of AdvertiseObjects.

    <Exceptions>
      Same as the network API in repy v2.    

    <Returns>      
      Same as the network API in repy v2.    

    """
    # Start listening so we have a complete view of the shim stack below us.
    udpserversocket = self.get_next_shim_layer().listenformessage(localip, localport)

    # The underlying shim stack has been built completely. We can advertise the
    # shim stack.
    adv_key = str(localip) + ',' + str(localport) + ',UDP'
    adv_value = self.get_next_shim_layer().get_advertisement_string()
    adv_handle = AdvertisePipe().add(adv_key, adv_value)

    # We need to save the advertisement handle to a global dictionary, so that
    # we can keep a reference to the handle. Later on, when we stop listening,
    # we can conveniently remove this key value pair from the advertisement
    # service by using this handle.
    self._adv_handle_dict_lock.acquire(True)
    self._adv_handle_dict[repr(udpserversocket)] = adv_handle
    self._adv_handle_dict_lock.release()

    return ShimUDPServerSocket(udpserversocket, self)



  def udpserversocket_close(self, udpserversocket):
    """
    Stops listening and stops advertising the server.

    """
    close_result = self.get_next_shim_layer().udpserversocket_close(udpserversocket)

    # Now that we have closed the listener without any exceptions, we can safely
    # stop the advertisement.
    self._stop_advertisement(udpserversocket)

    return close_result



  def sendmessage(self, destip, destport, message, localip, localport):
    """
    <Purpose>
      Looks up the string representation of the server's shim stack. Constructs
      the same shim stack and connects to the server. If the server's shim stack
      is not found, connects without using shims for backward compatibility.

    <Arguments>
      Same as the network API in repy v2.

    <Side Effects>
      See the documentation of AdvertiseObjects.

    <Exceptions>
      Same as the network API in repy v2.    

    <Returns>      
      Same as the network API in repy v2.    

    """
    # Key under which we look up the server's shim stack
    server_key = str(destip) + ',' + str(destport) + ',UDP'

    # Now we obtain the server's shim stack string representation from which we
    # will construct the client's shim stack. 
    lookup_result_list = LookupCache().lookup()

    if lookup_result_list:

      # We asusme that the last result in the list returned contains the most
      # up-to-date server shim stack string. We build a new shim stack based on it.
      server_shim_stack_str = lookup_result_list.pop()
      localhost = self.shim_context['shim_stack'].shim_stack_context['localhost']
      self.shim_context['shim_stack'] = ShimStack(server_shim_stack_str, localhost)
      
      # Send the message using the new shim stack.
      return self.get_next_shim_layer().sendmessage(destip, destport, message, localip, localport)

    else:

      # It is possible we're contacting a legacy server that doesn't use
      # shims. Thus, we contact it without shims.
      return sendmessage(destip, destport, message, localip, localport)




  def _stop_advertisement(self, serversocket):
    """
    Stops advertising on the supplied serversocket, which can be either a
    UDPServerSocket or TCPServerSocket. Helper method for the close methods of
    both sockets.

    """
    # Sanity check.
    assert isinstance(serversocket, UDPServerSocket) or isinstance(serversocket, TCPServerSocket)

    # Retrieve the advertisement handle associated with the current socket and
    # stop the advertisement.
    try:

      self._adv_handle_dict_lock.acquire(True)
      adv_handle = self._adv_handle_dict[repr(serversocket)]

    # Cannot find the handle, so we must have removed it when the close() method
    # was previously invoked. We quietly ignore the error.
    except KeyError:
      pass

    # Stop advertising.
    else:
      AdvertisePipe().remove(adv_handle)

    finally:
      self._adv_handle_dict_lock.release()



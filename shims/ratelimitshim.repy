#!python
"""
<Purpose>
  The RateLimitShim restricts the upload and download throughput of a connection.
  Given a parameter, it will block on send and recv if at any point it seems
  like the throughput will exceed the given parameter.

<Author>
  Monzur Muhammad
  monzum@cs.washington.edu

<Date Started>
  May 19th, 2011
"""


class RateLimitShim(BaseShim):


  def __init__(self, shim_stack = ShimStack(), optional_args = None):
    """
    <Purpose>
      Initialize the Rate Limit Shim.

    <Arguments>
      shim_stack - the shim stack that will be below the RateLimitShim

      optional_args - The arguments if provided will determine the upload
        and download rate of the shim in bytes/sec.

    <Side Effects>
      None

    <Exceptions>
      ShimInternalError raised if the optional args provided is not of the 
      proper format.

    <Return>
      None
    """

    # This is the dictionary that keeps track of the resource that has been
    # consumed as well as that which 
    # We need to use locks to ensure that we send and receive one msg at
    # a time, so we don't accidentally go over the upload/download limit.
    self.net_resources = {'netsend' : {'resource_limit' : 1024 * 1024 * 64, # 64MB/s
                                       'drained_time' : 0.0,
                                       'lock' : createlock()},
                          'netrecv' : {'resource_limit' : 1024 * 1024 * 64, # 64MB/s
                                       'drained_time' : 0.0,
                                       'lock' : createlock()}
                          }


    if optional_args:
      # Ensure that both the arguments that are provided are of the right 
      # format.
      assert(isinstance(optional_args, list))
      assert(len(optional_args) == 2), "Bad optional args. Optional args must contain 2 values (upload_rate/download_rate)"

      # Set the upload rate.
      try:
        self.net_resources['netsend']['resource_limit'] = int(optional_args[0])
      except ValueError:
        raise ShimInternalError("Upload rate provided is not of type int.")

      # Set the download rate
      try:
        self.net_resources['netrecv']['resource_limit'] = int(optional_args[1])
      except ValueError:
        raise ShimInternalError("Download rate provided is not of type int.")

    BaseShim.__init__(self, shim_stack, optional_args)






  def openconnection(self, destip, destport, localip, localport, timeout):
    """
    <Purpose>
      Calls on the next level of shim to do openconnection. This operation
      consumes 64*2 bytes of netsend (SYN, ACK) and 64 bytes of netrecv
      (SYN/ACK)
    """

    self.check_resource('netsend')
    self.check_resource('netrecv')

    sockobj = self.get_next_shim_layer().openconnection(destip, destport, localip, localport, timeout)

    self.consume_resource('netsend', 128)
    self.consume_resource('netrecv', 64)

    return ShimSocket(sockobj, self)
    



  def tcpserversocket_getconnection(self, tcpserversocket):
    """
    <Purpose>
      Calls on the next level of shim for getconnection. This operation consumes 128
      bytes (SYN and ACK) of netrecv and 64 bytes of netsend (ACK packet)
    """

    self.check_resource('netsend')
    self.check_resource('netrecv')

    (remote_ip, remote_port, repy_socket) = self.get_next_shim_layer().tcpserversocket_getconnection(tcpserversocket)

    self.consume_resource('netsend', 64)
    self.consume_resource('netrecv', 128)

    return (remote_ip, remote_port, ShimSocket(repy_socket, self))



  def socket_send(self, socket, msg):
    """
    <Purpose>
      Send the msg through the next shim layer. Consumes netsend of amount
      of data sent + 64. Consumes netrecv of 64.
    """

    self.check_resource('netsend')
    self.check_resource('netrecv')

    data_sent = self.get_next_shim_layer().socket_send(socket, msg)

    # Consume amount of netsend equal to the amount of data sent
    # plus 64.
    self.consume_resource('netsend', data_sent + 64)
    self.consume_resource('netrecv', 64)

    return data_sent




  def socket_recv(self, socket, bytes):
    """
    <Purpose>
      Recv data of length bytes or less. Consumes netrecv of amount of data
      received + 64. Consumes netsend of 64.
    """

    self.check_resource('netsend')
    self.check_resource('netrecv')

    data_recv = self.get_next_shim_layer().socket_recv(socket, bytes)

    # Consume the amount of netrecv equal to the amount of data received
    # plus 64.
    self.consume_resource('netsend', 64)
    self.consume_resource('netrecv', len(data_recv) + 64)

    return data_recv


  
  def socket_close(self, socket):
    """
    <Purpose>
      Closes the socket. Consumes 64 bytes of netrecv and 128 bytes of
      netsend.
    """

    return_val = self.get_next_shim_layer().socket_close(socket)

    self.consume_resource('netsend', 128)
    self.consume_resource('netrecv', 64)

    return return_val




  # ======================================================
  # UDP Section
  # ======================================================
  def sendmessage(self, destip, destport, message, localip, localport):
    """
    <Purpose>
      Calls on the next level of shim. Consumes some netsend resource
      so we take that into account. Consumes the amount of data sent
      + 64 bytes
    """
    self.check_resource('netsend')

    data_sent = self.get_next_shim_layer().sendmessage(destip, destport, message, localip, localport)
 
    # Consume the amount of data sent + 64 bytes.
    self.consume_resource('netsend', data_sent +64)

    return data_sent





  def udpserversocket_getmessage(self, udpserversocket):
    """
    <Purpose>
      Calls on the next level of udpserver_getmessage. We consume
      netrecv in the amount of the lenght of the message + 64 bytes.
    """
    self.check_resource('netrecv')

    msg = self.get_next_shim_layer().udpserversocket_getmessage(udpserversocket)

    # Consume the length of the message + 64 bytes.
    self.consume_resource('netrecv', len(msg) + 64)

    return msg



  # ======================================================
  # Common Section
  # ======================================================

  def consume_resource(self, resource, quantity):
    """
    <Purpose>
      Consume resources of the provided quantity.

    <Arguments>
      resource - the type of resource (netsend/netrecv)

      quantity - the amount of resource that will be consumed.

    <Exceptions>
      ShimInternalError - if the quantity is below 0.

    <Return>
      None
    """

    if quantity < 0:
      raise ShimInternalError("Attempting to consume a negative quantity of resource.")

    if resource not in self.net_resources.keys():
      raise ShimInternalError("Resource '%s' not a valid resource." % resource)

    self.net_resources[resource]['lock'].acquire(True)

    try:
      consume_elapsed_time = float(quantity) / self.net_resources[resource]['resource_limit']
      consume_start_time = max(getruntime(), self.net_resources[resource]['drained_time'])
      self.net_resources[resource]['drained_time'] = consume_start_time + consume_elapsed_time

    finally:
      self.net_resources[resource]['lock'].release()




  def check_resource(self, resource):
    """
    <Purpose>
      Checks if the resource consumption is over the limit.

    <Arguments>
      resource - the type of resource (netsend/netrecv)

    <Exceptions>
      ShimInternalError - if the quantity is below 0.
      SocketWouldBlockError - there are no resources available to be consumed

    <Return>
      None
    """

    if resource not in self.net_resources.keys():
      raise ShimInternalError("Resource '%s' not a valid resource." % resource)

    self.net_resources[resource]['lock'].acquire(True)

    try:
      if getruntime() < self.net_resources[resource]['drained_time']:
        raise SocketWouldBlockError()

    finally:
      self.net_resources[resource]['lock'].release()




  def copy(self):
    """
    Make a copy of self.
    """

    shim_stack_copy = self.shim_context['shim_stack'].copy()
    optional_args_copy = self.shim_context['optional_args']

    my_copy = RateLimitShim(shim_stack_copy, optional_args_copy)
    return my_copy




  def get_advertisement_string(self):
    """
    The RateLimitShim is an one sided shim, which means it
    doesn't need to advertise itself.
    """
    return self.get_next_shim_layer().get_advertisement_string()

"""
<Program Name>
  hidesizeshim.repy

<Author>
  Fraida Fund (ffund01@students.poly.edu)

<Date Started>
  December 1, 2012

<Purpose>
  'Bloats' the data payload sent over a TCP socket with a random number of extra 
  bytes, to hide the true size of a message from potential eavesdroppers.

  Meant to be layered on top of some kind of encryption shim, otherwise it is 
  basically useless!
"""


dy_import_module_symbols("shim_exceptions")

# Use 'random' to select how many bytes to add, and to get random bytes
dy_import_module_symbols('random')

_hidesize_shim_global_lock = createlock()

def _hidesize_shim_atomic_operation(target_func):
  def wrapper(*args, **kwargs):
    try:
      _hidesize_shim_global_lock.acquire(True)
      return target_func(*args, **kwargs)
    finally:
      _hidesize_shim_global_lock.release()

  return wrapper



class HideSizeShim(BaseShim):

  def __init__(self, shim_stack, optional_args=None):
    """
    In the optional arguments, you can specify the maximum number of bytes to 
    append on each send call. For example, if the shim string is 
    '(HideSizeShim,1024)' then a random number of bytes up to 1024 
    will be appended to each chunk of data that is sent.

    If it is not specified, then the default of 1024 will be used. 

    """

    # A dictionary that maps a socket to its send buffer, which stores any
    # temporary data pending to be transmitted.
    self._send_buf_dict = {}

    # A dictionary that maps a socket to its receive buffer, which stores
    # the 'bloated' TCP stream.
    self._recv_buf_dict = {}

    # A dictionary that maps a socket to any exception it raises while we try to
    # receive as much as possible.
    self._recv_exception_dict = {}

    # A dictionary that maps a socket to the stream of unprocessed data.
    self._result_buf_dict = {}

    # A set that stores all the active sockets used in socket_send. If a socket
    # raises an exception other than SocketWouldBlockError, it is considered
    # inactive and thus removed from the set.
    self._active_recv_socket_set = set()

    # A dictionary that maps a socket to the locks used to synchronize the 
    # socket's sending thread and 'bloating' thread
    self._full_lock = {}
    self._empty_lock = {}
    self._mutex_lock = {}


    # If optional args is provided, use it to limit the number of bytes that
    # will be appended.
    if optional_args:
      max_size = int(optional_args[0])
      self._MAX_BYTES = max_size
    else:
      self._MAX_BYTES = 1024

    BaseShim.__init__(self, shim_stack, optional_args)



  def copy(self):
    return HideSizeShim(self.shim_context['shim_stack'].copy(), self.shim_context['optional_args'])


  
  def get_advertisement_string(self):

    optional_args = self.shim_context['optional_args']
    shim_name = '(HideSizeShim'

    if optional_args:
      shim_name += ',' + str(optional_args[0]) + ')'
    else:
      shim_name += ')'

    return shim_name + self.get_next_shim_layer().get_advertisement_string()




  def tcpserversocket_getconnection(self, tcpserversocket):
    """
    Sets up dictionaries, sets, locks, threads, and other necessary things

    """

    # Call the next layer of tcpserver_getconnection()
    (remote_ip, remote_port, repy_socket) = self.get_next_shim_layer().tcpserversocket_getconnection(tcpserversocket)

    if isinstance(repy_socket, ShimSocket):
      sockobj = repy_socket._socket
    else:
      sockobj = repy_socket

    # Initialize all the necessary dictionaries and sets.
    self._send_buf_dict[repr(sockobj)] = ''
    self._recv_buf_dict[repr(sockobj)] = ''
    self._recv_exception_dict[repr(sockobj)] = None
    self._result_buf_dict[repr(sockobj)] = ''
    self._active_recv_socket_set.add(repr(sockobj))

    # locks for synchronizing threads
    self._full_lock[repr(sockobj)] = createlock()
    self._empty_lock[repr(sockobj)] = createlock()
    self._mutex_lock[repr(sockobj)] = createlock()


    # The "full" lock is initialized to locked, so that the sending thread  
    # will sleep until there is data to send (the lock will be released by the 
    # bloating thread after it places data in the send buffer)
    self._full_lock[repr(sockobj)].acquire(True)

    # Create the sending thread for this connection
    def _send_wrapper():
      self._send_pending_data(sockobj)
    createthread(_send_wrapper)  

    return (remote_ip, remote_port, ShimSocket(repy_socket, self))



  def openconnection(self, destip, destport, localip, localport, timeout):
    """
    Sets up dictionaries, sets, locks, threads, and other necessary things

    """

    # Call the next layer of openconnection.
    next_sockobj = self.get_next_shim_layer().openconnection(destip, destport, localip, localport, timeout)

    if isinstance(next_sockobj, ShimSocket):
      sockobj = next_sockobj._socket
    else:
      sockobj = next_sockobj

    # Initialize all the necessary dictionaries and sets.
    self._send_buf_dict[repr(sockobj)] = ''
    self._recv_buf_dict[repr(sockobj)] = ''
    self._recv_exception_dict[repr(sockobj)] = None
    self._result_buf_dict[repr(sockobj)] = ''
    self._active_recv_socket_set.add(repr(sockobj))

    self._full_lock[repr(sockobj)] = createlock()
    self._empty_lock[repr(sockobj)] = createlock()
    self._mutex_lock[repr(sockobj)] = createlock()

    # The "full" lock is initialized to locked, so that the sending thread  
    # will sleep until there is data to send (the lock will be released by the 
    # bloating thread after it places data in the send buffer)
    self._full_lock[repr(sockobj)].acquire(True)

    # Create the sending thread for this connection
    def _send_wrapper():
      self._send_pending_data(sockobj)
    createthread(_send_wrapper)  

    return ShimSocket(next_sockobj, self)



  def _send_pending_data(self,socket):
    """
    Sending thread. When there is data in the send buffer (signaled by the "full"
    lock becoming available), it keeps trying to send until the buffer is empty, 
    at which point it signals to the bloating thread by releasing the "empty" lock.
    """

    while True:
      self._full_lock[repr(socket)].acquire(True)
      self._mutex_lock[repr(socket)].acquire(True)
      send_buf = self._send_buf_dict[repr(socket)]
      bytes_to_send = len(send_buf)
      
      # Send everything in the send buffer and remove it from the buffer.
      while send_buf:
        sent_bytes = 0
        try:
          sent_bytes = self.get_next_shim_layer().socket_send(socket, send_buf)
        except (SocketWouldBlockError, SocketClosedLocal, SocketClosedRemote), err:
          # ToDo: we shouldn't just pass
          pass
        send_buf = send_buf[sent_bytes : ]

      # When the send buffer is empty, release the locks and sleep until there
      # is more data to send
      self._mutex_lock[repr(socket)].release()
      self._empty_lock[repr(socket)].release()


  def socket_send(self, socket, msg):
    """ 
      Bloating thread. Picks a random int and gets that many random bytes to 
      append to the original data chunk. Prepends lengths of the data and extra 
      data as a header, and adds the chunk to the send buffer if it is empty.

      (If the send buffer is full, we raise SocketWouldBlockError)

    """
    # How much of the original data has been sent successfully.
    total_original_bytes_sent = 0

    # Keep sending the supplied message until no more data to send.
    while msg:

      # Create a bloated chunk of data out of the original message.
      header = ""

    
      msg_length = len(msg)
      # Don't send more "junk" data than the original message data
      extradata_length = min(random_int_below(self._MAX_BYTES),random_int_below(len(msg)))
      extradata = ''.join(random_sample(list(msg),extradata_length))

      # Append header information to indicate the length of the block
      header += str(msg_length) + ',' + str(extradata_length) + ','
      body = msg + extradata

      # Block is comprised of header and data + extra data
      block_data = header + body


      # If the send buffer is empty, place this block in the send buffer
      empty = self._empty_lock[repr(socket)].acquire(False)
      mutex = self._mutex_lock[repr(socket)].acquire(False)
      if mutex and empty:
        self._send_buf_dict[repr(socket)] = block_data
        self._mutex_lock[repr(socket)].release()
        self._full_lock[repr(socket)].release()
        total_original_bytes_sent += len(msg)
      else:
        # Release any lock we may have successfully acquired:
        if empty:
          self._empty_lock[repr(socket)].release()
        if mutex:
          self._mutex_lock[repr(socket)].release()
        break

    # If we have not sent any data, then the send buffer the system's send buffer must be full 
    # and we raise SocketWouldBlockError
    if total_original_bytes_sent == 0 and len(msg) > 0:
      raise SocketWouldBlockError

    return total_original_bytes_sent
        
      



  @_hidesize_shim_atomic_operation
  def socket_recv(self, socket, bytes):
    """ 
      Receive into the receive buffer until the socket blocks.

      Then, from the receive buffer, we reconstruct the "real" data from the 
      "bloated" data.

    """

    # Get the result buffer out of the dictionary.
    result_buf = self._result_buf_dict[repr(socket)]

    # If result buffer already has enough data in it, then we just return it.
    if len(result_buf) > bytes:
      requested_data = result_buf[0 : bytes]
      self._result_buf_dict[repr(socket)] = result_buf[len(requested_data) : ]
      return requested_data

    # Otherwise, we need to get fresh data off the wire and process it:

    # Receive as much as possible into the receive buffer
    while repr(socket) in self._active_recv_socket_set:
      try:
        self._recv_buf_dict[repr(socket)] += self.get_next_shim_layer().socket_recv(socket, 4096)

      # Stop trying to receive when there is no more data to read from the socket
      except SocketWouldBlockError:
        break

      # If a different exception occurs, save it first and raise it later
      # when we run out of data to return (i.e. empty result buffer). The socket
      # is now considered inactive. We remove it from the active socket set.
      except (SocketClosedLocal, SocketClosedRemote), err:
        self._recv_exception_dict[repr(socket)] = err
        self._active_recv_socket_set.remove(repr(socket))
        break



    # Reconstruct the 'real' message from the bloated TCP stream we have in the 
    # receive buffer, and add it to the result buffer.
    while True:
      bloated_block = self._reconstruct_blocks(socket)
      if bloated_block is None:
        break
      elif len(bloated_block) > 0:
        result_buf += bloated_block

    # If there is nothing in the result buffer, we have received all the data.
    if result_buf == '':

      # If we have saved exceptions, we raise them now, as these exceptions
      # occurred at the end of the received stream.
      if self._recv_exception_dict[repr(socket)]:
        raise self._recv_exception_dict[repr(socket)]

      # If we run out of data without any other exceptions.
      else:
        raise SocketWouldBlockError

    # Otherwise, return the number of bytes requested by the application 
    # and remove from result buffer
    requested_data = result_buf[0 : bytes]
    self._result_buf_dict[repr(socket)] = result_buf[len(requested_data) : ]

    return requested_data



  def _reconstruct_blocks(self, socket):
    """
    Helper method for the socket_recv method. Reconstructs and returns the
    "real" data starting from the head of the receive buffer. If
    there is nothing in the receive buffer to reconstruct, returns None. 

    """
    # Get the receive buffer. 
    recv_buf = self._recv_buf_dict[repr(socket)]

    # Return no blocks if the buffer is empty
    if recv_buf == '':
      return None

    # Use this string to keep track of the length of the message or the extra data
    length_str = ''

    msg_length = -1
    extradata_length = -1

    # Position in the receive buffer 
    cur_position = 0


    while True:

      # Read the header of the block, a char at a time, until two commas
      try:
        char = recv_buf[cur_position]

      # If we reach the end of the buffer without having received the full 
      # header, we will have to return None
      except IndexError:
        return None

      cur_position += 1

      # If we encounter a comma, it may signify that we have the msg length or 
      # the length of the extra data:
      if char == ',':
        if msg_length == -1:
          msg_length = int(length_str)
          length_str = ''
        elif extradata_length == -1:
          extradata_length = int(length_str)
          break

      elif char.isdigit():
        length_str += char

      # If we are still reading the header and we get something that is neither 
      # a comma nor a digit, we must have a bug
      else:
        err_str = 'HideSizeShim: Invalid character at position ' + str(cur_position) 
        err_str += ' in recv buffer: ' + str(recv_buf)
        raise ShimInternalError(err_str)
    
    # If we haven't received the entire "bloated" chunk, we return None
    if cur_position + msg_length + extradata_length > len(recv_buf):
      return None

    # Otherwise, get the bloated chunk out of the buffer and return the "real" 
    # data part of it
    block_body = recv_buf[cur_position : cur_position + msg_length]
    cur_position += msg_length
    cur_position += extradata_length
    self._recv_buf_dict[repr(socket)] = recv_buf[cur_position : ]
    return block_body[0 : msg_length ]




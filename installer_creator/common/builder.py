"""
<Program>
  builder.py

<Author>
  Jason Chen
  jchen@cs.washington.edu

<Started>
  September, 2009
  
<Purpose>
  Contains functions that are related to, or 
  directly involved with the building of the installers.
  
  This code is shared among the HTML and XMLRPC views of the installer_creator.
"""

import hashlib
import os
import sys
import subprocess
import shutil

from django.http import HttpResponse
from django.core.servers.basehttp import FileWrapper

from installer_creator import settings
from installer_creator.common import validations

from seattle import repyhelper
from seattle import repyportability

repyhelper.translate_and_import("rsa.repy")

def _state_key_file_to_publickey_string(key_file_name):
  """
  Read a public key file from the the state keys directory and return it in
  a key string format.
  """
  fullpath = os.path.join(settings.STATE_KEYS_DIR, key_file_name)
  return rsa_publickey_to_string(rsa_file_to_publickey(fullpath))

KEY_GENERATION_BITSIZE = 1024
SEATTLE_OWNER_PUBKEY = "22599311712094481841033180665237806588790054310631222126405381271924089573908627143292516781530652411806621379822579071415593657088637116149593337977245852950266439908269276789889378874571884748852746045643368058107460021117918657542413076791486130091963112612854591789518690856746757312472362332259277422867 12178066700672820207562107598028055819349361776558374610887354870455226150556699526375464863913750313427968362621410763996856543211502978012978982095721782038963923296750730921093699612004441897097001474531375768746287550135361393961995082362503104883364653410631228896653666456463100850609343988203007196015297634940347643303507210312220744678194150286966282701307645064974676316167089003178325518359863344277814551559197474590483044733574329925947570794508677779986459413166439000241765225023677767754555282196241915500996842713511830954353475439209109249856644278745081047029879999022462230957427158692886317487753201883260626152112524674984510719269715422340038620826684431748131325669940064404757120601727362881317222699393408097596981355810257955915922792648825991943804005848347665699744316223963851263851853483335699321871483966176480839293125413057603561724598227617736944260269994111610286827287926594015501020767105358832476708899657514473423153377514660641699383445065369199724043380072146246537039577390659243640710339329506620575034175016766639538091937167987100329247642670588246573895990251211721839517713790413170646177246216366029853604031421932123167115444834908424556992662935981166395451031277981021820123445253"
# The key used as the state key for new donations.
ACCEPTDONATIONS_STATE_PUBKEY = _state_key_file_to_publickey_string("acceptdonation.publickey")

# Path to the customize_installers.py. In this case, it's in the same directory
# as this views.py file.
PATH_TO_CUSTOMIZE_INSTALLER_SCRIPT = os.path.join(os.path.dirname(__file__), 
                                                  "customize_installers.py")


def build_installer(vessel_dict, key_dict, build_id):
  """
  <Purpose>
    Creates an installer with the given vessel_dict (vessel definitions)
    and the given key_dict (owner/user key dictionaries)
  
  <Arguments>
    vessel_dict:
      A list of vessel dictionaries, each dict representing a defintion
      of a vessel. Follows the format:
      [ {owner, percentage, [users]}, {owner, percentage, [users]} ... ]
    
    key_dict:
      A dictionary whose keys are usernames, and whose 
      values are key dicts (pubkey & privkey). Follows the format:
      { 'user1' : {'pubkey':pubkey, 'privkey':privkey}, 'user2' ... } 
    
    build_id:
      A build_id, specific to the vessel list/key dict combination;
      generated by generate_build_id().
    
    dist_str:
      Which OSes the installers should be built for. (any combination accepted)
      Valid options are: 'w' for windows, 'l' for linux, 'm' for mac
      
  <Returns>
    A list of urls pointing to where installers were created.
    
  <Notes>
    IMPORTANT: This method is NOT safe in terms of file-concurrency,
    and does not perform any kind of locking to protect against concurrent
    builds on the SAME VESSEL/KEY build. This means that builds on DIFFERENT
    VESSEL/KEY builds are SAFE.
    
    Make sure you perform proper locking before calling this method,
    IF there is chance that multiple clients could request a build
    on the same VESSEL/KEY combination (resulting in concurrent accesses
    to the same VESSEL/KEY installer dist folder)
  """
  
#  if dist_str == '' or not ((dist_str == 'w') or (dist_str == 'l') or (dist_str == 'm')):
#    raise ValueError("Invalid dist_str specificiation.")
  
  prefix = os.path.join(settings.USER_INSTALLERS_DIR, "%s_dist"%(build_id))
  temp_installinfo_dir = os.path.join(prefix, "install_info")
  
  # remove and recreate the prefix dir
  shutil.rmtree(prefix, True)

  # create install dir
  os.mkdir(prefix)
 
  # create the install_info dir, a temporary directory where the vesselinfo
  # will reside right before it gets added into the install package by installer_creator
  os.mkdir(temp_installinfo_dir)

  # strip out the privkeys from the key_dict, we won't need them for building the vesselinfo file
  for user in key_dict:
    key_dict[user] = {'pubkey':key_dict[user]['pubkey']}
  
  
  # prepare & write out the vesselinfo file
  vessel_info_str = _generate_vessel_info(vessel_dict, key_dict)

  
  f = open((temp_installinfo_dir + "/vesselinfo"), 'w')
  f.write(vessel_info_str)
  f.close()
  
  print vessel_info_str
  
  print("file preparation done. calling customize installer.")
   
  #installer_urls_dict = _run_customize_installer(username, dist_str)
  #return installer_urls_dict
  
#  try:
#    subprocess.check_call([sys.executable, PATH_TO_CUSTOMIZE_INSTALLER_SCRIPT, dist_str, 
#                           settings.BASE_INSTALLERS_DIR, temp_installinfo_dir, prefix])
#  except subprocess.CalledProcessError:
#    raise 
#  

#  installer_urls_dict = {}
#  if 'w' in dist_str:
#    installer_urls_dict['w'] = settings.USER_INSTALLERS_URL + "%s_dist/seattle_win.zip"%(build_id)
#  if 'l' in dist_str:
#    installer_urls_dict['l'] = settings.USER_INSTALLERS_URL + "%s_dist/seattle_linux.tgz"%(build_id)
#  if 'm' in dist_str:
#    installer_urls_dict['m'] = settings.USER_INSTALLERS_URL + "%s_dist/seattle_mac.tgz"%(build_id)
#  
#  return installer_urls_dict
  


def check_and_build_if_new_installers(installer_id):
  """
  <Purpose>
    Checks if the current user installers exist. If they don't, this function
    will try and rebuild them if it can find the vesselinfo file for the specified
    install. 
    
    Also, checks if the current base installers are newer than the already 
    built installers. If so, rebuild the installers with the newer, more current base 
    installers.
  
  <Returns>
    -1 if base installers are missing or unreadable.
     0 if installers are up to date, and do not require rebuilding.
     1 if installers were rebuilt using newest base installers.
  """
  user_installer_missing = False
  need_rebuild = False
  win_base_mtime = 0
  linux_base_mtime = 0
  mac_base_mtime = 0
  
  try:
    win_stat_buf = os.stat(os.path.join(settings.BASE_INSTALLERS_DIR, "seattle_win.zip"))
    linux_stat_buf = os.stat(os.path.join(settings.BASE_INSTALLERS_DIR, "seattle_linux.tgz"))
    mac_stat_buf = os.stat(os.path.join(settings.BASE_INSTALLERS_DIR, "seattle_mac.tgz"))
  except Exception:
    return -1
  else:
    win_base_mtime = win_stat_buf.st_mtime
    linux_base_mtime = linux_stat_buf.st_mtime
    mac_base_mtime = mac_stat_buf.st_mtime
  
  dist_folder = os.path.join(settings.USER_INSTALLERS_DIR, installer_id + "_dist")
  
  try:
    win_user_stat_buf = os.stat(os.path.join(dist_folder, "seattle_win.zip"))
    linux_user_stat_buf = os.stat(os.path.join(dist_folder, "seattle_linux.tgz"))
    mac_user_stat_buf = os.stat(os.path.join(dist_folder, "seattle_mac.tgz"))
  except Exception:
    user_installer_missing = True
  else:
    win_user_mtime = win_user_stat_buf.st_mtime
    linux_user_mtime = linux_user_stat_buf.st_mtime
    mac_user_mtime = mac_user_stat_buf.st_mtime
    
  # rebuild installers if base installers newer or user installers missing
  if user_installer_missing:
    # rebuild
    need_rebuild = True
  else:  
    if (win_base_mtime > win_user_mtime) or (linux_base_mtime > linux_user_mtime) or (mac_base_mtime > mac_user_mtime):
      need_rebuild = True
  
  if not need_rebuild:
    print "no rebuild needed!"
    return 0
  
  # try to remove existing installers (even though they might not exist, for whatever reason)
  try:
    os.remove(os.path.join(dist_folder, "seattle_win.zip"))
  except Exception:
    print "no win user installer to remove"
    pass
  else:
    print "removed win user installer"
  
  try:
    os.remove(os.path.join(dist_folder, "seattle_linux.tgz"))
  except Exception:
    print "no linux user installer to remove"
    pass
  else:
    print "removed linux user installer"
  
  try:
    os.remove(os.path.join(dist_folder, "seattle_mac.tgz"))
  except Exception:
    print "no mac user installer to remove"
    pass
  else:
    print "removed mac user installer"
  
  print "about to call customize"
  _run_customize_installer(installer_id)
  return 1


  
def generate_keypair():
  (pubkeydict, privkeydict) = rsa_gen_pubpriv_keys(KEY_GENERATION_BITSIZE)

  pubkeystring = rsa_publickey_to_string(pubkeydict)
  privkeystring = rsa_privatekey_to_string(privkeydict)
  
  return {'pubkey' : pubkeystring, 'privkey' : privkeystring}



def generate_build_id(vessel_dict, key_dict):
  vessel_str = ''
  
  for vessel in vessel_dict:
    vessel_str += str(vessel['owner']) + ":" + str(vessel['percentage']) + ":"
    
    for user in vessel['users']:
      vessel_str += str(user) + ","
    
    vessel_str += "|"
  
  build_id = hashlib.sha1(vessel_str).hexdigest()
  return build_id



def dl_installer(request, installer_id, installer_name):
  """
  <Purpose>
    This method is invoked when a client requests an installer via the installer url.
    We perform cache-checking at this point, and if needed, make a call to rebuild
    the installers. Finally, the installers will be read off disk, and served as an
    attachment via the HTTP response.
  
  <Arguments>
    The arguments are inferred from the URL itself.
  """
  
  # check inputs
  # TODO: catch validation exceptions
  validations.assert_str(installer_id)
  validations.assert_str(installer_name)
  
  if (installer_name != "seattle_win.zip" and installer_name != "seattle_linux.tgz" and installer_name != "seattle_mac.tgz"):
    return HttpResponse("Sorry, the installer you requested does not exist.", status=404) 
  
  # installer_id is derived from url, has _dist. remove it, as the rest of the code doesn't expect it
  installer_id = installer_id[0:len(installer_id)-5]
  
  # Entering a critical section (multiple clients could potentially access
  # the same installer_id installer instance). Begin locking.
  
  # first check if this installer build exists by trying to read the vesselinfo
  v_handle = None
  dist_folder = os.path.join(settings.USER_INSTALLERS_DIR, installer_id + "_dist")
  #dist_folder = os.path.join(settings.USER_INSTALLERS_DIR, installer_id)
  
  print "searching for vesselinfo at: " + os.path.join(dist_folder, "install_info", "vesselinfo")
  try:
    v_handle = open(os.path.join(dist_folder, "install_info", "vesselinfo"), 'rb');
  except IOError:
    # No dist folder for this user: this installer instance doesn't even exist, return error
    v_handle.close()
    return HttpResponse("Sorry, the installer you requested does not exist.", status=404)
  
  else:
    # Found the vesselinfo, check if installer is out-of-date 
    print "Found dist folder, checking if installer is out-of-date"
    v_handle.close()
    
    check_ret = check_and_build_if_new_installers(installer_id)
    print "check_and_build returned: " + str(check_ret)
    if (check_ret == 0):      
      # no rebuild needed
      print "[dl_installer]: serving up cached installers." 
    elif (check_ret == 1):
      # installers rebuilt
      print "[dl_installer]: serving up rebuilt, up-to-date installers." 
    else:
      # something went wrong during the check, eg: base installers not found
      print "[dl_installer]: check_and_build returned fatal -1"
      return HttpResponse("Fatal error: check_and_build returned -1", status=500)
  
  print "[dl_installer]: serving up fresh installers."
  
  # read installer off disk and serve
  if (installer_name == "seattle_win.zip"):
    print "[dl_installer]: serving up win installer"
    return _send_file(os.path.join(dist_folder, "seattle_win.zip"))
  elif (installer_name == "seattle_linux.tgz"):
    print "[dl_installer]: serving up linux installer"
    return _send_file(os.path.join(dist_folder, "seattle_linux.tgz"))
  elif (installer_name == "seattle_mac.tgz"):
    print "[dl_installer]: serving up mac installer"
    return _send_file(os.path.join(dist_folder, "seattle_mac.tgz"))
  else:
    # we should never get here, since validations should have caught invalid
    # installer_names. be safe, and just return a generic error message
    return HttpResponse("Sorry, the installer you requested does not exist.", status=404)



def _generate_vessel_info(vessel_dict, key_dict):
  lines = []
  for vessel in vessel_dict:
    percentage = str(vessel['percentage'] * 10)
    owner_keypair = key_dict[vessel['owner']] 
    owner_pubkey = owner_keypair['pubkey']
    
    lines.append("Percent " + percentage)
    lines.append("Owner " + owner_pubkey)
    for user in vessel['users']:
      user_keypair = key_dict[user]
      user_pubkey = user_keypair['pubkey']
      lines.append("User " + user_pubkey)
  
  # write in our reserved 20%
  lines.append("Percent 20")
  lines.append("Owner " + SEATTLE_OWNER_PUBKEY)
  
  vessel_info_str = '\n'.join(lines)
  return vessel_info_str



def _run_customize_installer(installer_id, dist_str='wml'):
  prefix = os.path.join(settings.USER_INSTALLERS_DIR, "%s_dist"%(installer_id))
  temp_installinfo_dir = os.path.join(prefix, "install_info")
  
  try:
    subprocess.check_call([sys.executable, PATH_TO_CUSTOMIZE_INSTALLER_SCRIPT, dist_str, 
                           settings.BASE_INSTALLERS_DIR, temp_installinfo_dir, prefix])
  except subprocess.CalledProcessError:
    raise 
  
  installer_urls_dict = {}
  if 'w' in dist_str:
    installer_urls_dict['w'] = settings.USER_INSTALLERS_URL + "%s_dist/seattle_win.zip"%(installer_id)
  if 'l' in dist_str:
    installer_urls_dict['l'] = settings.USER_INSTALLERS_URL + "%s_dist/seattle_linux.tgz"%(installer_id)
  if 'm' in dist_str:
    installer_urls_dict['m'] = settings.USER_INSTALLERS_URL + "%s_dist/seattle_mac.tgz"%(installer_id)
  
  return installer_urls_dict



def _send_file(file_name):
    """  
    <Purpose>                                                                       
      Send a file through Django without loading the whole file into              
      memory at once. The FileWrapper will turn the file object into an           
      iterator for chunks of 8KB.                                    
    """
    filename = file_name                         
    wrapper = FileWrapper(file(filename))
    response = HttpResponse(wrapper, content_type='text/plain')
    response['Content-Length'] = os.path.getsize(filename)
    return response

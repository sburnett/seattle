""" 
Author: Justin Cappos

Start Date: August 4, 2008

Description:
A software updater for the node manager.   The focus is to make it secure, 
robust, and simple (in that order).

Usage:  ./softwareupdater.py

"""



import sys

import urllib      # to retrieve updates
import os   # needed for remove and path.exists
import subprocess   # used to start an experiment
import time  # used to sleep after a stop so that we don't lie about stopping
import random
import shutil
import socket   # we'll make it so we don't hang...
import tempfile
import runonce
import nonportable  # Used for sys.exit

include signeddata.repy
include sha.repy

# MIX: fix the fact that I don't have or need the getruntime() call...
def time_gettime():
  return time_seconds_from_1900_to_1970 + time.time()


# where I log my errors to
logfileobj = None


softwareurl = "http://seattle.cs.washington.edu/couvb/real/"

# embedded this because it seems easier to update it along with this file
# Every computer running Seattle will have this same public key, and will trust
# files signed by this key.
softwareupdatepublickey = {'e':13221289395445914976130679314453626168966276217387787137080871341273852287573185994316352310444900014240262985628610006672282068241549946863146960020013171, 'n':1589456940628178955622789749467545098429716176817312937418225345848632319292218339145226317399290629352674850322043552215595238300420898593467248333987806485667943573607695797169463632993260829462338883909633640668087994191157092930310301121714211922849471156670352177769152675051338521583192110381238628036973343453550038815066340543971127144267796668792727916870140829333544141931409253248778119440181349458837376093509047447913691446118992104354729154198141235419080987635709890725086481369056205089476633891607372392333981127723122192237324181348217014560722397261768689966319923830564263221938291067470882342071}



def log(data):
  print >> sys.stderr, time.time(),data
  sys.stderr.flush()


def get_file_hash(filename):
  fileobj = file(filename, 'rb')
  filedata = fileobj.read()
  fileobj.close()

  return sha_hexhash(filedata)



# We'll use this to get a file.   If it doesn't download in a reasonable time, 
# we'll fail. (BUG: doesn't do this yet.   I use timeouts, but they don't
# always work)
def safe_download(serverpath, filename, destdir, filesize):
  try:
    urllib.urlretrieve(serverpath+filename,destdir+filename)
    return True
  except Exception,e:
    log(e)
    return False
 
#  # how much we have left to download
#  remainingsize = filesize
#
#  # get a file-like object for the URL...
#  safefo = urllib.urlopen(filename)
#
#  # always close after this...
#  try:
#    # download up to "filesize" worth of data...   
#    # BUG: We also should check to see if this is too slow...
#    mydata
#  
#  
#  finally:
#    try:
#      safefo.close()
#    except:
#      pass




################### Begin Rsync ################### 
# I'd love to be able to put this in a separate module or repyify it, but 
# I'd need urllib...

class RsyncError(Exception):
  pass




def do_rsync(serverpath, destdir, tempdir):
  # Returns a list of updated files.


  # get the metainfo (like a directory listing)
  safe_download(serverpath, "metainfo", tempdir, 1024*32)

  # read the file data into a string
  newmetafileobject = file(tempdir+"metainfo")
  newmetafiledata = newmetafileobject.read()
  newmetafileobject.close()

  # Incorrectly signed, we don't update...
  if not signeddata_issignedcorrectly(newmetafiledata, softwareupdatepublickey):
    return []

  try:
    # read in the old file
    oldmetafileobject = file(destdir+"metainfo")
    oldmetafiledata = oldmetafileobject.read()
    oldmetafileobject.close()
  except:
    # The old file has problems.   We'll use the new one since it's signed
    pass

  else:
    # they're both good.   Let's compare them...
    shoulduse, reasons = signeddata_shouldtrust(oldmetafiledata,newmetafiledata,softwareupdatepublickey)

    if shoulduse == True:
      # great!   All is well...
      pass
    elif shoulduse == None:
      # hmm, a warning...   
      if len(reasons) == 1 and reasons[0] == 'Cannot check expiration':
        # we should probably allow this.  The node may be offline 
        log("Warning:"+str(reasons))
        #print "Warning:"+str(reasons)
        pass
      elif 'Timestamps match' in reasons:
        # Already seen this one...
        log(reasons)
        #print str(reasons)
        return []

    elif shoulduse == False:
      # Let's assume this is a bad thing and exit
      log(reasons)
      #print str(reasons)
      return []
    

  # now it's time to update
  updatedfiles = [ "metainfo" ]

  for line in file(tempdir+"metainfo"):

    # skip comments
    if line[0] == '#':
      continue
 
    # skip signature parts
    if line[0] == '!':
      continue
 
    # skip blank lines
    if line.strip() == '':
      continue

    linelist = line.split()
    if len(linelist)!= 3:
      raise RsyncError, "Malformed metainfo line: '"+line+"'"

    filename, filehash, filesize = linelist
    
    # if the file is missing or the hash is different, we want to download...
    if not os.path.exists(destdir+filename) or get_file_hash(destdir+filename) != filehash:
      # get the file
      safe_download(serverpath, filename, tempdir, filesize)

      # oh crap!   The hash doesn't match what we thought
      if get_file_hash(tempdir+filename) != filehash:
        log("Hash mismatch on file '"+filename+"'")
        #print 'Hash download: '+str(filehash)
        #print 'Hash computed: '+str(get_file_hash(tempdir+filename))
        raise RsyncError, "Hash of file '"+filename+"' does not match information in metainfo file"

      # put this file in the list of files we need to update
      updatedfiles.append(filename)      


  # copy the files to the local dir...
  for filename in updatedfiles:
    #print "copying "+tempdir+filename+" to "+destdir+filename
    shutil.copy(tempdir+filename, destdir+filename)
    
  # done!   We updated the files
  return updatedfiles
  
################### End Rsync ################### 





# MUTEX  (how I prevent multiple copies)
# a new copy writes an "OK" file. if it's written the previous can exit.   
# a previous copy writes a "stop" file. if it's written the new copy must exit
# each new program has its own stop and OK files (listed by mutex number)
# 
# first program (fresh_software_updater)
#              get softwareupdater.new mutex
#              clean all mutex files
#              once in main, take softwareupdater.old, release softwareupdater.new
#              exit if we ever lose softwareupdater.old
#
# old program (restart_software_updater)
#              find an unused mutex 
#              starts new with arg that is the mutex
#              wait for some time
#              if "OK" file exists, release softwareupdater.old, remove it and exit
#              else write "stop" file
#              continue normal operation
#
# new program: (software_updater_start)
#              take softwareupdater.new mutex
#              initializes
#              if "stop" file exists, then exit
#              write "OK" file
#              while "OK" file exists
#                 if "stop" file exists, then exit
#              take softwareupdater.old, release softwareupdater.new
#              start normal operation
#


def init():
#  print 'Starting at the very beginning...'
  gotlock = runonce.getprocesslock("softwareupdater.new")
  if gotlock == True:
    # I got the lock.   All is well...
    pass
  else:
    # didn't get the lock, and we like to be real quiet, so lets 
    # exit quietly
    sys.exit(55)

#  print 'Right before closure...'

  # set up logging, etc.
  sys.stdin.close()
  # close C's stdout stream
  sys.stdout.close()
#  os.close(1)
#  sys.stdout = open('softwareupdater.stdout', 'w')
  sys.stderr.close()

  if not os.path.exists("softwareupdater.logfile") or os.path.getsize("softwareupdater.logfile") > 1024*1024:
    # kill the log file if it's > 1MB, create if it doesn't exist
    sys.stderr = open("softwareupdater.logfile","w")
    #pass
  else:
    # or append otherwise
    sys.stderr = open("softwareupdater.logfile","a")
    #pass

 # sys.stdout = sys.stderr

#  sys.stderr.write('Starting init')

#  print 'done with stderr stuffs'

  # don't hang if the socket is slow (in some ways, this doesn't always work)
  # BUG: http://mail.python.org/pipermail/python-list/2008-January/471845.html
  socket.setdefaulttimeout(10)
  
  # remove any old / broken test dirs...
  if os.path.exists("download.test"):
    shutil.rmtree("download.test")
  
  # create the test dir...
  os.mkdir("download.test")
  # copy my metainfo file into there
  shutil.copy("metainfo","download.test")

  # do an update to that directory.   If I don't see an unexpected error, we 
  # should be in good shape
  tempdir = tempfile.mkdtemp()+"/"
#  sys.stderr.write('Gonna do rsync test')
  try:
    do_rsync(softwareurl, "download.test/",tempdir)
  except:
     # We continue if this happens later, 
     # so we should do so now as well
     pass
  finally:
    shutil.rmtree(tempdir)
      
  # remove the test directory
  shutil.rmtree("download.test")

#  sys.stderr.write('Gonna get started now!')

  # time to handle startup (with respect to other copies of the updater
  if len(sys.argv) == 1:
    # I was called with no arguments, must be a fresh start...
    fresh_software_updater()
  else:
    # the first argument is our mutex number...
    software_updater_start(sys.argv[1])


def software_updater_start(mutexname):
  # if "stop" file exists, then exit
  if os.path.exists("softwareupdater.stop."+mutexname):
    sys.exit(2)

  # write "OK" file
  file("softwareupdater.OK."+mutexname,"w").close()
  
  # while "OK" file exists
  while os.path.exists("softwareupdater.OK."+mutexname):
    # if "stop" file exists, then exit
    if os.path.exists("softwareupdater.stop."+mutexname):
      sys.exit(3)

  # Get the process lock for the main part of the program.
  gotlock = runonce.getprocesslock("softwareupdater.old")
  # Release the lock on the initialization part of the program
  runonce.releaseprocesslock('softwareupdater.new')
  if gotlock == True:
    # I got the lock.   All is well...
    pass
  else:
    if gotlock:
      sys.stderr.write("Another software updater old process (pid: "+str(gotlock)+") is running")
      sys.exit(55)
    else:
      sys.stderr.write("Another software updater old process is running")
      sys.exit(55)
  
  # start normal operation
  return


# this is called by either the installer or the program that handles starting
# up on boot
def fresh_software_updater():
  # clean all mutex files
  for filename in os.listdir('.'):
    # Remove any outdated stop or OK files...
    if filename.startswith('softwareupdater.OK.') or filename.startswith('softwareupdater.stop.'):
      os.remove(filename)

  # Get the process lock for the main part of the program.
  gotlock = runonce.getprocesslock("softwareupdater.old")
  # Release the lock on the initialization part of the program
  runonce.releaseprocesslock('softwareupdater.new')
  if gotlock == True:
    # I got the lock.   All is well...
    pass
  else:
    if gotlock:
      sys.stderr.write("Another software updater old process (pid: "+str(gotlock)+") is running")
      sys.exit(55)
    else:
      sys.stderr.write("Another software updater old process is running")
      sys.exit(55)
  # Should be ready to go...



def get_mutex():
  # do this until we find an unused file mutex.   we should find one 
  # immediately with overwhelming probability
  while True:
    randtoken = str(random.random())
    if not os.path.exists("softwareupdater.OK."+randtoken) and not os.path.exists("softwareupdater.stop."+randtoken):
      return randtoken
  

def restart_software_updater():
  """This will exit if the new program seems to start correctly and return otherwise.   It should prevent multiple copies from running"""
#  std.stderr.write('Gonna restart!')
  # find an unused mutex 
  thismutex = get_mutex()

  # starts new with arg that is the mutex 
  junkupdaterobject = subprocess.Popen(["python","softwareupdater.py",thismutex])

  # wait for some time (1 minute) for them to init and stop them if they don't
  for junkcount in range(30):
    do_sleep(2.0)

    # if "OK" file exists, release softwareupdater.old, remove OK file and exit
    if os.path.exists("softwareupdater.OK."+thismutex):
      runonce.releaseprocesslock('softwareupdater.old')
      os.remove("softwareupdater.OK."+thismutex)
      # I'm happy, it is taking over
      sys.exit(10)

  # else write "stop" file because it failed...
  file("softwareupdater.stop."+thismutex,"w").close()

  # I continue normal operation
  return



def restart_client(filenamelist):
  # create a stop file
  clientfo = file("client.stop","w")
  for filename in filenamelist:
    print >> clientfo, filename
  clientfo.close()

  # run the node manager.   I rely on it to do the smart thing (handle multiple
  # instances, etc.)
  junkprocessobject = subprocess.Popen(["python","nmmain.py"])
  
  # I don't do anything with the processobject.  The process will run for some 
  # time, perhaps outliving me (if I'm updated first)

# sleep for a specified time.  Don't return early (no matter what)
def do_sleep(waittime):

  # there might be a race here
  endtime = time.time() + waittime
  sleeptime = endtime - time.time()
  while sleeptime>0:
    time.sleep(sleeptime)
    sleeptime = endtime - time.time()

      


def main():


  # This is similar to init only:
  #   1) we loop / sleep
  #   2) we restart ourselves if we are updated
  #   3) we restart our client if they are updated


  # If this is true, I need to be restarted...   Once True it will never be 
  # False again
  restartme = False

  while True:
#    sys.stderr.write('Before main sleep')
    # sleep for 5-55 minutes 
    do_sleep(1800+random.randint(-1500,1500))

#    sys.stderr('After main sleep')

    # Make sure we still have the process lock.
    # If not, we should exit
    if not runonce.stillhaveprocesslock('softwareupdater.old'):
      sys.stderr.write('We no longer have the processlock\n')
      sys.exit(55)

    # where I'll put files...
    tempdir = tempfile.mkdtemp()+"/"

#    sys.stderr.write('gonna update!')

    # I'll clean this up in a minute
    try:
      updatedlist = do_rsync(softwareurl, "./",tempdir)
    except RsyncError:
      # oops, hopefully this will be fixed next time...
      continue

    finally:
      shutil.rmtree(tempdir)

    # no updates   :)   Let's wait again...
    if updatedlist == []:
      continue

#    sys.stderr.write('Updated something!')
   
    # if there were updates, the metainfo file should be one of them...
    assert('metainfo' in updatedlist)

    clientlist = updatedlist[:]

    if 'softwareupdater.py' in clientlist:
      restartme = True
      clientlist.remove('softwareupdater.py')

    # if the client software changed, let's update it!
    if clientlist != []:
      restart_client(clientlist)

    # oh! I've changed too.   I should restart...   search for MUTEX for info
    if restartme:
      restart_software_updater()
    

if __name__ == '__main__':
  # problems here are fatal.   If they occur, the old updater won't stop...
  init()

  # in case there is an unexpected exception, continue (we'll sleep first thing
  # in main)
  while True:
    try:
      main()
    except SystemExit:
      # If there is a SystemExit exception, we should probably actually exit...
      raise
    except:
      # Otherwise we will keep on trucking
      pass

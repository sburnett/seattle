"""
<Program Name>
  repyhelper.py

<Started>
  November 2008

<Author>
  Andreas Sekine

<Purpose>
  Make porting Repy code to regular python easier. The main interface
  is through repyhelper.translate
"""

usestring = """repyhelper.py infile outfile

Processes infile to generate the valid python module outfile. 

outfile and infile must be distinct.
"""

import os

TRANSLATION_TAGLINE = "### Automatically generated by repyhelper.py ###"


class TranslationError(Exception):
  """ An error occurred during translation """
  


#Ensure each translated module uses a common "mycontext" dictionary
shared_context = {}
def get_shared_context():
  """ Ensure all imported repy code has a common 'mycontext' dict """
  return shared_context
  
  
#Ensure the generated module has a safe name
  # Can't use . in the name because import uses it for scope, so convert to _
def _get_module_name(repyfilename):
  return repyfilename.replace(".", "_")



def _translation_is_needed(repyfilename, generatedfilename):
  """ Checks if generatedfile needs to be regenerated. Does several checks to 
  decide if generating generatedfilename based on repyfilename is a good idea.
    --does file already exist?
    --was it automatically generated?
    --was the original modified since the last translation?
    
  """
  if not os.path.isfile(repyfilename):
    raise TranslationError("no such file:", repyfilename)
  if not os.path.isfile(generatedfilename):
    return True
  
  try:
    fh = open(generatedfilename, "r")
    first_line = fh.readline().rstrip("\n")
    fh.close()
    
    if first_line != TRANSLATION_TAGLINE:
      #This file was probably not generated by repyhelper, or was modified by
      #the user. Let's not clobber the file, just to be safe. 
      raise TranslationError("File name already exists: " + generatedfilename)
    
  except IOError:
    #Error opening the file. Assume this means we need to regen
    raise TranslationError("Error opening file: " + generatedfilename)
  
  #If we get here and modification time of orig is older than gen, this is still
  #a valid generation  
  repystat = os.stat(repyfilename)
  genstat = os.stat(generatedfilename)
  if repystat.st_mtime < genstat.st_mtime:
    return False
    
  return True


def _generate_python_file_from_repy(repyfilename, generatedfilename):
  """ Generate a python module from a repy file so it can be imported
  The first line is TRANSLATION_TAGLINE, so it's easy enough to detect that
  the file was automatically generated
  
  """
  
  #TODO: add the path and/or original file to tagline, 
  #      in case multiple files in different directories
  #      have the same generated name
  try:
    fh = open(generatedfilename, "w")
    print >> fh, TRANSLATION_TAGLINE
    print >> fh, "import repyhelper"
    print >> fh, "from repyportability import *"
    print >> fh, "mycontext = repyhelper.get_shared_context()"
    print >> fh, "callfunc = \"import\""
    print >> fh 
    _process_output_file(fh, repyfilename)
    fh.close()
    return True
  except IOError:
    raise TranslationError("Error translating file " + repyfilename)

def _process_output_file(outfh, filename):
  """ Recursive function that deals with repy code that contains includes
  
  Translates includes into repyhelper.translate calls
  """
  
  try:
    repyfh = open(filename, "r")
    repyfiledata = repyfh.readlines()
    repyfh.close()
  except IOError, e:
    print "Error opening included file", filename
    # This will make the generated file invalid python
    # Should we delete the partially translated file?
    print outfh << "ERROR PROCESSING INCLUDE:", filename
    outfh.close()
    raise TranslationError("Opening file " + filename + ":" + e.message)
  
  for line in repyfiledata:
    if line.lstrip().startswith('include '):
      includename = line.strip()[len('include '):]
      modulename = _get_module_name(includename)
      print >> outfh, "repyhelper.translate('" + includename + "')"
      print >> outfh, "from", modulename, "import *"
      
    else:
      print >> outfh, line,
  
  
def translate(repyfilename):
  """
  <Purpose>
    Translate a Repy file into a valid python module that can be invoked by
    the standard "import" statement. 
    
    Creates a python file correspond to the repy file, with the name format
    <original name>_repy.py. Performs several checks to only perform a 
    translation when necessary, to prevent accidentally clobbering other files
    
    The repyhelper and repyportability modules must be in the module path for the
    translated files
  
  <Arguments>
    repyfilename:
      A valid repy file name that exists and ends with a .repy extension. 
  
  <Exceptions>
    ValueError if filename doesn't exist or doesn't have a .repy extension
    TranslationError if there was an error during file generation
  
  <Side Effects>
    Creates a python file correspond to the repy file, overwriting previously 
    generated files that exists with that name
  
  <Returns>
    The name of the Python module that was created in the current directory. This
    string can be used with __import__ to import the translated module.
  """

  if not os.path.isfile(repyfilename):
    raise ValueError("File " + repyfilename + " does not exist")
  
  modulename = _get_module_name(repyfilename)
  generatedfilename = modulename + ".py"
  
  if _translation_is_needed(repyfilename, generatedfilename): 
    _generate_python_file_from_repy(repyfilename, generatedfilename)

  return modulename




def main():
  if len(sys.argv)!= 3:
    print "Invalid number of arguments"
    print usestring
    sys.exit(1)
  
  infile = sys.argv[1]
  outfile = sys.argv[2]
  # don't support translating file into itself
  if infile == outfile:
    print "The infile and outfile must be different files"
    sys.exit(1)

  if not _translation_is_needed(infile, outfile):
    print "Not generating file", outfile
    sys.exit(1)
  
  _generate_python_file_from_repy(infile, outfile)
  


if __name__ == '__main__':
  main()

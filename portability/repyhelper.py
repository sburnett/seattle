"""
<Program Name>
  repyhelper.py

<Started>
  November 2008

<Author>
  Andreas Sekine

<Purpose>
  Make porting Repy code to regular python easier. The main interface
  is through repyhelper.translate and repyhelper.translate_and_import
"""

usestring = """repyhelper.py infile outfile

Processes infile to generate the valid python module outfile. 

outfile and infile must be distinct.
"""

import os #needed for file checks
import inspect #needed to fiddle with callstack/module namespaces

TRANSLATION_TAGLINE = "### Automatically generated by repyhelper.py ###"



class TranslationError(Exception):
  """ An error occurred during translation """

  


shared_context = {}
def get_shared_context():
  """ Ensure all imported repy code has a common 'mycontext' dict """
  return shared_context
  
  
#Ensure the generated module has a safe name
# Can't use . in the name because import uses it for scope, so convert to _
def _get_module_name(repyfilename):
  return repyfilename.replace(".", "_")



def _translation_is_needed(repyfilename, generatedfilename):
  """ Checks if generatedfile needs to be regenerated. Does several checks to 
  decide if generating generatedfilename based on repyfilename is a good idea.
    --does file already exist?
    --was it automatically generated?
    --was the original modified since the last translation?
    
  """
  if not os.path.isfile(repyfilename):
    raise TranslationError("no such file:", repyfilename)
  if not os.path.isfile(generatedfilename):
    return True
  
  #Read the first line
  try:
    fh = open(generatedfilename, "r")
    #TODO does this handle windows newlines?
    first_line = fh.readline().rstrip("\n")
    fh.close()
  except IOError:
    #Error opening the file
    raise TranslationError("Error opening file: " + generatedfilename)
  
  #Check to see if the file was generated by repyhelper, to prevent
  #clobbering a file that we didn't create
  if not first_line.startswith(TRANSLATION_TAGLINE):
    raise TranslationError("File name already exists: " + generatedfilename)
  
  old_translation_path = first_line[len(TRANSLATION_TAGLINE):].strip()
  generated_abs_path = os.path.abspath(repyfilename)
  if old_translation_path != generated_abs_path:
    raise TranslationError("Path conflict between translated file: Trying to use " + 
                           generated_abs_path + ", but old translation had path " + old_translation_path)
  
  
  
  #If we get here and modification time of orig is older than gen, this is still
  #a valid generation
  repystat = os.stat(repyfilename)
  genstat = os.stat(generatedfilename)
  if repystat.st_mtime < genstat.st_mtime:
    return False
    
  return True


def _generate_python_file_from_repy(repyfilename, generatedfilename):
  """ Generate a python module from a repy file so it can be imported
  The first line is TRANSLATION_TAGLINE, so it's easy enough to detect that
  the file was automatically generated
  
  """
  
  #TODO: add the path and/or original file to tagline, 
  #      in case multiple files in different directories
  #      have the same generated name
  try:
    fh = open(generatedfilename, "w")
    print >> fh, TRANSLATION_TAGLINE, os.path.abspath(repyfilename)
    print >> fh, "import repyhelper"
    print >> fh, "from repyportability import *"
    print >> fh, "mycontext = repyhelper.get_shared_context()"
    print >> fh, "callfunc = \"import\""
    print >> fh 
    _process_output_file(fh, repyfilename)
    fh.close()
    return True
  except IOError:
    raise TranslationError("Error translating file " + repyfilename)


def _process_output_file(outfh, filename):
  """ Recursive function that deals with repy code that contains includes
  
  Translates includes into repyhelper.translate calls
  """
  
  try:
    repyfh = open(filename, "r")
    repyfiledata = repyfh.readlines()
    repyfh.close()
  except IOError, e:
    print "Error opening included file", filename
    # This will make the generated file invalid python
    # Should we delete the partially translated file?
    print outfh << "ERROR PROCESSING INCLUDE:", filename
    outfh.close()
    raise TranslationError("Opening file " + filename + ": " + e.message)
  
  #So we read all the data, lets process it
  for line in repyfiledata:
    #look for includes, and substitute them with calls to translate
    if line.lstrip().startswith('include '):
      includename = line.strip()[len('include '):]
      modulename = _get_module_name(includename)
      print >> outfh, "repyhelper.translate('" + includename + "')"
      print >> outfh, "from", modulename, "import *"
      
    else:
      #line includes a newline, so don't print another
      print >> outfh, line,
  
  
def translate(filename):
  """
  <Purpose>
    Translate a Repy file into a valid python module that can be invoked by
    the standard "import" statement. 
    
    Creates a python file correspond to the repy file, with the name format
    <original name>_repy.py. Performs several checks to only perform a 
    translation when necessary, to prevent accidentally clobbering other files
    
    The repyhelper and repyportability modules must be in the module path for the
    translated files
  
  <Arguments>
    repyfilename:
      A valid repy file name that exists and ends with a .repy extension. 
  
  <Exceptions>
    TranslationError if there was an error during file generation
  
  <Side Effects>
    Creates a python file correspond to the repy file, overwriting previously 
    generated files that exists with that name
  
  <Returns>
    The name of the Python module that was created in the current directory. This
    string can be used with __import__ to import the translated module.
  """

  if not os.path.isfile(filename):
    raise ValueError("File " + filename + " does not exist")
  
  modulename = _get_module_name(filename)
  generatedfilename = modulename + ".py"
  
  if _translation_is_needed(filename, generatedfilename): 
    _generate_python_file_from_repy(filename, generatedfilename)

  return modulename



def translate_and_import(filename, preserve_globals=False):
  """
  <Purpose>
    Translate a repy file to python (similarly to translate), but also import
    it to the current global namespace. This import is the same as 
    "from <module> import *", to mimic repy's include semantics, where modules
    are inlined. Globals starting with "_" are ignored. 
    
  <Arguments>
    filename:
      The name of the repy filename to translate and import
    preserve_globals:
      Whether or not to preserve globals in the current namespace.
      False means globals in current context will get overwritten by globals
      in filename if the names clash, True means to keep current globals in the
      event of a collision. Default to false
  
  <Exceptions>
    TranslationError if there was an error during translation
  
  <Side Effects>
    Creates/updates a python module corresponding to the repy file argument,
    and places references to that module in the current global namespace 
  
  <Returns>
    None
  
  """
  modulename = translate(filename)
  _import_file_contents_to_caller_namespace(modulename, preserve_globals)



def _import_file_contents_to_caller_namespace(modulename, preserve_globals):
  """
    Responsible for importing modulename, and taking the contents and 
  injecting them into the caller's namespace. If overwrite_globals is set to 
  false, then globals that are already defined in the callers namespace get 
  skipped.
  
  Doesn't include objects that start with "_"
  
  BIG HACK WARNING:
    The idea here is to use inspect to get a handle to the caller's module, and 
  start inserting elements from the imported module into the caller's global 
  namespace. This is to simulate the repy behavior of inlining includes, which
  puts everything in the same namespace.
    
  
  """
  import_module = __import__(modulename)
  
  #To get a handle on the caller's module, navigate back up the stack:
  #Go 2 frames back:back to translate_and_import, and another that's caller
  caller_globals = inspect.currentframe().f_back.f_back.f_globals

  for name,definition in inspect.getmembers(import_module):
    #like normal python from imports, don't import names starting with "_"
    if name.startswith("_"):
      continue
    
    #skip already defined vars if told to do so
    if name in caller_globals and preserve_globals:
      continue
    
    caller_globals[name] = definition
 
      
  

def main():
  if len(sys.argv)!= 3:
    print "Invalid number of arguments"
    print usestring
    sys.exit(1)
  
  infile = sys.argv[1]
  outfile = sys.argv[2]
  # don't support translating file into itself
  if infile == outfile:
    print "The infile and outfile must be different files"
    sys.exit(1)

  if _translation_is_needed(infile, outfile):
    _generate_python_file_from_repy(infile, outfile)
  else:
    print "Not generating file", outfile
    sys.exit(0)
  
  
  
if __name__ == '__main__':
  main()

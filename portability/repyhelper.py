"""
<Program Name>
  repyhelper.py

<Started>
  November 2008

<Author>
  Andreas Sekine

<Purpose>
  Make porting Repy code to regular python easier. The main interface
  is through repyhelper.translate and repyhelper.translate_and_import
  
  Note that the translation produced includes the absolute path of the
  repy file. This is for safety, to prevent multiple repy files in different 
  directories with the same name from overwriting each other. If you
  move the location of the source file, make sure to delete the old translation
  
"""

usestring = """repyhelper.py infile outfile

Processes infile to generate the valid python module outfile. 

outfile and infile must be distinct.
"""

import os #needed for file checks
import inspect #needed to fiddle with callstack/module namespaces

TRANSLATION_TAGLINE = "### Automatically generated by repyhelper.py ###"



class TranslationError(Exception):
  """ An error occurred during translation """

  

#For keeping a truly shared context between translated files
shared_context = {}
def get_shared_context():
  """ Ensure all imported repy code has a common 'mycontext' dict """
  return shared_context
  
  
def set_shared_context(context):
  """
  <Purpose>
    Set the shared mycontext dictionary
  
  <Arguments>
    context:
      A dict to use as the new mycontext
  
  <Exceptions>
  
  <Side Effects>
    Creates a python file correspond to the repy file, overwriting previously 
    generated files that exists with that name
  
  <Returns>
    The name of the Python module that was created in the current directory. This
    string can be used with __import__ to import the translated module.  
  
  """
  global shared_context
  if context is None:
    raise TypeError("Context can't be none")
  shared_context = context
  
  
#Ensure the generated module has a safe name
# Can't use . in the name because import uses it for scope, so convert to _
def _get_module_name(repyfilename):
  return repyfilename.replace(".", "_")



def _translation_is_needed(repyfilename, generatedfile):
  """ Checks if generatedfile needs to be regenerated. Does several checks to 
  decide if generating generatedfilename based on repyfilename is a good idea.
    --does file already exist?
    --was it automatically generated?
    --was the original modified since the last translation?
    
  """
  if not os.path.isfile(repyfilename):
    raise TranslationError("no such file:", repyfilename)
  if not os.path.isfile(generatedfile):
    return True
  
  #Read the first line
  try:
    fh = open(generatedfile, "r")
    #TODO does this handle windows newlines?
    first_line = fh.readline().rstrip("\n")
    fh.close()
  except IOError:
    raise TranslationError("Error opening old generated file: " + generatedfile)
  
  #Check to see if the file was generated by repyhelper, to prevent
  #clobbering a file that we didn't create
  if not first_line.startswith(TRANSLATION_TAGLINE):
    raise TranslationError("File name already exists: " + generatedfile)
  
  old_translation_path = first_line[len(TRANSLATION_TAGLINE):].strip()
  generated_abs_path = os.path.abspath(repyfilename)
  if old_translation_path != generated_abs_path:
    raise TranslationError("Path conflict when translating file " + repyfilename + ": Trying to use " + 
                           generated_abs_path + ", but old translation had path " + old_translation_path)
  
  #If we get here and modification time of orig is older than gen, this is still
  #a valid generation
  repystat = os.stat(repyfilename)
  genstat = os.stat(generatedfile)
  if repystat.st_mtime < genstat.st_mtime:
    return False
    
  return True


def _generate_python_file_from_repy(repyfilename, generatedfilename, shared_mycontext, callfunc, callargs):
  """ Generate a python module from a repy file so it can be imported
  The first line is TRANSLATION_TAGLINE, so it's easy to detect that
  the file was automatically generated
  
  """

  #Since we're outputting python code, make sure to quote the strings
  repy_callargs = []
  for arg in callargs:
    arg = arg.replace("\\", "\\\\") #escape back slashes
    arg = arg.replace("\"", "\\\"") #escape double quotes
    repy_callargs.append('"' + arg + '"')
    
  #Start the generation!
  try:
    fh = open(generatedfilename, "w")
    print >> fh, TRANSLATION_TAGLINE, os.path.abspath(repyfilename)
    print >> fh, "from repyportability import *"
    print >> fh, "import repyhelper"
    if shared_mycontext:
      print >> fh, "mycontext = repyhelper.get_shared_context()"
    else:
      print >> fh, "mycontext = {}"
    print >> fh, "callfunc = \"" + callfunc + "\""
    #Properly format the callargs list. Assume it only contains python strings
    print >> fh, "callargs = [" + ' ,'.join(repy_callargs) + "]" 
    print >> fh 
    _process_output_file(fh, repyfilename)
    fh.close()
  except IOError, e:
    raise TranslationError("Error translating file " + repyfilename + ": " + str(e))


def _process_output_file(outfh, filename):
  """ Read filename and print it to outfh, except convert includes into calls to
  repyhelper.translate
  """
  try:
    repyfh = open(filename, "r")
    repyfiledata = repyfh.readlines()
    repyfh.close()
  except IOError, e:
    print "Error opening included file", filename
    # This will make the generated file invalid python
    # Should we delete the partially translated file?
    print outfh << "ERROR PROCESSING INCLUDE:", filename
    outfh.close()
    raise TranslationError("Opening file " + filename + ": " + e.message)
  
  #Having read all the data, lets output it again, performing translations 
  #as needed
  for line in repyfiledata:
    #look for includes, and substitute them with calls to translate
    if line.lstrip().startswith('include '):
      includename = line.strip()[len('include '):]
      modulename = _get_module_name(includename)
      print >> outfh, "repyhelper.translate_and_import('" + includename + "')"
      
    else:      
      print >> outfh, line, #line includes a newline, so dont add one
  
  
def translate(filename, shared_mycontext=True, callfunc="import", callargs=None):
  """
  <Purpose>
    Translate a Repy file into a valid python module that can be imported by
    the standard "import" statement. 
    
      Creates a python file correspond to the repy file in the current directory, 
    with all '.' in the name replaced with "_", and ".py" appended to it to make
    it a valid python module name.
    Performs several checks to only perform a translation when necessary, and to 
    prevent accidentally clobbering other files.    
      The repyhelper and repyportability modules must be in the module path for the
    translated files
      Note that the optional arguments used to set variables are only inserted if 
    the file is retranslated--otherwise they are ignored.
  
  <Arguments>
    repyfilename:
      A valid repy file name that exists. 
    shared_mycontext:
      Optional parameter whether or not the mycontext of this translation should 
      be shared, or the translation should have it's own. Default True
    callfunc:
      Optional parameter for what the callfunc of this translation should be.
      Should be valid python string. Deafault "import"
    callargs:
      A list of strings to use as the repy's "callargs" variable. Default empty list.
      
  <Exceptions>
    TranslationError if there was an error during file generation
  
  <Side Effects>
    Creates a python file correspond to the repy file, overwriting previously 
    generated files that exists with that name
  
  <Returns>
    The name of the Python module that was created in the current directory. This
    string can be used with __import__ to import the translated module.
  """

  if not os.path.isfile(filename):
    raise ValueError("File " + filename + " does not exist")

  if callargs is None:
    callargs = []
  modulename = _get_module_name(filename)
  generatedfilename = modulename + ".py"
  
  if _translation_is_needed(filename, generatedfilename): 
    _generate_python_file_from_repy(filename, generatedfilename, shared_mycontext, callfunc, callargs)

  return modulename


def translate_and_import(filename, shared_mycontext=True, callfunc="import", callargs=None, preserve_globals=False):
  """
  <Purpose>
    Translate   a repy file to python (see repyhelper.translate), but also import
    it to the current global namespace. This import is the same as 
    "from <module> import *", to mimic repy's include semantics, in which
    included files are in-lined. Globals starting with "_" aren't imported. 
    
  <Arguments>
    filename:
      The name of the repy filename to translate and import
    shared_mycontext:
      Whether or not the mycontext of this translation should be shared, or
      the translation should have it's own. Default True
    callfunc:
      Optional parameter for what the callfunc of this translation should be.
      Should be valid python string. Deafault "import"
    callargs:
      A list of strings to use as the repy's "callargs" variable. Default empty list.
    preserve_globals:
      Whether or not to preserve globals in the current namespace.
      False means globals in current context will get overwritten by globals
      in filename if the names clash, True means to keep current globals in the
      event of a collision. Default False
  
  <Exceptions>
    TranslationError if there was an error during translation
  
  <Side Effects>
    Creates/updates a python module corresponding to the repy file argument,
    and places references to that module in the current global namespace 
  
  <Returns>
    None
  
  """
  modulename = translate(filename, shared_mycontext, callfunc, callargs)
  _import_file_contents_to_caller_namespace(modulename, preserve_globals)


#List of globals to skip; we want to make sure to ignore these when
#inserting the imported module's vars into the caller's namespace
# Could also blacklist the repyportability things here....
GLOBAL_VARS_BLACKLIST = ['mycontext', 'callfunc', 'callargs', 'repyhelper']

def _import_file_contents_to_caller_namespace(modulename, preserve_globals):
  """
    Responsible for importing modulename, and taking the contents and 
  injecting them into the caller's namespace. If overwrite_globals is set to 
  false, then globals that are already defined in the callers namespace get 
  skipped.
  
  Doesn't include objects that start with "_"
  
  BIG HACK WARNING:
    The idea here is to use inspect to get a handle to the caller's module, and 
  start inserting elements from the imported module into the caller's global 
  namespace. This is to simulate the repy behavior of inlining includes, which
  puts everything in the same namespace.

  """
  #Let's let python handle the initial import
  import_module = __import__(modulename)
  
  #To get a handle on the caller's module navigate back up the stack:
  #Go 2 frames back: back to translate_and_import, and another to
  #whoever called it
  caller_globals = inspect.currentframe().f_back.f_back.f_globals

  #Now iterate over the import's members, and insert them into the
  #caller's namespace
  for name,definition in inspect.getmembers(import_module):
    
    #like normal python from imports, don't import names starting with "_"
    if name.startswith('_'):
      continue
    
    #Skip blacklisted items
    if name in GLOBAL_VARS_BLACKLIST:
      continue
    
    #skip already defined vars if told to do so
    if name in caller_globals and preserve_globals:
      continue
    
    caller_globals[name] = definition
 
      
  

def main():
  if len(sys.argv)!= 3:
    print "Invalid number of arguments"
    print usestring
    sys.exit(1)
  
  infile = sys.argv[1]
  outfile = sys.argv[2]
  # don't support translating file into itself
  if infile == outfile:
    print "The infile and outfile must be different files"
    sys.exit(1)

  if _translation_is_needed(infile, outfile):
    _generate_python_file_from_repy(infile, outfile)
  else:
    print "Not generating file", outfile
    sys.exit(0)
  
  
  
if __name__ == '__main__':
  main()

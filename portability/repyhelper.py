"""
<Program Name>
  repyhelper.py

<Started>
  November 2008

<Author>
  Andreas Sekine

<Purpose>
  Make porting Repy code to regular python easier. The main interface
  is through repyhelper.translate and repyhelper.translate_and_import

"""


import os # for file checks
import inspect # for fiddling with callstack/module namespaces


TRANSLATION_TAGLINE = "### Automatically generated by repyhelper.py ###"


WARNING_LABEL = """
### THIS FILE WILL BE OVERWRITTEN!
### DO NOT MAKE CHANGES HERE, INSTEAD EDIT THE ORIGINAL SOURCE FILE
###
### If changes to the src aren't propagating here, try manually deleting this file. 
### Deleting this file forces regeneration of a repy translation

"""



class TranslationError(Exception):
  """ An error occurred during translation """



#For keeping a truly shared context between translated files
shared_context = {}
def get_shared_context():
  """ Ensure all imported repy code has a common 'mycontext' dict """
  return shared_context
  
  
def set_shared_context(context):
  """
  <Purpose>
    Set the shared mycontext dictionary
  
  <Arguments>
    context:
      A dict to use as the new mycontext
  
  <Exceptions>
    TypeError if context is none
  
  <Side Effects>
    Creates a python file correspond to the repy file, overwriting previously 
    generated files that exists with that name
  
  <Returns>
    The name of the Python module that was created in the current directory. This
    string can be used with __import__ to import the translated module.  
  
  """
  global shared_context
  if context is None:
    raise TypeError("Context can't be none")
  shared_context = context
  
  
#Ensure the generated module has a safe name
# Can't use . in the name because import uses it for scope, so convert to _
def _get_module_name(repyfilename):
  head,tail = os.path.split(repyfilename)
  tail = tail.replace('.', '_')
  return os.path.join(head, tail)


def _translation_is_needed(repyfilename, generatedfile):
  """ Checks if generatedfile needs to be regenerated. Does several checks to 
  decide if generating generatedfilename based on repyfilename is a good idea.
    --does file already exist?
    --was it automatically generated?
    --was it generated from the same source file?
    --was the original modified since the last translation?
    
  """
  
  if not os.path.isfile(repyfilename):
    raise TranslationError("no such file:", repyfilename)
    
  if not os.path.isfile(generatedfile):
    return True
  
  #Read the first line
  try:
    fh = open(generatedfile, "r")
    first_line = fh.readline().rstrip()
    fh.close()
  except IOError, e:
    raise TranslationError("Error opening old generated file: " + generatedfile + ": " + str(e))
  
  #Check to see if the file was generated by repyhelper, to prevent
  #clobbering a file that we didn't create
  if not first_line.startswith(TRANSLATION_TAGLINE):
    raise TranslationError("File name exists but wasn't automatically generated: " + generatedfile)
  
  #Check to see if the generated file has the same original source
  old_translation_path = first_line[len(TRANSLATION_TAGLINE):].strip()
  generated_abs_path = os.path.abspath(repyfilename)
  if old_translation_path != generated_abs_path:
    #It doesn't match, but the other file was also a translation! Regen then...
    return True
  
  #If we get here and modification time of orig is older than gen, this is still
  #a valid generation
  repystat = os.stat(repyfilename)
  genstat = os.stat(generatedfile)
  if repystat.st_mtime < genstat.st_mtime:
    return False
    
  return True


def _generate_python_file_from_repy(repyfilename, generatedfilename, shared_mycontext, callfunc, callargs):
  """ Generate a python module from a repy file so it can be imported
  The first line is TRANSLATION_TAGLINE, so it's easy to detect that
  the file was automatically generated
  
  """
    
  #Start the generation! Print out the header and portability stuff, then include
  #the original data and translations
  try:
    fh = open(generatedfilename, "w")
    print >> fh, TRANSLATION_TAGLINE, os.path.abspath(repyfilename)
    print >> fh, WARNING_LABEL
    print >> fh, "from repyportability import *"
    print >> fh, "import repyhelper"
    if shared_mycontext:
      print >> fh, "mycontext = repyhelper.get_shared_context()"
    else:
      print >> fh, "mycontext = {}"
    print >> fh, "callfunc =", repr(callfunc)
    #Properly format the callargs list. Assume it only contains python strings
    print >> fh, "callargs =", repr(callargs) 
    print >> fh 
    _process_output_file(fh, repyfilename, generatedfilename)
  except IOError, e:
    raise TranslationError("Error translating file " + repyfilename + ": " + str(e))
  finally:
    fh.close()

def _process_output_file(outfh, filename, generatedfilename):
  """ Read filename and print it to outfh, except convert includes into calls to
  repyhelper.translate
  """
  try:
    repyfh = open(filename, "r")
    repyfiledata = repyfh.readlines()
    repyfh.close()
  except IOError, e:
    #Delete the partially translated file, to ensure this partial translation
    #doesn't get used
    try:
      os.remove(generatedfilename)
    except (IOError, OSError):
      pass
    raise TranslationError("Error opening " + filename + ": " + str(e))
  
  #Having read all the data, lets output it again, performing translations 
  #as needed
  for line in repyfiledata:
    #look for includes, and substitute them with calls to translate
    if line.startswith('include '):
      includename = line[len('include '):].strip()
      modulename = _get_module_name(includename)
      print >> outfh, "repyhelper.translate_and_import('" + includename + "')"
    else:      
      print >> outfh, line, #line includes a newline, so dont add another
  
  
def translate(filename, shared_mycontext=True, callfunc="import", callargs=None, force_overwrite=False):
  """
  <Purpose>
    Translate a Repy file into a valid python module that can be imported by
    the standard "import" statement. 
    
      Creates a python file correspond to the repy file in the current directory, 
    with all '.' in the name replaced with "_", and ".py" appended to it to make
    it a valid python module name.
      Performs several checks to only perform a translation when necessary, and 
    to prevent accidentally clobbering other files.    
      The repyhelper and repyportability modules must be in the module path for
    the translated files
      Note that the optional arguments used to set variables are only used 
    if the file is retranslated--otherwise they are ignored. To ensure they're 
    used, manually delete the translation to force regeneration
  
  <Arguments>
    repyfilename:
      A valid repy file name that exists. 
    shared_mycontext:
      Optional parameter whether or not the mycontext of this translation should 
      be shared, or the translation should have it's own. Default True
    callfunc:
      Optional parameter for what the callfunc of this translation should be.
      Should be valid python string. Deafault "import"
    callargs:
      A list of strings to use as the repy's "callargs" variable. Default empty list.
    force_overwrite:
      If set to True, will skip all file checks and just overwrite any file with
      the same name as the generated file. Dangerous, so use cautiously. 
      Default False
      
  <Exceptions>
    TranslationError if there was an error during file generation
  
  <Side Effects>
    Creates a python file correspond to the repy file, overwriting previously 
    generated files that exists with that name
  
  <Returns>
    The name of the Python module that was created in the current directory. This
    string can be used with __import__ to import the translated module.
  """

  if not os.path.isfile(filename):
    raise ValueError("File " + filename + " does not exist")

  if callargs is None:
    callargs = []
  modulepath = _get_module_name(filename)
  modulename = os.path.basename(modulepath)
  generatedfilename = modulename + ".py"
  
  if force_overwrite or _translation_is_needed(filename, generatedfilename): 
    _generate_python_file_from_repy(filename, generatedfilename, shared_mycontext, callfunc, callargs)

  #Only return the basename, it's what __import__ expects (assuming cwd is on pythonpath)
  return modulename


def translate_and_import(filename, shared_mycontext=True, callfunc="import", callargs=None, 
                         force_overwrite=False, preserve_globals=False):
  """
  <Purpose>
    Translate a repy file to python (see repyhelper.translate), but also import
    it to the current global namespace. This import behaves similarly to python's 
    "from <module> import *", to mimic repy's include semantics, in which
    included files are in-lined. Globals starting with "_" aren't imported. 
    
  <Arguments>
    filename:
      The name of the repy filename to translate and import
    shared_mycontext:
      Whether or not the mycontext of this translation should be shared, or
      the translation should have it's own. Default True
    callfunc:
      Optional parameter for what the callfunc of this translation should be.
      Should be valid python string. Deafault "import"
    callargs:
      A list of strings to use as the repy's "callargs" variable. Default empty list.
    force_overwrite:
      If set to True, will skip all file checks and just overwrite any file with
      the same name as the generated file. Dangerous, so use cautiously. 
      Default False
    preserve_globals:
      Whether or not to preserve globals in the current namespace.
      False means globals in current context will get overwritten by globals
      in filename if the names clash, True means to keep current globals in the
      event of a collision. Default False
  
  <Exceptions>
    TranslationError if there was an error during translation
  
  <Side Effects>
    Creates/updates a python module corresponding to the repy file argument,
    and places references to that module in the current global namespace 
  
  <Returns>
    None
  
  """
  
  modulename = translate(filename, shared_mycontext, callfunc, callargs, force_overwrite)
  _import_file_contents_to_caller_namespace(modulename, preserve_globals)


#List of globals to skip; we want to make sure to ignore these when
#inserting the imported module's vars into the caller's namespace
# Could also blacklist the repyportability things here....
GLOBAL_VARS_BLACKLIST = set(['mycontext', 'callfunc', 'callargs', 'repyhelper'])

def _import_file_contents_to_caller_namespace(modulename, preserve_globals):
  """
    Responsible for importing modulename, and taking the contents and 
  injecting them into the caller's namespace. If overwrite_globals is set to 
  false, then globals that are already defined in the callers namespace get 
  skipped.
  
  Doesn't include objects that start with "_"
  
  BIG HACK WARNING:
    The idea here is to use inspect to get a handle to the caller's module, and 
  start inserting elements from the imported module into the caller's global 
  namespace. This is to simulate the repy behavior of inlining includes, which
  puts everything in the same namespace.

  """
  #DEBUG
  #caller_file = os.path.basename(inspect.currentframe().f_back.f_back.f_code.co_filename)
  #print "*** IMPORTNG", modulename, "INTO FILE", caller_file, "***"
  

  #Let python handle the initial import
  import_module = __import__(modulename)
  
  #To get a handle on the caller's module navigate back up the stack:
  #Go back 2 frames: back to translate_and_import, and another to
  #whoever called that
  caller_globals = inspect.currentframe().f_back.f_back.f_globals
  

  #Now iterate over the import's members, and insert them into the
  #caller's namespace
  for name,definition in inspect.getmembers(import_module):
    
    #like normal python from imports, don't import names starting with "_"
    if name.startswith('_'):
      continue
    
    #Skip blacklisted items
    if name in GLOBAL_VARS_BLACKLIST:
      continue
    
    #skip already defined vars if told to do so
    if name in caller_globals and preserve_globals:
      continue
      
    caller_globals[name] = definition


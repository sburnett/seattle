""" 
  <Source>
    RFC 793 -- TCP

  <State Diagram>

                                           Transmission Control Protocol
                                                Functional Specification

                              +---------+ ---------\      active OPEN  
                              |  CLOSED |            \    -----------  
                              +---------+<---------\   \   create TCB  
                                |     ^              \   \  snd SYN    
                   passive OPEN |     |   CLOSE        \   \           
                   ------------ |     | ----------       \   \         
                    create TCB  |     | delete TCB         \   \       
                                V     |                      \   \     
                              +---------+            CLOSE    |    \   
                              |  LISTEN |          ---------- |     |  
                              +---------+          delete TCB |     |  
                   rcv SYN      |     |     SEND              |     |  
                  -----------   |     |    -------            |     V  
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------                  
   |                  x         |     |     snd ACK                    
   |                            V     V                                
   |  CLOSE                   +---------+                              
   | -------                  |  ESTAB  |                              
   | snd FIN                  +---------+                              
   |                   CLOSE    |     |    rcv FIN                     
   V                  -------   |     |    -------                     
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |  
   | --------------   snd ACK   |                           ------- |  
   V        x                   V                           snd FIN V  
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |  
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |  
   |  -------              x       V    ------------        x       V  
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
                               Figure 6.
"""

include client.repy
include server.repy
include packet.repy 

# modulo arithmetic for seq_num bounds
include utilities.repy

# constants
MSS = 1050 # bytes maximum payload    
WINDOW_SIZE = 5 * MSS
MAX_SEQ_NUM = 2 ** 32 # 16 bits
MAX_ACK_NUM = 2 ** 32 # 16 bits

# Keeps track of our connection state.
class TcpStateMachine:
  """
  <Purpose>
    The state machine organizes the changes in relationship
    between a pair of connected parties.
    
  <Side Effects>
    Calls Repy's getlock().
    Uses a TcpServer and TcpClient.

  <Example Use>
    sm = TcpStateMachine
    recvmess(getmyip(), 12345, sm.next)
  """
  
  def __init__(self):
    """
    <Purpose>
      Initialize the state machine's variables. Sets state
      to be a closed connection.
    
    <Arguments>
      None
    
    <Exceptions>
      None
    
    <Side Effects>
      Creates a lock in self.lock.
      Creates a server and a client.
     
    <Returns>
      The new state machine object.
    """
    (self.STATE_CLOSED, self.STATE_LISTEN, self.STATE_SYN_SENT, \
     self.STATE_SYN_RCVD, self.STATE_ESTAB, self.STATE_FIN_WAIT_1, \
     self.STATE_FIN_WAIT_2, self.STATE_CLOSING, self.STATE_CLOSE_WAIT, \
     self.STATE_LAST_ACK, self.STATE_TIME_WAIT) = range(0, 11)

    # not initialized yet
    self.server = TcpServer()
    self.client = TcpClient()
    self.state = self.STATE_CLOSED

    # pass back to connection
    self.synip = None 
    self.synport = None

    # state changes must be atomic
    self.lock = getlock()
    self.sleep_lock = getlock()
    self.sleep_timer = None

    # timeout for handshakes
    self.HANDSHAKE_TIMEOUT = DEFAULT_RETRIES * DEFAULT_TIMEOUT
    
  # Callback for received packets
  def next(self, ip, mess, ch):
    """
    <Purpose>
      Handles all callbacks.  This function is the engine
      of a state machine.
    
    <Arguments>
      ip
          The ip of the sender
     
      mess
          The packet
 
      ch
          A handle to the UDP listener.
    
    <Exceptions>
      Raises UnknownStateError if it cannot handle the type of
      packet coming in.
    
    <Side Effects>
      Acquires the self.lock at the beginning and releases
      at end.
      Ends the UDP listener before raising an exception.

    <Returns>
      Nothing.
    """
    # two threads could come in, right?
    self.lock.acquire()       

    packet = unpack(mess)
    if(self.state == self.STATE_CLOSED): pass

    elif(self.state == self.STATE_LISTEN):
      if packet.is_syn():
        self.state = self.STATE_SYN_RCVD
        self.acceptHandShake(ip, packet)
        self.wake_up()
      else:
        stopcomm(ch)
        self.wake_up()
        self.lock.release()
        raise UnknownStateError("unknown packet: expected SYN not " + str(packet.control_bits))


    elif(self.state == self.STATE_SYN_SENT): 
      # finish the handshake with an ACK...
      if packet.is_synack():
        self.state = self.STATE_ESTAB
        self.responseHandShake(ip, packet)
        self.acceptHandShake(ip, packet)
        self.wake_up()
      # loopback special case: recv own SYN!
      elif packet.is_syn():
        self.state = self.STATE_SYN_RCVD
        self.acceptHandShake(ip, packet)
        self.wake_up()
      # who knows?
      else:
        stopcomm(ch)
        self.wake_up()
        self.lock.release()
        raise UnknownStateError("unknown packet: expected SYN or SYNACK not " + str(packet.control_bits))


    elif(self.state == self.STATE_SYN_RCVD):
      # skip the ack then...
      if packet.is_payload():
        self.state = self.STATE_ESTAB
        self.wake_up()
        self.server.process_payload(ip, packet)
      # ok ready
      elif packet.is_ack():
        self.state = self.STATE_ESTAB
        self.wake_up()
      elif packet.is_syn():
        pass #ignore
      else:
        stopcomm(ch)
        self.wake_up()
        self.lock.release()
        raise UnknownStateError("unknown packet: expected ACK not " + str(packet.control_bits))


    elif(self.state == self.STATE_ESTAB):
      # count packet or ignore old ack
      if packet.is_ack():
        self.client.process_ack(packet)
      # Send back an ack or reack.
      elif packet.is_payload():
        self.server.process_payload(ip, packet)
      # who knows?
      elif packet.is_synack() or packet.is_syn():
	pass # ignore old handshake
      else:
        stopcomm(ch)
        self.lock.release()
        raise UnknownStateError("unknown packet: expected PSH or ACK not " + str(packet.control_bits))

    elif(self.state == self.STATE_FIN_WAIT_1): pass
    elif(self.state == self.STATE_FIN_WAIT_2): pass
    elif(self.state == self.STATE_CLOSING): pass
    elif(self.state == self.STATE_CLOSE_WAIT): pass
    elif(self.state == self.STATE_LAST_ACK): pass
    elif(self.state == self.STATE_TIME_WAIT): pass
    else:
      self.lock.release()
      raise UnknownStateError("undefined state")
    
    self.lock.release()


  # Part of handshake: Step 2
  # Block until a SYN comes.  Then, return.
  # State should be in STATE_SYN_RCVD.
  def listen(self):
    """
    <Purpose>
      Called by Connection.  Continues the listen procedure.
      Sets the state to STATE_LISTEN.

      Blocks and waits until it receives a SYN or it times out.
      Knows if received a SYN by the next() function changing
      state from STATE_LISTEN.

      The next() function should set up the client/server with
      the appropriate window sizes and sequence number from the
      request.
    <Arguments>
      None.
    
    <Exceptions>
      TimeoutError if it does not receive a SYN.
      AlreadyConnectedError if the state is not STATE_CLOSED
    
    <Side Effects>
      Acquires a lock to handle shared syn variables.
     
    <Returns>
      The ip and port of the remote party.
    """

    self.lock.acquire()
    if self.state != self.STATE_CLOSED:
      self.lock.release()
      raise AlreadyConnectedError("cannot listen because the connection is already in use")
    self.state = self.STATE_LISTEN 
    self.lock.release()

    # wait for a request, coming out early
    retries = DEFAULT_RETRIES
    while retries > 0 and self.state == self.STATE_LISTEN:
      self.sleep_lock.acquire()
      retries -= 1
      self.goto_sleep(self.HANDSHAKE_TIMEOUT)

    if self.state == self.STATE_LISTEN:
      raise TimeoutError("timed out listening")

    # make sure and return the syn address
    self.lock.acquire()
    if self.synip == None or self.synport == None:
      raise UnknownStateError("Must have recvd SYN (but did not?)")
    remote_address = (self.synip, self.synport)

    # Uninitialize them
    self.synip = None
    self.synport = None
    self.lock.release()

    return remote_address


  # Handshake: Step 1
  # Send out a SYN
  # Block until response SYN or SYNACK
  def connect(self, destip, destport, srcip, srcport):
    """
    <Purpose>
      Requests a connection.  Trickled down from Connection
      class.
  
      Sets state to STATE_SYN_SENT.  Waits for a SYN or SYNACK.
      Knows by a change in state through next() when a response comes.
      
    <Arguments>
      destip
         The ip to send to.
      
      destport
         The port to send to.
 
      srcip
         Who am I?  What ip?

      srcport
         Who am I?  What port?
    
    <Exceptions>
      TimeoutError if the party does not respond.
      AlreadyConnectedError if the connection is used

    <Side Effects>
      Sends a UDP message.  
      Makes a new rand_seq_num() and sets up its client
      and server with the sequence number.
     
    <Returns>
      Nothing.
    """

    self.lock.acquire()
    if self.state != self.STATE_CLOSED:
      self.lock.release()
      raise AlreadyConnectedError("cannot connect because the connection is already in use")
    self.state = self.STATE_SYN_SENT
    self.lock.release()

    # Agree to start at,
    start_num = self.rand_start_num()
    self.client.reset(start_num, None)
    self.server.reset(start_num)

    # init handshake
    handShakePack = TcpPacket(srcport, destport, start_num, 0, "SYN", WINDOW_SIZE, "syncing...").pack()


    # wait for a request, coming out early on yes
    retries = DEFAULT_RETRIES
    while self.state == self.STATE_SYN_SENT and retries > 0:
      self.sleep_lock.acquire()
      register_sendmess(destip, destport, handShakePack)
      retries -= 1
      self.goto_sleep(self.HANDSHAKE_TIMEOUT)
 
    if self.state == self.STATE_SYN_SENT:
      raise TimeoutError("timed out waiting to connect")
  
    # loopback, we need to wait for SYN-SYN-ACK
    if self.state == self.STATE_SYN_RCVD:
      tcpAck = TcpPacket(srcport, destport, 0, start_num, "ACK", 0, "acking syn ...").pack()
      # wait for a request, coming out early on yes
      retries = DEFAULT_RETRIES    
      while self.state == self.STATE_SYN_RCVD and retries > 0:
        self.sleep_lock.acquire()
        register_sendmess(destip, destport, tcpAck)
        retries -= 1
        self.goto_sleep(self.HANDSHAKE_TIMEOUT)
     
      if self.state != self.STATE_ESTAB:
        raise TimeoutError("timed out waiting to connect")

    if self.state != self.STATE_ESTAB:
      raise UnknownStateError("State must be STATE_ESTAB after connecting")

  # Handshake: Step 2
  # Method called by application to continue handshake
  def accept(self, destip, destport, srcip, srcport):
    """
    <Purpose>    
      Trickled down from Connection.accept().
      Sends back a SYNACK to the requester.  Waits for
      ACK or data. 
    
      On return, guarentees the state to be STATE_ESTAB.

    <Arguments>
      destip
         The ip to send to.
      
      destport
         The port to send to.
 
      srcip
         Who am I?  What ip?

      srcport
         Who am I?  What port?
          
    <Exceptions>
      TimeoutError if the requestor does not respond.
      NotConnectedError if the listen() call wasn't called
    
    <Side Effects>
      Sends UDP message.
     
    <Returns>
      Nothing.
    """

    if self.state != self.STATE_SYN_RCVD and self.state != self.STATE_ESTAB:
      raise NotConnectedError("cannot accept without a requested connection")
    
    # we haven't sent a syn yet
    if self.state == self.STATE_SYN_RCVD:
      responseTcpPack = TcpPacket(srcport, destport, 0, self.server.last_ack_sent, "SYNACK", WINDOW_SIZE, "synacking...")

      # wait for ack or data    
      retries = DEFAULT_RETRIES    
      while self.state == self.STATE_SYN_RCVD and retries > 0:
        self.sleep_lock.acquire()
        register_sendmess(destip, destport, responseTcpPack.pack())
        retries -= 1
        self.goto_sleep(self.HANDSHAKE_TIMEOUT)

      if self.state == self.STATE_SYN_RCVD:
        raise TimeoutError("timed out waiting to accept")

    # was before accept() or is now
    if self.state != self.STATE_ESTAB:
      raise UnknownStateError("State must be STATE_ESTAB after accepting")

    
  # Pass on to the client
  def send(self, data, destip, destport, \
                srcip, srcport, retries, timeout):
    """
    <Purpose>
      Pass on a send.
    
    <Arguments>
      Same as Connection.send()
    
    <Exceptions>
      TimeoutError if the send fails.
    
    <Side Effects>
      None
     
    <Returns>
      The bytes sent.
    """
    
    return self.client.send(data, destip, destport, \
                        srcip, srcport, retries, timeout)


  def recv(self, maxlen):
    """
    <Purpose>
      Pass on recv.
    
    <Arguments>
      maxlen
        maximum bytes to get.
    
    <Exceptions>
      None
    
    <Side Effects>
      Deletes data from buffer.
     
    <Returns>
      The first maxlen bytes in buffer.
    """
    
    return self.server.recv(maxlen)





  ##############################################################
  # Private
  ##############################################################

  # Helps Handshake: Step 1
  # New sequence number to start with
  def rand_start_num(self):
    """
    <Purpose>
      
    
    <Arguments>
      
    
    <Exceptions>
      
    
    <Side Effects>
      
     
    <Returns>
      
    """
    
    return int(randomfloat() * (MAX_SEQ_NUM - 1))

  # Helps Handshake: Step 2
  # Method will be called when a HandShake request is recieved by passive comp.
  def acceptHandShake(self, ip, tcpPack):
    """
    <Purpose>
      
    
    <Arguments>
      
    
    <Exceptions>
      
    
    <Side Effects>
      
     
    <Returns>
      
    """

    # save these to send back by listen() to connection obj
    # Later used by conn.accept()
    self.synip = ip
    self.synport = tcpPack.srcport    

    # Set up the client and server to be ready
    # choose the lesser window
    synwindow = tcpPack.window
    if (WINDOW_SIZE < synwindow):
      synwindow = WINDOW_SIZE

    self.client.reset(tcpPack.seq_num, synwindow)
    self.server.reset(tcpPack.seq_num)

  # Handshake: Step 3
  # Method will be called when a response handshake from passive is recieved.
  def responseHandShake(self, ip, tcpPack):
    """
    <Purpose>
      
    
    <Arguments>
      
    
    <Exceptions>
      
    
    <Side Effects>
      
     
    <Returns>
      
    """
    tcpAck = TcpPacket(tcpPack.destport, tcpPack.srcport, 0, tcpPack.seq_num, "ACK", 0, "acking syn ...").pack()
    register_sendmess(ip, tcpPack.srcport, tcpAck)

  def goto_sleep(self, time):
    # wait for a request, coming out early
    self.sleep_timer = settimer(time, self.wake_up, ())

  def wake_up(self):
    if self.sleep_timer:
      canceltimer(self.sleep_timer)
      self.sleep_timer = None
      self.sleep_lock.release()

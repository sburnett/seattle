"""
<Author>
  Richard Jordan

<Start Date>
  January 24th, 2009

<Description>
  Test that the internals of TCP work as expected.

<Usage>
  Public Objects:
    StubConnection - Dummy Tcp Socket.  Minimal set of TCP.
"""

# Acts like Berkeley Socket.
class StubConnection:
  """
  <Purpose>
    Wraps up a minimal Tcp socket.
  <Side Effects>
    None
  <Example Use>
    # Get an object
    connection = StubConnection()
    # bind to an address
    connection.bind(getmyip(), 12345)
    # open a connection
    connection.connect('123.4.5.6', 12345)
    # write information to the connected party
    connection.send("hello")
    # receive information from the connected party
    connection.recv(4096)
    # and disconnect without checking if they have said anything
    connection.disconnect()
  """   

  ########### Public methods #######

  # Get object
  def __init__(self):
    self.conn = None
    (self.STATE_CLOSED, self.STATE_LISTEN, self.STATE_SYN_RCVD, self.STATE_SENDING, \
     self.STATE_ACKED, self.STATE_ESTAB, self.STATE_FIN_WAIT_1, \
     self.STATE_FIN_WAIT_2, self.STATE_CLOSING, self.STATE_CLOSE_WAIT, \
     self.STATE_LAST_ACK, self.STATE_TIME_WAIT) = range(0, 12)

    self.state = self.STATE_CLOSED
    self.conn  = None
    self.packet_cache = {} # any packets we recv
  
    self.RETRIES = 4
    self.TIMEOUT = .01
    self.WINDOW = WINDOW_SIZE

    self.SEQ_NUM = 1 # just start at the same one for all

    self.lock = getlock()
  def bind(self, localip, localport):
    """
    <Purpose>
      Attaches the socket to an address.

    <Arguments>
      localip:
             The ip to communicate from.  Probably is either '127.0.0.1' or
             the result from getmyip().

      localport:
             The port to communicate from.  The restrictions file must allow
             this port as a messport.

    <Exceptions>
      None              

    <Side Effects>
      None   

    <Returns>
      Nothing  
    """
    # I am:
    self.localip = localip
    self.localport = localport

  # Setup a udp callback    
  def listen(self):
    """
    <Purpose>
      Allows the local connection to receive messages.
      Waits RETRIES * TIMEOUT times for a connection request.
      If it doesn't hear back, it raises an exception.
      Otherwise it grabs the remote address (see callback on how).

    <Arguments>
      None

    <Exceptions>
      NotBoundError if bind() is not yet called.
      TimeoutError if no request.
    <Side Effects>
      Sets up a UDP callback.

    <Returns>
      Nothing           
    """         
    if not self.localip or not self.localport:
      raise NotBoundError("need to bind before listening")

    self.conn = recvmess(self.localip, self.localport, self.callback)
    self.state = self.STATE_LISTEN

    # wait a little
    retries = self.RETRIES
    while self.state == self.STATE_LISTEN and retries > 0:
      sleep(self.TIMEOUT)
      retries -= 1

    if retries == 0:
      raise TimeoutError("timed out listening")

    # see callback for how these are set
    # who requested?
    self.seq_num = self.synseqnum
    self.remoteip = self.synip
    self.remoteport = self.synport

   # Fake the synack.
  def accept(self):
    """
    <Purpose>
      Fakes the continuation the 3-way handshake.
      Called by application after a call to listen() receives
      a request by connect().  Continues the process of connecting
      with the remote host.
      Blocks until the remote host responds or times out.
   
    <Arguments>
      None

    <Exceptions>
      TimeoutError if the remote host does not respond in default
        timeout times retries seconds.           

    <Side Effects>
      None

    <Returns>
      Nothing  
    """        
    # response with SYNACK
    retries = self.RETRIES
    while self.state == self.STATE_SYN_RCVD and retries > 0:
      sendmess(self.remoteip, self.remoteport, \
        TcpPacket(self.localport, self.remoteport, self.seq_num, 0, "SYNACK", self.WINDOW, "synacking...").pack())
      sleep(self.TIMEOUT)
      retries -= 1
    
    if retries == 0:
      raise TimeoutError("timed out accepting")

  # Start faking the handshake
  def connect(self, remoteip, remoteport):
    """
    <Purpose>   
      Starts a mock handshake.          
      Requests a TCP connection with the remote party.
      The remote party should have called listen().  Blocks
      until the remote party responds by calling accept().
      Then returns and waits for calls to send() and recv().        

    <Arguments>
      remoteip:                 
             The ip to communicate to.    

      remoteport:      
             The port to communicate to.

    <Exceptions>
      NotBoundError if bind() is not yet called.
      TimeoutError if the remote host does not respond in default
        timeout times retries seconds.

    <Side Effects>
      Sets up a UDP callback.

    <Returns>
      Nothing
    """
    self.remoteip = remoteip
    self.remoteport = remoteport
    self.state = self.STATE_SENDING
    self.conn = recvmess(self.localip, self.localport, self.callback)

    # wait a little
    retries = self.RETRIES
    while self.state == self.STATE_SENDING and retries > 0:
      sendmess(remoteip, remoteport, \
        TcpPacket(self.localport, remoteport, self.SEQ_NUM, 0, "SYN", self.WINDOW, "syncing...").pack())
      sleep(self.TIMEOUT)
      retries -= 1

    if self.state != self.STATE_ACKED:
      raise TimeoutError("timed out during connect()")

    # send final ack for 3-way
    sendmess(remoteip, remoteport, \
      TcpPacket(self.localport, remoteport, self.SEQ_NUM, 0, "ACK", self.WINDOW, "acking synack...").pack())

  # Close the connection
  # BUG: Need Tcp 4-way close
  def disconnect(self):
    if self.conn == None:
      raise NotConnectedError("cannot disconnect without connection")
    stopcomm(self.conn)
    self.conn = None

  # UDP callback
  def callback(self, ip, port, mess, ch):
    # print mess # DEBUG
    self.lock.acquire()
    packet = unpack(mess)
    self.last_packet = packet
    if(self.state == self.STATE_CLOSED): pass
    elif(self.state == self.STATE_LISTEN):
      if packet.is_syn():
        self.synip = ip
        self.synport = packet.srcport
        self.synseqnum = packet.seq_num
        self.state = self.STATE_SYN_RCVD
    elif(self.state == self.STATE_SYN_RCVD):
      if packet.is_ack() or packet.is_payload():
        self.state = self.STATE_ESTAB
    elif(self.state == self.STATE_SENDING):
      self.state = self.STATE_ACKED
    elif(self.state == self.STATE_ACKED): pass
    elif(self.state == self.STATE_ESTAB):
      if packet.is_payload():
        self.packet_cache[packet.seq_num] = packet
    elif(self.state == self.STATE_FIN_WAIT_1): pass
    elif(self.state == self.STATE_FIN_WAIT_2): pass               
    elif(self.state == self.STATE_CLOSING): pass
    elif(self.state == self.STATE_CLOSE_WAIT): pass
    elif(self.state == self.STATE_LAST_ACK): pass       
    elif(self.state == self.STATE_TIME_WAIT): pass 
    else:
      self.lock.release()
      raise UnknownStateError("undefined state")

    self.lock.release()


### Client Tests #################

  # In test code:
  # ... # setup code
  # MESS = "message larger than MSS"
  # try:
  #   real_tcp_socket.send(MESS)
  # except TimeoutError:
  #   stub.assert_sent_full_window(MESS)
  # else:
  #   raise Exception("should have raised timeout")
  def assert_sent_full_window(self, message):
    buffer = ""
    for seq_num in self.packet_cache.keys():
      buffer += self.packet_cache[seq_num].payload
      
    mess_len = len(message)
    assert len(self.packet_cache) == mess_len/MSS
    
    if len(self.packet_cache) != mess_len/MSS:
      raise Exception(str(len(self.packet_cache)) + " != " + str(mess_len/MSS))

  # window_size < len(message) < MSS
  def assert_sent_tiny_window(self, message, window_size):
    buffer = ""
    for seq_num in self.packet_cache.keys():
      buffer += self.packet_cache[seq_num].payload

    assert buffer == message[0:window_size]
    assert len(self.packet_cache) == 1

  # Make sure sends a syn
  def assert_sent_syn(self):
    assert len(self.packet_cache) == 1 # only sent SYN
    (seq_num, packet) = self.packet_cache.popitem() # get the SYN
    assert packet.control_bits == "SYN"


#### Server Tests ###############

  # Make sure responds to syn
  def assert_responds_to_syn(self, remoteip, remoteport):
    if not self.localip or not self.localport:
      raise NotBoundError("need to bind before connecting")

    # Peer is:
    self.remoteip = remoteip
    self.remoteport = remoteport

    seq_num = int(randomfloat() * (MAX_SEQ_NUM - 1))
    self.conn = recvmess(self.localip, self.localport, self.callback)
    self.state = self.STATE_ESTAB

    sendmess(remoteip, remoteport, \
      TcpPacket(self.localport, remoteport, seq_num, 0, "SYN", 1, "syncing...").pack())

    retries = self.RETRIES
    while len(self.packet_cache) == 0 and retries > 0:
      sleep(self.TIMEOUT)
      retries -= 1

    packet = self.last_packet # get the SYN
    assert packet.control_bits == "SYNACK"

  # Send out of order and then see if the last
  # ack is cumulative.
  def assert_cumulative_acking(self):
    seq_num = 1
    mess = 'a'
    self.state = self.STATE_SENDING
    tries = self.RETRIES
    while tries and self.state == self.STATE_SENDING:
      sendmess(self.remoteip, self.remoteport, \
        TcpPacket(self.localport, self.remoteport, seq_num, 0, "PSH", 1, mess).pack())
      tries -= 1
      sleep(self.TIMEOUT)
    assert self.state == self.STATE_ACKED

    # expect no ack
    mess = 'c'
    seq_num = 3
    self.state = self.STATE_SENDING
    tries = 2
    while tries: # send it a few times
      sendmess(self.remoteip, self.remoteport, \
        TcpPacket(self.localport, self.remoteport, seq_num, 0, "PSH", 1, mess).pack())
      tries -= 1
      sleep(self.TIMEOUT)
  
    mess = 'b'
    seq_num = 2
    tries = self.RETRIES
    while tries and self.state == self.STATE_SENDING:
      sendmess(self.remoteip, self.remoteport, \
        TcpPacket(self.localport, self.remoteport, seq_num, 0, "PSH", 1, mess).pack())
      tries -= 1
  
    sleep(self.TIMEOUT * self.RETRIES)

    assert self.state == self.STATE_ACKED
    assert self.last_packet.ack_num == 4

  # Make sure fails to ack when missing a seq.
  def assert_does_not_ack_missing(self):
    seq_num = self.SEQ_NUM
    mess = 'a'
    self.state = self.STATE_SENDING
    tries = self.RETRIES
    while tries and self.state == self.STATE_SENDING:
      sendmess(self.remoteip, self.remoteport, \
        TcpPacket(self.localport, self.remoteport, seq_num, 0, "PSH", 1, mess).pack())
      tries -= 1
      sleep(self.TIMEOUT)
    assert self.state == self.STATE_ACKED

    # expect no ack
    mess = 'c'
    seq_num = 3
    self.state = self.STATE_SENDING
    tries = self.RETRIES
    while tries: # send it a few times
      sendmess(self.remoteip, self.remoteport, \
        TcpPacket(self.localport, self.remoteport, seq_num, 0, "PSH", 1, mess).pack())
      tries -= 1
      sleep(self.TIMEOUT)
  
    # wait a little to make sure
    sleep(self.TIMEOUT * self.RETRIES)

    assert self.last_packet.ack_num == 2

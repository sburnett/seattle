include constants.repy
include errors.repy
include packet.repy
include sleep_lock.repy
include utilities.repy

# Holds sending structure
class TcpClient:
  """
  <Purpose>
    A connection has two personalities: 
      an active-sender-client and 
      a passive-receiver-server.

    This class is the active-sender-client.
    
  <Side Effects>
    Call getlock()
    
  <Example Use>
    def callback(ip, port, mess, ch):
      print mess

    recvmess(getmyip(), 12345, callback)
    client = TcpClient()
    client.send(getmyip(), 12345, "hi")

  """

  def __init__(self, conn):
    """
    <Purpose>
      Initializes varibles.
    
    <Arguments>
      None.
    
    <Exceptions>
      None.
    
    <Side Effects>
      Creates self.lock
     
    <Returns>
      New client object.
    """
    self.conn = conn    
    self.packet_cache = {} # holds currently sent, unacked packets

    # kept track of + updated by Server
    self.recv_window_size = None # size of window

    # Sliding window accounting
    self.send_window_size = None # size of window
    self.last_ack_recv = None # recv back by SYNACK, Beginning of window 
    self.last_seq_sent = mod_rand()  # End of window

    self.lock = getlock()
    self.sleep_lock = SleepLock()

  def send(self, data, destip, destport, \
                srcip, srcport, retries, timeout):
    """
    <Purpose>
      Trickled down from connection via state machine.
      Does sliding window algorithm.  Uses slow start.

    <Arguments>
      ...
    
    <Exceptions>
      TimeoutError if not enough ACK's come back.
    
    <Side Effects>
      Sends UDP messages.
      Uses self.lock
     
    <Returns>
      The bytes sent.
    """
    bytes_sent = 0  # total bytes sent

    # Split up into bytes
    data = list(data)
 
    # Send them -- Sliding Window Algorithm
    while data:   
      # reset variables
      last_ack = self.last_ack_recv # save to see if changes
      times_sent = 0
 
      # while we haven't receieved a newer ack
      while self.last_ack_recv == last_ack:
        self.sleep_lock.acquire()
        # give up
        if times_sent > retries:
          self.sleep_lock.release()
#          raise Exception("tried %d times" % times_sent)
          raise TimeoutError("tried %d times" % times_sent)

        self.lock.acquire()
        # Send or Re-send all those in cache
        # BUG: Should these be modulo sorted?
        # Say we're never sending the first
        # one because the window size is too small.
        seqs = self.packet_cache.keys() 
        free_window = self.send_window_size
        for seq_num in seqs:
          if len(self.packet_cache[seq_num].payload) <= free_window:
            free_window -= len(self.packet_cache[seq_num].payload)
            bytes_sent += self.conn.register_sendmess(destip, destport, \
                self.packet_cache[seq_num].pack(), srcip, srcport)
          else: # can't send anymore
            free_window = 0
            break

        # make and Send a new packet -- Slow Start Algorithm
        if data and free_window:
            # can we send the whole window?
            if free_window < MSS: # yes
              payload_size = self.send_window_size
            else: # no just send MSS of the window
              payload_size = MSS 
            # make the packet
            next_seq_num = mod_add(self.last_seq_sent, 1)
            packet = TcpPacket(srcport, destport, next_seq_num, 0, "PSH", WINDOW_SIZE, ''.join(data[0:payload_size]))
            del data[0:payload_size]
            self.packet_cache[packet.seq_num] = packet
            self.last_seq_sent = mod_add(packet.seq_num, len(packet.payload) - 1)
            # send it as well
            bytes_sent += self.conn.register_sendmess(destip, destport, packet.pack(), srcip, srcport)
        self.lock.release()

        # increment tries
        times_sent += 1
        # take a deep breath
        self.sleep_lock.sleep(timeout)

    return bytes_sent


  # Used for SYNACK to send it, stops with Timeout or
  # the window_size is set by ACK
  def accept(self, ack_num, destip, destport, \
                srcip, srcport, retries, timeout):
    if not self.send_window_size is None or not self.last_ack_recv is None:
      raise UnknownStateError("whoa shouldn't have variables yet")
   
    synack = TcpPacket(srcport, destport, self.last_seq_sent, ack_num, "SYNACK", self.recv_window_size, "synacking...")
    times_sent = 0
    bytes_sent = 0
    while self.send_window_size is None:
      self.sleep_lock.acquire()
      # give up
      if times_sent > retries:
        self.sleep_lock.release()
        raise TimeoutError("tried %d times" % times_sent)

      self.lock.acquire()
      bytes_sent += self.conn.register_sendmess(destip, destport, \
                	synack.pack(), srcip, srcport)

      self.lock.release()
      times_sent += 1
      self.sleep_lock.sleep(timeout)

    return bytes_sent

  def process(self, packet):
    """
    <Purpose>
      Handles ACK's (and therefore SYNACK's)
      Sets up variables and stops sleeping. 
   
    <Arguments>
      packet
        the ACK or SYNACK
    
    <Exceptions>
      raise NotConnectedError("no packets sent to ack")
    
    <Side Effects>
      Changes window size and seq nums and last ack recv
     
    <Returns>
      True if the packet is a SYNACK and valid.
    """
    self.lock.acquire()

    if self.last_seq_sent == None:
      self.lock.release()
      raise NotConnectedError("no packets sent to ack")
    elif packet.is_synack():
      return self.process_synack(packet)
    elif packet.is_ack():
      self.process_ack(packet)
    else:
      pass

    self.lock.release()

  ##########
  # Getters
  ##########
 
  # atomic setter for Server to specify recv window
  def set_recv_window(self, size):
    self.lock.acquire()
    self.recv_window_size = size
    self.lock.release()

  ##########
  # Private
  ##########
  def process_synack(self, packet):
    """
    <Purpose>
      Accounts a synack.
      Verifies if valid ACK num of SYN sent.

    <Returns>
      True if the SYNACK is valid, false otherwise.
    """
    is_valid = False
    if self.last_ack_recv is None and packet.ack_num == self.last_seq_sent:  # new synack
      self.last_ack_recv = self.last_seq_sent
      self.sleep_lock.wakeup()
      is_valid = True 

    elif not self.last_ack_recv is None and packet.ack_num == self.last_seq_sent:  # old synack
      if self.last_ack_recv != self.last_seq_sent: # never will happen
	raise UnknownStateError("cannot be true that old synack is not current ack")
      is_valid = True 

    elif packet.ack_num != self.last_seq_sent:  # bad synack
      pass
    else: # no other cases
      pass

    if is_valid:
      # reset window
      self.send_window_size = packet.window 

    return is_valid

  def process_ack(self, packet):
    """
    <Purpose>
      Handles ACK's from receiver.

      Throws an error if the last seq number is undefined
      or if the packet is not an ack.
      Accounts to stop resending the acked packet.
    
    <Arguments>
      packet
        the ACK
    
    <Exceptions>
      ...
    
    <Side Effects>
      Changes window size and seq nums and last ack recv
     
    <Returns>
      Nothing.
    """
    if not packet.is_ack():
      raise UnknownStateError("expected an ack")

    next_ack = mod_add(self.last_seq_sent, 1)

    # if a newer ack that falls in sent
    if mod_between(self.last_ack_recv, packet.ack_num, next_ack):

      # -- Cumulative ACK Processing
      for seq_num in self.packet_cache.keys():  
        # Delete all packets below this recvd ack_num.
        # We never received their acks but the sender must have
        # received the payloads of all seq_num before this ack by
        # the definition of our protocol.
        if mod_between(self.last_ack_recv, seq_num, packet.ack_num):
          del self.packet_cache[seq_num]

      # all done up to this ack
      self.last_ack_recv = packet.ack_num
      self.sleep_lock.wakeup()

    else: # old ack 
      pass # ignore it

    # reset window
    self.send_window_size = packet.window 

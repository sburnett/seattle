"""
<Author>
  Richard Jordan

<Start Date>
  January 13th, 2009

<Description>
  Work towards Tcp over Upd.

  This code implements:
     * reliable packets (acks) (1/13/09)
     * the sliding window (1/20/09)
     * three way handshake (2/4/09)

<Usage>
  Public Objects:
    Connection - Tcp Socket.  Sends/Receives messages.
    NotConnectedError(Exception) - recv or send called without peer
    TimeoutError(Exception) - no response from peer
    NotBoundError(Exception) - the connection needs to have an address

  Public Methods:
    Connection() - get new socket
    connection.bind(localip, localport) - sets localip, localport
    connection.listen() - listen for peers
    connection.accept() - accept a request from a peer
    connection.connect(remoteip, remoteport) - request a connection
    connection.send(data) - send data to current peer
    connection.recv(maxLen) - recv data from current peer
    connection.disconnect() - end connection with current peer

  Private Methods:
    connection.callback(ip, port, mess, ch) - single inlet for receiving
    connection.register_recvmess(ip, port, callback) - single point for setting up listener

  Other Public Methods:
    register_sendmess(destip, destport, message, srcip = None, srcport = None) -
    	single outlet for sending

  Private Objects:
    TcpStateMachine - handles event calls, sending, recving, handshake.
"""

# state machine class
include state_machine.repy

include errors.repy


##############################################################
# Constants
##############################################################

DEFAULT_MAXDGRAMSIZE = 1050 # MSS
DEFAULT_RETRIES = 4 # listen times for ack
DEFAULT_TIMEOUT = .01 # seconds to wait

##############################################################
# Public Interface
##############################################################

# Acts like Berkeley Socket.
class Connection:
  """
  <Purpose>
    Wraps up a Tcp socket.
  <Side Effects>
    None
  <Example Use>
    # Get an object
    connection = Connection()
    # bind to an address
    connection.bind(getmyip(), 12345)
    # open a connection
    connection.connect('123.4.5.6', 12345)
    # write information to the connected party
    connection.send("hello")
    # receive information from the connected party
    connection.recv(4096)
    # and disconnect without checking if they have said anything
    connection.disconnect()
  """   

  ##############################################################
  # Public methods
  ##############################################################

  # Get object
  def __init__(self):
    """
    <Purpose>
      Initializes an object to communicate from.

    <Arguments>
      None

    <Exceptions>
      None

    <Side Effects>
      Sets defaults for:
        * maxdgramsize - the maximum size of a packet
        * retries - times to retry sending
        * timeout - seconds to wait before retrying

    <Returns>
      A new Connection object.
    """

    # Let's assign some constants
    self.DEFAULT_MAXLEN = 4096 # 4 kilo bytes ??


    # Configuration  
    self.maxdgramsize = DEFAULT_MAXDGRAMSIZE
    self.retries = DEFAULT_RETRIES
    self.timeout = DEFAULT_TIMEOUT

    # undefined
    self.localip = None
    self.localport = None
    self.remoteip = None
    self.remoteport = None
    self.conn = None

    # temporary for listen - accept transition
    self.requestip = None
    self.requestport = None

    # Let's put all the protocol details in a state machine
    self.state_machine = TcpStateMachine()

    # need locks for race conditions
    self.lock = getlock()  # general
    self.send_lock = getlock() # just send
    self.recv_lock = getlock() # just recv


  # Attach to an address
  def bind(self, localip, localport):
    """
    <Purpose>
      Attaches the socket to an address.

    <Arguments>
      localip:
             The ip to communicate from.  Probably is either '127.0.0.1' or
             the result from getmyip().

      localport:
             The port to communicate from.  The restrictions file must allow
             this port as a messport.

    <Exceptions>
      AlreadyConnectedError if the connection is active.

    <Side Effects>
      None

    <Returns>
      Nothing
    """
    self.lock.acquire()
    if self.conn:
      self.lock.release()
      raise AlreadyConnectedError("cannot rebind an active connection")
    
    # I am:
    self.localip = localip
    self.localport = localport
    self.lock.release()

  # Setup a udp callback    
  def listen(self):
    """
    <Purpose>
      Allows the local connection to receive messages.
      Blocks until it receives a connection request.
      Then returns for the application to call accept().

    <Arguments>
      None

    <Exceptions>
      NotBoundError if bind() is not yet called.
      TimeoutError if no request comes in default
        timeout times retries seconds.
      AlreadyConnectedError if the connection is active.

    <Side Effects>
      Sets up a UDP callback.

    <Returns>
      Tuple address(ip, port) of remote party.
    """

    self.lock.acquire()
    if not self.localip or not self.localport:
      self.lock.release()
      raise NotBoundError("need to bind before listening")

    if self.conn:
      self.lock.release()
      raise AlreadyConnectedError("cannot listen with an active connection")

    self.conn = self.register_recvmess(self.localip, self.localport, self.callback)
    # block until syn request
    (self.requestip, self.requestport) = self.state_machine.listen() 
    self.lock.release()
    return (self.requestip, self.requestport)

  # continue handshake
  def accept(self):
    """
    <Purpose>
      Called by application after a call to listen() receives
      a request by connect().  Continues the process of connecting
      with the remote host.
      Blocks until the remote host responds or times out.
    
    <Arguments>
      None      
    
    <Exceptions>
      TimeoutError if the remote host does not respond in default
        timeout times retries seconds.
      NotConnectedError if the connection is not established.
    
    <Side Effects>
      None      
     
    <Returns>
      Nothing
    """
    self.lock.acquire()
    if not self.localip or not self.localport:
      self.lock.release()
      raise NotBoundError("need to bind and listen before accepting")

    if self.conn == None:
      self.lock.release()
      raise NotConnectedError("cannot accept without a connection")

    if self.remoteip and self.remoteport:
      self.lock.release()
      raise AlreadyConnectedError("cannot accept when already connected")

    if not self.requestip or not self.requestport:
      self.lock.release()
      raise NotRequestedError("cannot accept without a request")

    self.state_machine.accept(self.requestip, self.requestport, self.localip, self.localport)
    self.remoteip = self.requestip
    self.remoteport = self.requestport
    self.requestip = None
    self.requestport = None
    self.lock.release()

  # Request connection.
  def connect(self, remoteip, remoteport):
    """
    <Purpose>
      Requests a TCP connection with the remote party.  
      The remote party should have called listen().  Blocks
      until the remote party responds by calling accept().
      Then returns and waits for calls to send() and recv().

    <Arguments>
      remoteip:
             The ip to communicate to.

      remoteport:
             The port to communicate to.

    <Exceptions>
      NotBoundError if bind() is not yet called.
      TimeoutError if the remote host does not respond in default
        timeout times retries seconds.
      AlreadyConnectedError if the connection is active.

    <Side Effects>
      Sets up a UDP callback.

    <Returns>
      Nothing
    """
    self.lock.acquire()
    if not self.localip or not self.localport:
      self.lock.release()
      raise NotBoundError("need to bind before connecting")

    if self.conn:
      self.lock.release()
      raise AlreadyConnectedError("cannot connect on an active connection")

    # Peer is:
    self.remoteip = remoteip
    self.remoteport = remoteport

    # listen for responses
    self.conn = self.register_recvmess(self.localip, self.localport, self.callback)

    self.state_machine.connect(remoteip, remoteport, \
		self.localip, self.localport) # block until syn recv
    self.lock.release()

  # Sends via client the data in packets to the server. 
  # Throws exception on timeout.
  # Throws an exception when no connection
  # Returns the bytes sent.
  def send(self, data):
    """
    <Purpose>
      Send a message over our TCP connection to the remote party.

    <Arguments>
      data:
             Whatever message you want to send to the remote party.

    <Exceptions>
      NotConnectedError if the connection is not established.

    <Side Effects>
      None

    <Returns>
      The bytes sent over the network.  The bytes include lost or
      dropped packets.
    """

    self.send_lock.acquire()
    if self.conn == None:
      self.send_lock.release()
      raise NotConnectedError("cannot send data without a receiver")
   
    # send them
    bytes = self.state_machine.send(data, self.remoteip, self.remoteport, \
					self.localip, self.localport, \
					self.retries, self.timeout)
    self.send_lock.release()
    return bytes

  # Throws an exception when no connection
  # Returns a buffer filled with data. 
  # Returns a maximum of maxLen bytes.
  def recv(self, maxLen):
    """
    <Purpose>
      Receive a message over our TCP connection from the remote party.

    <Arguments>
      maxLen:
             The maximum bytes you want to receive.

    <Exceptions>
      NotConnectedError if the connection is not established.

    <Side Effects>
      Will wait 1 timeout period if the buffer is empty.
      Deletes the returned data from the connection buffer.

    <Returns>
      The maxLen bytes.
    """
    self.recv_lock.acquire()

    if self.conn == None:
      self.recv_lock.release()
      raise NotConnectedError("cannot recv data without listening")
  
    message = self.state_machine.recv(maxLen)
    
    # If empty, wait a little
    if not message:
      sleep(self.timeout)
      message = self.state_machine.recv(maxLen)

    self.recv_lock.release()
    return message

  # Close the connection
  # BUG: Need Tcp 4-way close
  def disconnect(self):
    """
    <Purpose>
      End our TCP connection with the remote party.

    <Arguments>
      None

    <Exceptions>
      NotConnectedError if the connection is not established.

    <Side Effects>
      Destroys the UDP callback.

    <Returns>
      Nothing
    """

    self.lock.acquire()
    self.send_lock.acquire()
    self.recv_lock.acquire()
    if self.conn == None:
      self.recv_lock.release()
      self.send_lock.release()
      self.lock.release()
      raise NotConnectedError("cannot disconnect without connection")
    stopcomm(self.conn)
    self.conn = None
    self.recv_lock.release()
    self.send_lock.release()
    self.lock.release()


  # hook for controller to intercept event calls
  def callback(self, ip, port, mess, ch):
    """
    <Purpose>
      Provides a single way point between received messages.
      Allows for easier debugging.  By putting a single output 
      statement you can output all messages that come in.
    
      Passes call down to statemachine's callback.
      Elimates UDP port which should not be used.

    <Arguments>
      Same as a UDP callback.
    
    <Exceptions>
      Undefined
    
    <Side Effects>
      Undefined
     
    <Returns>
      Nothing
    """
    print "recving: " + mess + " at: " + str(ip) + ":" + str(port) # DEBUG
    self.state_machine.next(ip, mess, ch)


  # Hook for controller to handle recv
  def register_recvmess(self, ip, port, callback):
    """
    <Purpose>
      Provides a single point for setting up a listener.
      Allows for easier debugging.  By putting a single output 
      statement you can know whenever the code sets up a listener.

    <Arguments>
      Same as Repy's UDP recvmess.
    
    <Exceptions>
      Same as Repy's UDP recvmess.
    
    <Side Effects>
      Sets up UDP listener event.
     
    <Returns>
      A handle to the listener event.
    """
    # print "listening on: " + str(ip) + ":" + str(port) # DEBUG
    return recvmess(ip, port, self.callback)

##############################################################
# Other Public and Private Methods
##############################################################


# Hook for controller to handle send
def register_sendmess(destip, destport, message, srcip = None, srcport = None):
  """
  <Purpose>
    Provides a single outlet for tracking sent messages.
    Allows for easier debugging.  By putting a single output
    statement you can output all messages that go out.

  <Arguments>
    Same as Repy's UDP sendmess.
    
  <Exceptions>
    Same as Repy's UDP sendmess.
    
  <Side Effects>
    None
     
  <Returns>
    The bytes sent.
  """
  # print "sending: " + message # DEBUG
  if srcip is None:
    return sendmess(destip, destport, message)
  else:  
    return sendmess(destip, destport, message, srcip, srcport)

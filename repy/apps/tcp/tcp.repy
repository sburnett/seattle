"""
<Author>
  Richard Jordan

<Start Date>
  January 13th, 2009

<Description>
  Work towards Tcp over Upd.

  This code implements:
     * reliable packets (acks) (1/13/09)
     * the sliding window (1/20/09)
     * three way handshake (2/4/09)

<Usage>
  Public Objects:
    Connection - Tcp Socket.  Sends/Receives messages.
    NotConnectedError(Exception) - recv or send called without peer
    TimeoutError(Exception) - no response from peer
    NotBoundError(Exception) - the connection needs to have an address

  Public Methods:
    Connection() - get new socket
    connection.bind(localip, localport) - sets localip, localport
    connection.listen() - listen for peers
    connection.accept() - accept a request from a peer
    connection.connect(remoteip, remoteport) - request a connection
    connection.send(data) - send data to current peer
    connection.recv(maxLen) - recv data from current peer
    connection.disconnect() - end connection with current peer

  Private Objects:
    TcpStateMachine - handles event calls
    TcpPacket - encapsilates packet structure
    TcpClient - encapsilates sender
    TcpServer - encapsilates receiver 
"""

# modulo arithmetic for seq_num bounds
include utilities.repy 
# packet class
include packet.repy
# client class
include client.repy
# server class
include server.repy
# state machine class
include state_machine.repy

##############################################################
# Public Exceptions
##############################################################

class NotConnectedError(Exception):
  """This exception indicates the executed action cannot take place without 
     starting a connection"""

class NotBoundError(Exception):
  """This exception indicates the executed action cannot take place without 
     binding to a local address"""

class TimeoutError(Exception):
  """This exception indicates that the peer is not responded in enough time"""


##############################################################
# Constants
##############################################################

MAX_SEQ_NUM = 2 ** 32 # 16 bits 
MAX_ACK_NUM = 2 ** 32 # 16 bits 

MSS = 1050 # bytes maximum payload
DEFAULT_MAXDGRAMSIZE = MSS # always same as MSS
WINDOW_SIZE = 5 * MSS
DEFAULT_RETRIES = 4 # listen times for ack
DEFAULT_TIMEOUT = .001 # 1 millisecond to wait

# lock
conn_lock = getlock()

##############################################################
# Public Interface
##############################################################

# Acts like Berkeley Socket.
class Connection:
  """
  <Purpose>
    Wraps up a Tcp socket.
  <Side Effects>
    None
  <Example Use>
    # Get an object
    connection = Connection()
    # bind to an address
    connection.bind(getmyip(), 12345)
    # open a connection
    connection.connect('123.4.5.6', 12345)
    # write information to the connected party
    connection.send("hello")
    # receive information from the connected party
    connection.recv(4096)
    # and disconnect without checking if they have said anything
    connection.disconnect()
  """   

  ##############################################################
  # Public methods
  ##############################################################

  # Get object
  def __init__(self):
    """
    <Purpose>
      Initializes an object to communicate from.

    <Arguments>
      None

    <Exceptions>
      None

    <Side Effects>
      None

    <Returns>
      A new Connection object.
    """

    # Let's assign some constants
    self.DEFAULT_MAXLEN = 4096 # 4 kilo bytes ??


    # Configuration  
    self.maxdgramsize = DEFAULT_MAXDGRAMSIZE
    self.retries = DEFAULT_RETRIES
    self.timeout = DEFAULT_TIMEOUT

    # undefined
    self.localip = None
    self.localport = None
    self.remoteip = None
    self.remoteport = None

    # Let's put all the protocol details in a state machine
    self.state_machine = TcpStateMachine()

  # Attach to an address
  def bind(self, localip, localport):
    """
    <Purpose>
      Attaches the socket to an address.

    <Arguments>
      localip:
             The ip to communicate from.  Probably is either '127.0.0.1' or
             the result from getmyip().

      localport:
             The port to communicate from.  The restrictions file must allow
             this port as a messport.

    <Exceptions>
      None

    <Side Effects>
      None

    <Returns>
      Nothing
    """
    # I am:
    self.localip = localip
    self.localport = localport

  # Setup a udp callback    
  def listen(self):
    """
    <Purpose>
      Allows the local connection to receive messages.

    <Arguments>
      None

    <Exceptions>
      NotBoundError if bind() is not yet called.

    <Side Effects>
      Sets up a UDP callback.

    <Returns>
      Nothing
    """

    if not self.localip or not self.localport:
      raise NotBoundError("need to bind before listening")

    
    self.conn = recvmess(self.localip, self.localport, self.callback)
    # block until syn request
    (self.remoteip, self.remoteport) = self.state_machine.listen() 
    

  # continue handshake
  def accept(self):
    """
    <Purpose>
      
    
    <Arguments>
      
    
    <Exceptions>
      
    
    <Side Effects>
      
     
    <Returns>
      
    """
    self.state_machine.accept(self.remoteip, self.remoteport, self.localip, self.localport)

  # Request connection.
  def connect(self, remoteip, remoteport):
    """
    <Purpose>
      Requests a TCP connection with the remote party.

    <Arguments>
      remoteip:
             The ip to communicate to.

      remoteport:
             The port to communicate to.

    <Exceptions>
      NotBoundError if bind() is not yet called.

    <Side Effects>
      Sets up a UDP callback.

    <Returns>
      Nothing
    """
    if not self.localip or not self.localport:
      raise NotBoundError("need to bind before connecting")

    # Peer is:
    self.remoteip = remoteip
    self.remoteport = remoteport

    # listen for responses
    self.conn = recvmess(self.localip, self.localport, self.callback)

    self.state_machine.connect(remoteip, remoteport, \
		self.localip, self.localport) # block until syn recv

  # Sends via client the data in packets to the server. 
  # Throws exception on timeout.
  # Throws an exception when no connection
  # Returns the bytes sent.
  def send(self, data):
    """
    <Purpose>
      Send a message over our TCP connection to the remote party.

    <Arguments>
      data:
             Whatever message you want to send to the remote party.

    <Exceptions>
      NotConnectedError if the connection is not established.

    <Side Effects>
      None

    <Returns>
      The bytes sent over the network.  The bytes include lost or
      dropped packets.
    """

    if self.conn == None:
      raise NotConnectedError("cannot send data without a receiver")
   
    # send them
    return self.state_machine.send(data, self.remoteip, self.remoteport, \
					self.localip, self.localport, \
					self.retries, self.timeout)

  # Throws an exception when no connection
  # Returns a buffer filled with data. 
  # Returns a maximum of maxLen bytes.
  def recv(self, maxLen):
    """
    <Purpose>
      Receive a message over our TCP connection from the remote party.

    <Arguments>
      maxLen:
             The maximum bytes you want to receive.

    <Exceptions>
      NotConnectedError if the connection is not established.

    <Side Effects>
      Will wait 1 timeout period if the buffer is empty.
      Deletes the returned data from the connection buffer.

    <Returns>
      The maxLen bytes.
    """

    if self.conn == None:
      raise NotConnectedError("cannot recv data without listening")
  
    message = self.state_machine.server.buffer[0:maxLen]
    
    # If empty, wait a little
    if not message:
      sleep(self.timeout)
      message = self.state_machine.server.buffer[0:maxLen]
    
    # remove from buffer
    del self.state_machine.server.buffer[0:maxLen]

    return ''.join(message)

  # Close the connection
  # BUG: Need Tcp 4-way close
  def disconnect(self):
    """
    <Purpose>
      End our TCP connection with the remote party.

    <Arguments>
      None

    <Exceptions>
      NotConnectedError if the connection is not established.

    <Side Effects>
      Destroys the UDP callback.

    <Returns>
      Nothing
    """

    if self.conn == None:
      raise NotConnectedError("cannot disconnect without connection")
    stopcomm(self.conn)
    self.conn = None

  ##############################################################
  # Private
  ##############################################################

  def callback(self, ip, port, mess, ch):
    """
    <Purpose>
      
    
    <Arguments>
      
    
    <Exceptions>
      
    
    <Side Effects>
      
     
    <Returns>
      
    """
    # print mess # DEBUG
    self.state_machine.next(ip, port, mess, ch)

# Holds receiving structure
class TcpServer:
  """
  <Purpose>
    A connection has two personalities:
      an active-sender-client and
      a passive-receiver-server.

    This class is the passive-receiver-server.
    
  <Side Effects>
    Call Repy's getlock()
    
  <Example Use>
    serv = TcpServer()

    def callback(ip, port, mess, ch):
      packet = unpack(mess)
      serv.process_payload(ip, packet)

    serv.recvmess(getmyip(), 12345, callback)
    sendmess(getmyip(), 12345, "hi")
    hi_message = serv.recv(2)
    
  """

  def __init__(self):
    """
    <Purpose>
      Initialize variables.
    
    <Arguments>
      None.
    
    <Exceptions>
      None.
    
    <Side Effects>
      Call Repy's getlock().
     
    <Returns>
      New server object.
    """
    
    self.buffer = [] # Receiver buffer of payloads
    self.packet_cache = {} # holds received, out-of-order packets

    # Sliding window accounting
    self.recv_window_size = WINDOW_SIZE # size of window
    self.last_ack_sent = None # Begining of window
    self.last_seq_recv = None # BUG: Do we need this? What for?

    # lock on buffer control
    self.lock = getlock()

  # Throws exception if not a payload or no connection.
  # Then, if payload is next, fills buffer with payload.
  # Else, if payload is in window, caches packet.
  # Otherwise, re-acks packet.
  def process_payload(self, ip, packet):
    """
    <Purpose>
      Called to handle packets such that packet.is_payload().
      Sends back ACK's, saves payloads, or ignores.
    
    <Arguments>
      ip
          The ip it came from.    

      packet 
          The packet to process

    <Exceptions>
      NotConnectedError if there is not a connection yet 
        to recv a packet.
      UnknownStateError if the packet is not a payload
    
    <Side Effects>
      Adds to self.buffer.
      Uses self.lock

    <Returns>
      Nothing.
    """
    
    if not packet.is_payload():
      raise UnknownStateError("expected a payload")
    if self.last_ack_sent == None:
      raise NotConnectedError("no client yet")
    if not packet.payload: # no data?
      return None

    self.lock.acquire()

    # Is it the payload we want?
    if self.last_ack_sent == packet.seq_num:
      #  -- Cumulative Acking
      # See how many we have in our window. 
      # We can skip all these acks.
      seq_num = packet.seq_num
      self.packet_cache[packet.seq_num] = packet
      while seq_num in self.packet_cache.keys():
        packet = self.packet_cache[seq_num]
        self.buffer += packet.payload
        new_seq_num = mod_add(packet.seq_num, len(packet.payload), MAX_SEQ_NUM)
        del self.packet_cache[seq_num]
        seq_num = new_seq_num

      # Ask for the next missing one
      self.last_ack_sent = seq_num
      register_sendmess(ip, packet.srcport, TcpPacket(packet.destport, packet.srcport, 0, self.last_ack_sent, \
                 "ACK", WINDOW_SIZE, "ack...").pack())

    # Maybe we can cache it.  Is it inside our window?
    elif packet.seq_num in mod_range(self.last_ack_sent, self.last_ack_sent \
                                        + self.recv_window_size, MAX_ACK_NUM):
      # don't have it yet?
      if not packet.seq_num in self.packet_cache.keys():
        # save it quietly
        self.packet_cache[packet.seq_num] = packet
      else: # ignore the already cached seq
        pass

    # Send back an ack again for the payload we really want.
    else: 
      register_sendmess(ip, packet.srcport, TcpPacket(packet.destport, packet.srcport, 0, self.last_ack_sent, "ACK", WINDOW_SIZE, \
                "resending ack...").pack())

    self.lock.release()

  # Setup initial state
  def reset(self, start_num):
    self.lock.acquire()
    self.last_ack_sent = start_num
    self.last_seq_recv = mod_sub(start_num, 1, MAX_SEQ_NUM)
    self.lock.release()

  # Finish off trickled down call to recv
  def recv(self, maxLen):
    self.lock.acquire()
    message = self.buffer[0:maxLen]
    
    # remove from buffer
    del self.buffer[0:maxLen]

    self.lock.release()

    return ''.join(message)


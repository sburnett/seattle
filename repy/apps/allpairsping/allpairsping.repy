MAXIMUM_MSG_SIZE = 1024 #maximum number of bytes per message contents per send call to user
MAXIMUM_HTTP_REQUEST_SIZE= 4000 #max number of bytes in a http get request

# send a probe message to each neighbor
def probe_neighbors(port):

  for neighborip in mycontext["neighborlist"]:
    mycontext['sendtime'][neighborip] = getruntime()
    sendmess(neighborip, port, 'ping',getmyip(),port)

    sendmess(neighborip, port,'share'+encode_row(getmyip(), mycontext["neighborlist"], mycontext['latency'].copy()))
    # sleep in between messages to prevent us from getting a huge number of 
    # responses all at once...
    sleep(.5)

  # Call me again in 10 seconds
  while True:
    try:
      settimer(10,probe_neighbors,(port,))
      return
    except Exception, e:
      if "Resource 'events'" in str(e):
        # there are too many events scheduled, I should wait and try again
        sleep(.5)
        continue
      raise
  


# Handle an incoming message
def got_message(srcip,srcport,mess,ch):
  if mess == 'ping':
    sendmess(srcip,srcport,'pong')
  elif mess == 'pong':
    # elapsed time is now - time when I sent the ping
    mycontext['latency'][srcip] = getruntime() - mycontext['sendtime'][srcip]

  elif mess.startswith('share'):
    mycontext['row'][srcip] = mess[len('share'):]



def encode_row(rowip, neighborlist, latencylist):

  retstring = "<tr><td>"+rowip+"</td>"
  for neighborip in neighborlist:
    if neighborip in latencylist:
      retstring = retstring + "<td>"+str(latencylist[neighborip])[:4]+"</td>"
    else:
      retstring = retstring + "<td>Unknown</td>"

  retstring = retstring + "</tr>"
  return retstring


# Displays a web page with the latency information
def show_status(): 

  webpage = "<html><head><title>Latency Information</title></head><body><h1>Latency information from "+getmyip()+' </h1><table border="1">'

  webpage = webpage + "<tr><td></td><td>"+ "</td><td>".join(mycontext['neighborlist'])+"</td></tr>"

  # copy to prevent a race
#  connobj.send(encode_row(getmyip(), mycontext['neighborlist'], mycontext['latency'].copy()))

  for nodeip in mycontext['neighborlist']:
    if nodeip in mycontext['row']:
      webpage = webpage + mycontext['row'][nodeip]+'\n'
    else:
      webpage = webpage + '<tr><td>'+nodeip+'</td><td>No Data Reported</td></tr>\n'

  # now the footer...
  webpage = webpage + '</table></html>'

  return webpage






# Get entire HTTP GET request to keep the browser happy
# Keeps trying to receive data from the user until it 
# finds the '\n\n' sequence or maxes past the upper reasonable limit of bytes read.
# Returns True if the entire line was found and False if not
def get_complete_request(client_conn):

  msg_recvd = ""
  num_bytes_recvd = 0

  while( num_bytes_recvd < MAXIMUM_HTTP_REQUEST_SIZE):

    #try to get more data from the client
    temp_recvd = client_conn.recv(1)

    #update the total number of bytes of data received from the connection
    num_bytes_recvd += temp_recvd


    # Remove carriage returns, '/r' characters, from the new data received and then add it to the data you've already collected 
    # Some machines use '\r\n' as a newline character while others just use '\n'
    # So you can see 2 newline characters in a row on all machines as '\n\n'
    msg_recvd += temp_recvd
    msg_recvd = msg_recvd.replace("\r\n","\n")


    if ( msg_recvd.find("\n\n") != -1 ):
      # the 2 newlines were found so return the data
      return True

  return False



 

# Sends response arguement to a client via the client connection and then closes it.
def send_reply(response, client):
  count = 0
  length_of_msg = len(response)

  while(count < length_of_msg):
    string_to_send = ''
    max= count + MAXIMUM_MSG_SIZE

    if(max >= length_of_msg):
      string_to_send = response[count: ]
    else:
      string_to_send = response[count:max]

    num_sent = client.send(string_to_send)
    count += num_sent

  client.close()


# Closes client connection when called.
def close_user_conn(client_conn):
  client_conn.close()





def send_webpage_to_user(ip, port, client_conn, thiscommhandle, listencommhandle):

  # The lock is acquired so that no other client can reset the timer or concurrently open a file.
  mycontext['lock'].acquire()

  # Set a 6 second timeout for the connection to be closed if the client doesn't send a request.
  close_client_conn = settimer(6.0, timed_out, [client])

  try:
    get_request_results = get_complete_request(client_conn)
    canceltimer(close_client_conn)

    if(get_request_results == True):

      page_results = show_status()
      send_reply(page_results, client_conn)
 
  except:
    print 'client timed out'
  finally:
    mycontext['lock'].release()
    stopcomm(thiscommhandle)





if callfunc == 'initialize':

  # this holds the response information (i.e. when nodes responded)
  mycontext['latency'] = {}

  # this remembers when we sent a probe
  mycontext['sendtime'] = {}

  # this remembers row data from the other nodes
  mycontext['row'] = {}
  
  # get the nodes to probe
  mycontext['neighborlist'] = []
  for line in file("neighboriplist.txt"):
    mycontext['neighborlist'].append(line.strip())

  ip = getmyip() 
  if len(callargs) != 1:
    raise Exception, "Must specify the port to use"
  pingport = int(callargs[0])

  # call gotmessage whenever receiving a message
  recvmess(ip,pingport,got_message)  

  probe_neighbors(pingport)

  # Setup the webserver
  # we want to register a function to show a status webpage (TCP port)
  pageport = int(callargs[0])
  mycontext['lock'] = getlock()
  listencommhandle = waitforconn(ip, pageport, send_webpage_to_user)

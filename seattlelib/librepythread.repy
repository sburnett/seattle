"""
This is a sub-component os librepy, and provides
thread, and locking related functionality. It must
be imported, and cannot be used directly as a module.

This module will import librepyrunloop, so if one unified
run-loop is to be used, then the global variable
"librunloop" should be overriden.

This module provides the following objects:
  - Lock()
  - RLock()
  - Thread()
  - Timer()

These objects are meant to emulate the python builtin
versions. The Lock is a generic binary semaphore,
RLock is a re-entrant lock (meaning the same thread can
re-acquire the lock without deadlocking). The Thread
is wrapper around the createthread() API, and can be
sub-classed to implement a thread. The Timer is a sub-class
of the Thread object, and is the same except that it
supports a delay before the thread is initialized.

When start() is called on a Timer object, the creation
of the thread is scheduled in a runloop. In this manner,
it is possible to schedule multiple threads simultaneously
without wasting events. For example, if threads are set
to start staggered, in (1,2,3) seconds, then it is possible
for one event to be used rather than having three threads
which are sleeping until their start time.

"""
##### Imports

# Get a run loop
librunloop = dy_import_module("librepyrunloop")


##### Public methods

def active_threads():
  """Returns the active thread count."""
  # Call getresources to get the usage and return the event count
  lim, usage, stops = getresources()
  return usage["events"]


##### Class Definitions

class Lock (object):
  """Generic binary semaphore."""
  def __init__(self):
    self.lock = createlock()

  def acquire(self, blocking=True):
    return self.lock.acquire(blocking)

  def release(self):
    self.lock.release()



class RLock (object):
  """Re-entrant lock object."""
  def __init__(self):
    self.lock = createlock()
    self.holding_lock = createlock()
    self.holding_thread = None
    self.acquire_count = 0

  def acquire(self, blocking=True):
    """
    <Purpose>
      Acquires the lock. If the current thread has already acquired
      this lock, calling acquire() will NOT deadlock. The lock will be
      re-acquired. Each time acquire() is successful, release() must be called.

    <Arguments>
      blocking: (Optional) If True, the thread will block until the lock is acquired.
                Defaults to True.

    <Returns>
      True if the lock was acquired.
    """
    # Get the first lock
    self.lock.acquire(True)
    try:
      # Check if we are the holding lock, or if it is none
      thread_name = getthreadname()
      if self.holding_thread is None and self.holding_lock.acquire(False):
        self.holding_thread = thread_name
        self.acquire_count = 1
        return True

      elif self.holding_thread == thread_name:
        self.acquire_count += 1
        return True

      # If we are not willing to block, then we just return now
      elif not blocking:
        return False

    finally:
      self.lock.release()

    # Otherwise, we wait to get the holding lock
    self.holding_lock.acquire(True)
    self.holding_thread = thread_name
    self.acquire_count = 1
    return True

  
  def release(self):
    """
    <Purpose>
      Releases the lock. This must be called once per successful acquire()

    <Exceptions>
      Raises RuntimeError if this thread does not hold the lock.

    <Returns>
      None
    """
    # Get the first lock
    self.lock.acquire(True)
    try:
      # Check if the thread name matches
      thread_name = getthreadname()
      if thread_name == self.holding_thread:
        # Reduce the acquire count
        self.acquire_count = max(0, self.acquire_count - 1)
        
        # If this thread has no more acquire counts, we are no longer
        # the holding thread
        if self.acquire_count == 0:
          self.holding_thread = None
          self.holding_lock.release()

      else:
        raise RuntimeError, "Cannot release a lock held by another thread!"
    finally:
      self.lock.release()



class Thread (object):
  """
  Provides an implementation of a thread like object.
  A sub-class should override the run() method.

  """
  def __init__(self,target=None,args=None,kwargs=None):
    """
    <Purpose>
      Creates a new Thread object
    
    <Arguments>
       target: The callable object to be invoked by the run() method.
       args : The argument tuple for the target invocation
       kwargs : A dictionary of keyword arguments for the target invocation

    <Returns>
      A new thread object.
    """
    # Substitude default args
    if args is None:
      args = ()
    if kwargs is None:
      kwargs = {}

    # Store the args
    self.target = target
    self.args = args
    self.kwargs = kwargs

    # Set alive to false
    self.alive = False
    self.alive_lock = createlock()

    # This is a list of locks which are all trying to be acquired
    # by threads which have "joined" this thread
    self.join_locks = []


  def start(self):
    """
    <Purpose>
      Starts the thread.

    <Exceptions>
      Raises RuntimeError if the thread is already started.

    <Returns>
      None
    """
    # Launch a thread on the _run() method
    # That will invoke run()
    self.alive_lock.acquire(True)
    try:
      if self.alive:
        raise RuntimeError, "Thread already started!"

      self.alive = True
      createthread(self._run)
    
    finally:
      self.alive_lock.release()


  def _run(self):
    """Private run method."""
    try:
      self.run()
    finally:
      self.alive_lock.acquire(True)
      self.alive = False
    
      # Release all joined threads
      for lock in self.join_locks:
        lock.release()
      self.join_locks = []

      self.alive_lock.release()


  def run(self):
    """
    This should be overridden by sub-classes.
    Default run method invokes the target given at initialization time.
    """
    # Invoke the target method
    if self.target is not None:
      func = self.target
      func(*self.args, **self.kwargs)


  def is_alive(self):
    """Returns if a thread is alive. Live from start() until run() exits."""
    self.alive_lock.acquire(True)
    try:
      return self.alive
    finally:
      self.alive_lock.release()


  def join(self):
    """
    <Purpose>
      Joins the thread. 
    
    <Exceptions>
      Raises RuntimeError if the thread is not alive.

    <Returns>
      None
    """
    # Check if the thread is alive
    if not self.is_alive():
      raise RuntimeError, "Thread is not alive!"

    # Create a lock
    lock = createlock()
    lock.acquire(True) # Acquire once
    self.join_locks.append(lock) # Append this lock
    lock.acquire(True) # This will block until the thread exits


class Timer (Thread):
  """
  This class emulates a Timer thread.
  """
  def __init__(self, interval, target=None, args=None, kwargs=None):
    """
    <Purpose>
    Creates a new Timer object

    <Arguments>
      interval: How long to delay between calling start() and starting the thread.
      target: The callable object to be invoked by the run() method.
      args : The argument tuple for the target invocation
      kwargs : A dictionary of keyword arguments for the target invocation

    <Exceptions>
      TypeError if the interval is not an int or float.
      ValueError if the interval is negative.

    <Returns>
      A new Timer object
    """
    if type(interval) not in [int, float]:
      raise TypeError, "Interval must be an integer or floating point value!"
    if interval < 0:
      raise ValueError, "Interval cannot be negative!"
    
    # Initialize the super-class
    Thread.__init__(self, target=target, args=args, kwargs=kwargs)

    # Store the interval
    self.intv = interval

    # Store a lock to serialize cancel / start
    self.cancel_lock = createlock()

    # This is our runloop handle
    self.rl_handle = None


  def start(self):
    """
    <Purpose>
      Schedules the thread to be started.

    <Exceptions>
      Raises RuntimeError if the thread is already started.
      Raises RuntimeError if the thread is scheduled to start.

    <Notes>
      This calls runEvery() which is a method provided by the
      runloop. If the run loop is not running, this will consume
      an event to start the run loop. Once the 'interval' number
      of seconds has elapsed, the run-loop will launch the thread.
    """
    # Acquire the canceled lock
    self.cancel_lock.acquire(True)
    try:
      # Check if we are started
      if self.is_alive():
        raise RuntimeError, "Thread is already started!"
      if self.rl_handle is not None:
        raise RuntimeError, "Thread is already scheduled to start!"

      # Create a wrapper function
      def wrapper():
        librunloop.stopSchedule(self.rl_handle)
        Thread.start(self)
        self.rl_handle = None

      # Schedule us. The run loop will wait for the interval
      # and then launch the thread
      self.rl_handle = librunloop.runEvery(self.intv, wrapper)

    finally:
      self.cancel_lock.release()


  def cancel(self):
    """
    <Purpose>
      Cancels starting the thread after start() has been called.

    <Exceptions>
      Raises RuntimeError if the thread is already started.
      Raises RuntimeError if the thread is not scheduled to start.

    <Returns>
      None.
    """
    # Get the cancel lock
    self.cancel_lock.acquire(True)
    try:
      # Check if we are started
      if self.is_alive():
        raise RuntimeError, "Thread is already started!"
      if self.rl_handle is None:
        raise RuntimeError, "Thread is not scheduled to start!"

      # Cancel the schedule
      librunloop.stopSchedule(self.rl_handle)

      # Set the handle to None
      self.rl_handle = None

    finally:
      self.cancel_lock.release()
  

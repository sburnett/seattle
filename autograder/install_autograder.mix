"""
<Program Name>
  install_autograder.py

<Author>
  Alper Sarikaya
  alpers@cs.washington.edu

<Purpose>

<Todo>

"""

import sys 
import nmAPI
import persist

from repyportability import *
include nmclient.repy

include rsa.repy

nextid = 1
key = {}
vesselinfo = {}

# the default Seattle instance to connect to
DEFAULT_NODEMANAGER_PORT = 1224

# alpers - adds a vessel and its information to the overall vessel dict
#          (from seash.mix); this is strictly internal.
def add_vessel(longname, vesselhandle):
    global nextid

    vesselinfo[longname] = {}
    vesselinfo[longname]['handle'] = vesselhandle
#    vesselinfo[longname]['keyname'] = keyname
    vesselinfo[longname]['IP'] = longname.split(':')[0]
    vesselinfo[longname]['port'] = int(longname.split(':')[1])
    vesselinfo[longname]['vesselname'] = longname.split(':')[2]
    


def add_node_by_hostname(host, port=DEFAULT_NODEMANAGER_PORT):
    """
    <Purpose>
      Attempts to find a running Beraber instance at the host specified, connect
      to it, and add meta-information about the instance and its available vessels
      to the internal dictionary (vesselinfo).

    <Arguments>
      host:
          The host where the Beraber instance is running (ip or full-qual name)
      port:
          The port where the Beraber instance is running (default 1224)

    <Exceptions>
      Will (doesn't atm) throw an exception if the module has not been initalized, the
      host was not found, or no Beraber instance was found running on the specified
      host:port.

    <Side Effects>
      Updates internal dict vesselinfo

    <Returns>
      None.
    """

    # get information about the node's vessels
    thishandle = nmclient_createhandle(host, port, privatekey = key['private'], 
                                       publickey = key['public'])
    ownervessels, uservessels = nmclient_listaccessiblevessels(thishandle, 
                                                               key['public'])
    
    new_vessel_list = []
    
    # we should add anything we can access (we only care about ownervessels)
    for vesselname in ownervessels:
      longname = host+":"+str(port)+":"+vesselname
      if longname not in vesselinfo:
        # set the vesselname
        # NOTE: we leak handles (no cleanup of thishandle).   
        # I think we don't care...
        newhandle = nmclient_duplicatehandle(thishandle)
        handleinfo = nmclient_get_handle_info(newhandle)
        handleinfo['vesselname'] = vesselname
        nmclient_set_handle_info(newhandle, handleinfo)
        
        add_vessel(longname, newhandle)
        new_vessel_list.append('%'+str(id)+"("+longname+")")
        
        
    # tell the user what we did...
    if len(new_vessel_list) == 0:
        print "Could not add any targets."
    else:
        print "Added targets: "+", ".join(new_vessel_list)
    

# alpers - attempts to tell each vessel to run a program
def run_target(longname, filename, filedata, argstring):
    """
    <Purpose>
      Attempts to add and run a file on a specific vessel given the vessel's longname
      and the file data.  This should be the main way to execute repy code on emulab
      servers.

    <Arguments>
      longname:
          The vessel's longname, i.e. ip:port:vessel_name

      filename:
          The name of the repy file

      filedata:
          A string containing the contents of the file

      argstring:
          An argument string passed to the repy program at runtime - note that the 
          argstring is NEVER empty - the first argument should always be the filename.

    <Exceptions>
      At the moment will throw an exception if the longname is invalid.  In the future,
      will throw an exception if the module has not been initialized.

    <Side Effects>
      None.

    <Returns>
      A tuple with the format (success?, info).  On success, the tuple (True,) will be 
      returned; on failure the tuple (False, str(exception)) will be returned.
    """

    vesselname = vesselinfo[longname]['vesselname']
    try:
        nmclient_signedsay(vesselinfo[longname]['handle'], "AddFileToVessel", 
                           vesselname, filename, filedata)
    except NMClientException, e:
        return (False, str(e))
    
    print "Successfully added ", filename, " to vessel"
    
    try:
        nmclient_signedsay(vesselinfo[longname]['handle'], "StartVessel", 
                           vesselname, argstring)
    except NMClientException, e:
        return (False, str(e))
    else:
        print "Successfully started vessel with repy file"
        return (True,)
    


def stop_target(longname):
    """
    <Purpose>
      Stop a vessel from executing repy code.

    <Arguments>
      longname:
          The vessel's longname, i.e. ip:port:vessel_name

    <Exceptions>
      At the moment will throw an exception if the longname is invalid.  In the future,
      will throw an exception if the module has not been initalized.

    <Side Effects>
      None.

    <Returns>
      A tuple consisting of (success?, info)
    """

    vesselname = vesselinfo[longname]['vesselname']
    try:
        nmclient_signedsay(vesselinfo[longname]['handle'], "StopVessel", vesselname)
    except NMClientException, e:
        return (False, str(e))
    else:
        return (True,)



def showlog_vessel(longname):
    """
    <Purpose>
      Get a vessel's log outlining output from the executed repy file.

    <Arguments>
      longname:
          The vessel's longname, i.e. ip:port:vessel_name

    <Exceptions>
      At the moment will throw an exception if the longname is invalid.  In the future,
      will throw an exception if the module has not been initalized.

    <Side Effects>
      None.

    <Returns>
      A tuple consisting of (success?, info).  A successful log-get will write the log
      to the info variable, otherwise the exception will be printed.
    """

    vesselname = vesselinfo[longname]['vesselname']
    try:
        logdata = nmclient_signedsay(vesselinfo[longname]['handle'],"ReadVesselLog",
                                     vesselname)
    except NMClientException, e:
        return (False, str(e))
    else:
        return (True, logdata)


# alpers - main method for acquiring information for all vessels and running an
# application
# !!! hopefully this method will be adapted into the initialize method
def connect_to_emulab_beraber_instance(ip, port, program_name, argstring=program_name):
    """
    <Purpose>
      Big wrapper method that connects to a Beraber instance given ip:port and attempts
      to upload and run the given repy code.

    <Arguments>
      ip:
          The hostname where a Beraber instance is running (ip or full-qual name).
      port:
          The port at which a Beraber instance is running.
      program_name:
          The name of the repy file that will be executed.
      argstring:
          A string of arguments to pass to the repy code upon execution.

    <Exceptions>
      See exceptions for add_node_by_hostname and run_target.

    <Side Effects>
      Edits vesselinfo to keep track of state.

    <Returns>
      Nothing yet.
    """
    
    add_node_by_hostname(ip, port=port)
    
    fileobj = open(program_name, "r")
    filedata = fileobj.read()
    fileobj.close()
    
    retdict = {}
    for vessel in vesselinfo:
        retdict[vessel] = run_target(vessel, program_name, filedata, argstring)
        if retdict[vessel][0]:
            print "Successfully connected and run program on ", vessel
        else:
            print "Failed to connect/run program on ", vessel
            print "Reason: ", retdict[vessel][1]


# alpers - main method for retreiving the logs from each vessel
def get_logs_from_all_emulab_beraber_instances():
    retdict = {}
    logs = {}
    for vessel in vesselinfo:
        retdict[vessel] = showlog_vessel(vessel)
        if retdict[vessel][0]:
            print "Successfully connected to and acquired log from ", vessel
            logs[vessel] = retdict[vessel][1]
        else:
            print "Failed to connect to/acquire log from ", vessel
            print "Reason: ", retdict[vessel][1]

    return logs


# alpers - main method for stopping a vessel
def stop_all_emulab_beraber_instances():
    retdict = {}
    for vessel in vesselinfo:
        retdict[vessel] = stop_target(vessel)
        if retdict[vessel][0]:
            print "Successfully stopped execution on ", vessel
        else:
            print "Failed to stop execution on ", vessel
            print "Reason: ", retdict[vessel][1]



def query_vessel_state():
    """
    <Purpose>
      Attempts to acquire vessel state for each vessel in vesselinfo.

    <Arguments>
      None.

    <Exceptions>
      Should be none unless vesselinfo was instantiated incorrectly and has invalid 
      data.

    <Side Effects>
      None.

    <Returns>
      A dictionary of vessel longnames to status strings.
    """
    
    status_list = {}
    
    for longname in vesselinfo:
        retdict = nmclient_getvesseldict(vesselinfo[longname]['handle'])
        status_list[longname] = retdict['vessels'][vesselinfo[longname]['vesselname']]['status']
    
    return status_list


# alpers - query vessel state to see if vessels are finished executing
def all_emulab_vessels_done():
    """
    <Purpose>
      Runs query_vessel_state() to determine whether all vessels have finished executing
      repy code.

    <Arguments>
      None.

    <Exceptions>
      Should be none unless vesselinfo was instantiated incorrectly and has invalid 
      data.

    <Side Effects>
      None.

    <Returns>
      A boolean describing whether all vessels have finished executing repy code.
    """

    status = query_vessel_state()
    for vessel, status in status.iteritems():
        if status == 'Started':
            return False

    return True



log_lock = threading.Lock()
logs = {}
def append_log(host, log):
    log_lock.acquire()
    logs[host] = log
    log_lock.release()

def get_logs():
    return logs

# alpers - this is the function that should be called from the outside..
# !! this method will be deprecated.
def run_emulab_repy(ip, keyname, timeout, repy_file, repy_argstring=""):
    threading.Timer(0, __run_emulab_repy, [ip, keyname, timeout, repy_file, repy_argstring])
    

# private?
# !! this method will be deprecated.
def __run_emulab_repy(ip, keyname, timeout, repy_file, repy_argstring=""):
    key['public'] = rsa_file_to_publickey(keyname + ".publickey")
    key['private'] = rsa_file_to_privatekey(keyname + ".privatekey")

    if not repy_argstring == repy_file:
        repy_argstring = repy_file + " " + repy_argstring

    time_updatetime(34933)

    print "Connecting to ", ip, ":", DEFAULT_NODEMANAGER_PORT, "; looking for vessels.."
    connect_to_emulab_beraber_instance(ip, DEFAULT_NODEMANAGER_PORT, repy_file, 
                                       repy_argstring)

    num_checks = 10
    for i in range(num_checks):
        if i + 1 == num_checks:
            sleep_time = timeout/num_checks + timeout%num_checks
        else:
            sleep_time = timeout/num_checks

        sleep(sleep_time)
        print "slept for ", str(sleep_time), " seconds"
        
        if all_emulab_vessels_done():
            print "noticed that all execution is done before timeout hit"
            break

    if not all_emulab_vessels_done():
        print "! Force stopping all vessels (timeout hit)" 
        stop_all_emulab_beraber_instances()

    logs = get_logs_from_all_emulab_beraber_instances()
    print "Saving log to ", ip, ".log..."
    persist.commit_object(logs, ip+".log")

    append_log(ip, logs)
    
    print "Finished execution!"


# alpers - prints the usage of the application
def print_usage():
    print \
"""python install_autograder.py <keyname> <ip> <port> <program> [<args> ...]
    <keyname> - The name of the key files where the owner keys are stored,
                e.g. keyname.privatekey, keyname.publickey would submit 
                privatekey
    <ip>      - The host on which Beraber is running (can be full-qual name)
    <port>    - The port on the host on which the node manager is running
    <program> - repy code for the autograder vessels to run
    <args>    - Any arguments that the repy program may take
"""


# alpers - main starter thread 
# !! this method will be depreciated.
def main():
    if len(sys.argv) < 5:
        print_usage()
        return

    keyname = sys.argv[1]
    ip = sys.argv[2]
    try:
        port = int(sys.argv[3])
    except TypeError:
        print_usage()
        return
    program_name = sys.argv[4]

    repy_args = program_name + " "
    if len(sys.argv) > 5:
        repy_args += " ".join(sys.argv[5:])

    key['public'] = rsa_file_to_publickey(keyname + ".publickey")
    key['private'] = rsa_file_to_privatekey(keyname + ".privatekey")

    print "Connecting to ", ip, ":", port, "; looking for vessels.."
    connect_to_emulab_beraber_instance(ip, port, program_name, repy_args)

    sleep(10)

    logs = get_logs_from_all_emulab_beraber_instances()
    print "Saving log to ", ip, ".log..."
    persist.commit_object(logs, ip+".log")

    print "Finished execution!"

if __name__ == '__main__':
    time_updatetime(34933)
    main()

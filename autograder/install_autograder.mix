"""
<Program Name>
  install_autograder.py

<Author>
  Alper Sarikaya
  alpers@cs.washington.edu

<Purpose>

<Todo>

"""

import sys 
import nmAPI
import persist

from repyportability import *
include nmclient.repy

include rsa.repy

nextid = 1
key = {}
vesselinfo = {}

DEFAULT_NODEMANAGER_PORT = 1224

# alpers - adds a vessel and its information to the overall vessel dict
#          (from seash.mix)
def add_vessel(longname, vesselhandle):
    global nextid

    vesselinfo[longname] = {}
    vesselinfo[longname]['handle'] = vesselhandle
#    vesselinfo[longname]['keyname'] = keyname
    vesselinfo[longname]['IP'] = longname.split(':')[0]
    vesselinfo[longname]['port'] = int(longname.split(':')[1])
    vesselinfo[longname]['vesselname'] = longname.split(':')[2]
    

    myid = nextid
    nextid += 1
    
    return myid



# alpers - adds all vessels available at ip:port (adapted from seash.mix)
def add_node_by_hostname(host, port):
    # get information about the node's vessels
    thishandle = nmclient_createhandle(host, port, privatekey = key['private'], 
                                       publickey = key['public'])
    ownervessels, uservessels = nmclient_listaccessiblevessels(thishandle, 
                                                               key['public'])
    
    new_vessel_list = []
    
    # we should add anything we can access (we only care about ownervessels)
    for vesselname in ownervessels:
      longname = host+":"+str(port)+":"+vesselname
      if longname not in vesselinfo:
        # set the vesselname
        # NOTE: we leak handles (no cleanup of thishandle).   
        # I think we don't care...
        newhandle = nmclient_duplicatehandle(thishandle)
        handleinfo = nmclient_get_handle_info(newhandle)
        handleinfo['vesselname'] = vesselname
        nmclient_set_handle_info(newhandle, handleinfo)
        
        id = add_vessel(longname, newhandle)
        new_vessel_list.append('%'+str(id)+"("+longname+")")
        
        
    # tell the user what we did...
    if len(new_vessel_list) == 0:
        print "Could not add any targets."
    else:
        print "Added targets: "+", ".join(new_vessel_list)
    
    return new_vessel_list


# alpers - attempts to tell each vessel to run a program
def run_target(longname, filename, filedata, argstring):
  vesselname = vesselinfo[longname]['vesselname']
  # debug
  # print "vesselname", vesselname, ", longname: ", longname
  # print "filename: ", filename, ", argstring: ", argstring
  # print
  # print "handle: " + str(vesselinfo[longname]['handle'])
  # print "filedata: " + filedata
  try:
      nmclient_signedsay(vesselinfo[longname]['handle'], "AddFileToVessel", 
                         vesselname, filename, filedata)
  except NMClientException, e:
      return (False, str(e))

  print "Successfully added ", filename, " to vessel"

  try:
      nmclient_signedsay(vesselinfo[longname]['handle'], "StartVessel", 
                         vesselname, argstring)
  except NMClientException, e:
      return (False, str(e))
  else:
      print "Successfully started vessel with repy file"
      return (True,)


# alpers - attempts to stop a vessel from running a program
def stop_target(longname):
    vesselname = vesselinfo[longname]['vesselname']
    try:
        nmclient_signedsay(vesselinfo[longname]['handle'], "StopVessel", vesselname)
    except NMClientException, e:
        return (False, str(e))
    else:
        return (True,)


# alpers - attempts to retreive logs from each vessel
def showlog_vessel(longname):
  vesselname = vesselinfo[longname]['vesselname']
  try:
    logdata = nmclient_signedsay(vesselinfo[longname]['handle'],"ReadVesselLog",
                                 vesselname)
  except NMClientException, e:
    return (False, str(e))
  else:
    return (True, logdata)


# alpers - main method for acquiring information for all vessels and running an
# application
def connect_to_emulab_beraber_instance(ip, port, program_name, argstring):
    vessel_id_list = add_node_by_hostname(ip, port)
    
    fileobj = open(program_name, "r")
    filedata = fileobj.read()
    fileobj.close()
    
    retdict = {}
    for vessel in vesselinfo:
        retdict[vessel] = run_target(vessel, program_name, filedata, argstring)
        if retdict[vessel][0]:
            print "Successfully connected and run program on ", vessel
        else:
            print "Failed to connect/run program on ", vessel
            print "Reason: ", retdict[vessel][1]


# alpers - main method for retreiving the logs from each vessel
def get_logs_from_all_emulab_beraber_instances():
    retdict = {}
    logs = {}
    for vessel in vesselinfo:
        retdict[vessel] = showlog_vessel(vessel)
        if retdict[vessel][0]:
            print "Successfully connected to and acquired log from ", vessel
            logs[vessel] = retdict[vessel][1]
        else:
            print "Failed to connect to/acquire log from ", vessel
            print "Reason: ", retdict[vessel][1]

    return logs


# alpers - main method for stopping a vessel
def stop_all_emulab_beraber_instances():
    retdict = {}
    for vessel in vesselinfo:
        retdict[vessel] = stop_target(vessel)
        if retdict[vessel][0]:
            print "Successfully stopped execution on ", vessel
        else:
            print "Failed to stop execution on ", vessel
            print "Reason: ", retdict[vessel][1]


# alpers - query a vessel's state
def query_vessel_state():
    status_list = {}
    
    for longname in vesselinfo:
        retdict = nmclient_getvesseldict(vesselinfo[longname]['handle'])
        status_list[longname] = retdict['vessels'][vesselinfo[longname]['vesselname']]['status']
    
    return status_list


# alpers - query vessel state to see if vessels are finished executing
def all_emulab_vessels_done():
    status = query_vessel_state()
    for vessel, status in status.iteritems():
        if status == 'Started':
            return False

    return True



log_lock = threading.Lock()
logs = {}
def append_log(host, log):
    log_lock.acquire()
    logs[host] = log
    log_lock.release()

def get_logs():
    return logs

# alpers - this is the function that should be called from the outside..
def run_emulab_repy(ip, keyname, timeout, repy_file, repy_argstring=""):
    threading.Timer(0, __run_emulab_repy, [ip, keyname, timeout, repy_file, repy_argstring])
    

# private?
def __run_emulab_repy(ip, keyname, timeout, repy_file, repy_argstring=""):
    key['public'] = rsa_file_to_publickey(keyname + ".publickey")
    key['private'] = rsa_file_to_privatekey(keyname + ".privatekey")

    if not repy_argstring == repy_file:
        repy_argstring = repy_file + " " + repy_argstring

    time_updatetime(34933)

    print "Connecting to ", ip, ":", DEFAULT_NODEMANAGER_PORT, "; looking for vessels.."
    connect_to_emulab_beraber_instance(ip, DEFAULT_NODEMANAGER_PORT, repy_file, 
                                       repy_argstring)

    num_checks = 10
    for i in range(num_checks):
        if i + 1 == 10:
            sleep_time = timeout/num_checks + timeout%num_checks
        else:
            sleep_time = timeout/num_checks

        sleep(sleep_time)
        print "sleeping for ", str(sleep_time)
        
        if all_emulab_vessels_done():
            print "noticed that all execution is done before timeout hit"
            break

    logs = get_logs_from_all_emulab_beraber_instances()
    print "Saving log to ", ip, ".log..."
    persist.commit_object(logs, ip+".log")

    append_log(ip, logs)
    
    print "Finished execution!"


# alpers - prints the usage of the application
def print_usage():
    print \
"""python install_autograder.py <keyname> <ip> <port> <program> [<args> ...]
    <keyname> - The name of the key files where the owner keys are stored,
                e.g. keyname.privatekey, keyname.publickey would submit 
                privatekey
    <ip>      - The host on which Beraber is running (can be full-qual name)
    <port>    - The port on the host on which the node manager is running
    <program> - repy code for the autograder vessels to run
    <args>    - Any arguments that the repy program may take
"""


# alpers - main starter thread -- !! is there a way to see when an applcation has
#                                    finished running in a vessel?  (just sleeps 
#                                    for 30 sec now)
def main():
    if len(sys.argv) < 5:
        print_usage()
        return

    keyname = sys.argv[1]
    ip = sys.argv[2]
    try:
        port = int(sys.argv[3])
    except TypeError:
        print_usage()
        return
    program_name = sys.argv[4]

    repy_args = program_name + " "
    if len(sys.argv) > 5:
        repy_args += " ".join(sys.argv[5:])

    key['public'] = rsa_file_to_publickey(keyname + ".publickey")
    key['private'] = rsa_file_to_privatekey(keyname + ".privatekey")

    print "Connecting to ", ip, ":", port, "; looking for vessels.."
    connect_to_emulab_beraber_instance(ip, port, program_name, repy_args)

    sleep(10)

    logs = get_logs_from_all_emulab_beraber_instances()
    print "Saving log to ", ip, ".log..."
    persist.commit_object(logs, ip+".log")

    print "Finished execution!"

if __name__ == '__main__':
    time_updatetime(34933)
    main()

include StandardShims.repy

class TCP_TLayer(EmptyShim):
  # a default t-layer class
  # to use just inherit TCP_TLayer and define and innerclass T_socket
  # that implements the functionality you want  


  def waitforconn(self,id,port,callback):
    # call a the next_wait method, with our callback function
    self.previous_callback=callback #TODO do we need locking?
    next_comm_handle = self.shim_stack.waitforconn(id,port,self.this_callback)
    
    return (self.name,next_comm_handle)

  def stopcomm(self,handle):
  # t-layers generally won't have to do anything expect call the lower stopcomm
  # they can however override this method to add functionality
    (name,next_handle) = handle
    if self.name != name:
      raise Exception('Bad commhandle in layer '+self.name+' handlename: '+name)

    return self.shim_stack.stopcomm(next_handle)


  def this_callback(self,remote_ip,remote_port,socket,thiscommhandle,listencommhandle):
    # wrap the socket and return it to the previous callback
    new_socket = self.T_Socket(socket)
    self.previous_callback(remote_ip,remote_port,new_socket,thiscommhandle,listencommhandle)
  
  def openconn(self,id,port,localip=None,localport=None,timeout=5):
    # call the next openconn
    socket = self.shim_stack.openconn(id,port,localip,localport,timeout)
    new_socket = self.T_Socket(socket)
    return new_socket


  
    

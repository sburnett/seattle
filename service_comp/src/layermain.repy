"""
<Program Name>
  conn_framework.py

<Started>
  Jun 25, 2009

<Author>
  Eric Kimbrel

<Purpose>
  
  Prototype of a dynamic network stack framework.  Provides a top level 
  openconn and waitforconn that can be called by users.

  This is a working prototype NOT MEANT FOR DISTRIBUTION OR PRODUCTION

  Also see comments on the shim stack object below.
  see StandardShims for examples of how to write shims.


"""


# to allow for advertisement and lookups, used by coordination shim
include lookup_methods.repy


# mapping of comm handles to the associated object
# used to implement layered_stopcomm
COMM_HANDLE_DICT = {'next_handle_id':0,'lock':getlock()} 


# a dictionary to store refrences to each layers class
_LAYERMAIN_LAYER_DICT = {}


### REGISTRATION USED FOR LAYERS TO REGISTER WITH THE FRAMEWORK  ###


def layermain_reg_layer(layer_name,layer_info_dict):
  """
  <Purpose>
    Allows layers to register their information inside of the service
    comp framework

  <Arguments>
    layer_name:
      the name of the layer being registered

    layer_info_dict:
      a dictionary of the form {'class':LayerClass,'type':'LayerType'}

  <Exceptions>
    Exception if a previously registered name is registered

  <Side Effects>
     None

  <Returns>
    None
  """

  # provides a way for T_layers to register themselves with the framework
  if layer_name in _LAYERMAIN_LAYER_DICT:
    raise Exception('Attempt to register previously existing h-layer' +str(layer_name_))
  _LAYERMAIN_LAYER_DICT[layer_name] = layer_info_dict




###  Top level calls used by users to use service comp   ###

def layered_openconn(host,port,localip=None,localport=None,timeout=5):
  #instantiates a shim stack and calls openconn

  # get a new shim_stack  
  shim_stack = ShimStack(DEFAULT_SHIM_STACK_NAMES)
  return shim_stack.openconn(host,port,localip,localport,timeout)


def layered_sendmess(host,port,message,localhost=None,localport=None):
  # instanties a shim stack and calls sendmess
  
  shim_stack = ShimStack(DEFAULT_SHIM_STACK_NAMES)
  return shim_stack.sendmess(host,port,message,localhost,localport)


def layered_waitforconn(host,port,callback):
  """
  <Purpose>
   Performs a service compostion waitforconn

  <Arguments>
    host: A string that is a unique id for the server
    
    for others see waitforconn

  <Exceptions>
    see waitforconn

  <Side Effects>
     None

  <Returns>
    a commhandle that can be used with layered_stopcomm
  """  
  
  # instantiate the defaulte layer stack
  shim_stack = ShimStack(DEFAULT_SHIM_STACK_NAMES)

  # do the waitforconn
  handle = shim_stack.waitforconn(host,port,callback)

  # map the handle to the correct stopcomm function
  COMM_HANDLE_DICT['lock'].acquire()
  handle_id = COMM_HANDLE_DICT['next_handle_id']
  COMM_HANDLE_DICT['next_handle_id'] = handle_id + 1
  COMM_HANDLE_DICT[handle_id] = shim_stack.stopcomm
  COMM_HANDLE_DICT['lock'].release()

  # return the handle
  return (handle_id,handle)






def layered_recvmess(host,port,callback):
  # instantiates a default shim stack
  # and calls recvmess

  shim_stack = ShimStack(DEFAULT_SHIM_STACK_NAMES)
  handle = shim_stack.recvmess(host,port,callback)

  # map the handle to the correct stopcomm function
  COMM_HANDLE_DICT['lock'].acquire()
  handle_id = COMM_HANDLE_DICT['next_handle_id']
  COMM_HANDLE_DICT['next_handle_id'] = handle_id + 1
  COMM_HANDLE_DICT[handle_id] = shim_stack.stopcomm
  COMM_HANDLE_DICT['lock'].release()

  return (handle_id,handle)






def layered_stopcomm(handle):
  """
  <Purpose>
    stops a listener returned by a layered_waitforconn

  <Arguments>
    handle:
      a commhandle returned by layered_waitforconn

    
  <Exceptions>
    None

  <Side Effects>
     None

  <Returns>
    True if success, otherwise False
  """
  # un-pack the handle
  (handle_id,handle) = handle
  
  try:
    # get the stopcomm from the correct object  
    COMM_HANDLE_DICT['lock'].acquire()
    current_stopcomm = COMM_HANDLE_DICT[handle_id]
    del COMM_HANDLE_DICT[handle_id]  
    COMM_HANDLE_DICT['lock'].release()
  except Exception:
    COMM_HANDLE_DICT['lock'].release()
    return False
    
  # do the stop comm
  return current_stopcomm(handle)

  
 

def getmykey():
  # not implemnted, raise an exception if i call it to remind me
  raise Exception('GET MY KEY IS NOT IMPLEMENTED')




def _layermain_make_stack(shim_stack_str):
  # private method used only by the ShimStack constructor

  # takes a string of the form '(a)(b,c,d)'
  # the first item in each (..) is the name of the shim
  # following items are optional args that will be understood
  # by the shims constructor  


  temp_str = shim_stack_str.replace('(','')
  stack_list = temp_str.split(')')
  del stack_list[len(stack_list)-1]

  
  # make objects for each layer in the list
  top = None # the top of this stack
  previous = None
  for comma_seperated_str in stack_list:
    
    shim_list = comma_seperated_str.split(',')
    
    shim_name = shim_list[0]
    

    shim_args = shim_list[1:]
    if len(shim_args) == 0:
      shim_args = None

    
    
    # first arguemnt is always for the next shim, second argument is optional args
    new_shim = _LAYERMAIN_LAYER_DICT[shim_name]['class'](None,shim_args)
    
    if top == None: top = new_shim
    
    if previous !=None:
      # link in the shim stack to the above shim
      previous.shim_stack.top_shim = new_shim
    
    previous = new_shim

  return top 

  




class ShimStack:
# Each Shim stack implements the networking API
# Each shim has a reference to the ShimStack beneath it

# a Shim stack string (for the constructor) is of the form
# (LayerName,arg1,arg2,arg3,...)(..)....
# The first item in a () is the name of the Shim to be instantiated,
# each following item is convered to a list of strings and passed to
# the Shim constructor as optional_args


  def __init__(self,shim_stack_string=None):
    # create a new shim stack
    if shim_stack_string != None: 
      self.top_shim = _layermain_make_stack(shim_stack_string)
    else:
      self.top_shim = None
  
  def push(self,shim):
    # give the new shim a shim stack that is the same as this one
    shim.shim_stack = ShimStack()
    shim.shim_stack.stop_shim = self.top_shim
    
    # change this shim stack to include the new shim
    self.top_shim = shim
      

  def pop(self):
    # remove and return the top shim
    shim = self.top_shim
    self.top_shim = self.top.shim_stack.top
    shim.shim_stack = None 
    return shim

  def get_names(self):
    # return a list of names that can be used to create compatible 
    # shim stacks
    return self.top_shim.get_names()


  def waitforconn(self,host,port,callback):
    return self.top_shim.waitforconn(host,port,callback)

  def recvmess(self,host,port,callback):
    return self.top_shim.recvmess(host,port,callback)

  def openconn(self,host,port,localhost=None,localport=None,timeout=5):
    return self.top_shim.openconn(host,port,localhost,localport)

  def sendmess(self,host,port,msg,localhost=None,localport=None):
    return self.top_shim.sendmess(host,port,msg,localhost,localport)

  def stopcomm(self,handle):
    return self.top_shim.stopcomm(handle)
  










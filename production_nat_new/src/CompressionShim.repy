"""
A shim that compresses and decompresses data created for the purpose of the
SIGCOMM '11 paper. 

The UDP portion is fully functional and has been extensively tested.

The semantics are not preserved for the TCP portion of this shim. The send()
method guarantees to send all the input data as a compressed string, and this
operation may only be invoked once. Subsequent calls of the send() method will
potentially invalidate the CRC of the compression. I am not using a stream
compressor here, because it involves complex book-keepings of the lengths of
various buffers. For the same reason, the recv() method receives and
decompresses all the data into an internal queue when it is invoked for the
first time. Subsequent calls of this operation will return data from this queue.

For instance, the following piece of program will work with this shim:

  include ShimStackInterface.mix

  shim_str = '(CompressionShim)'

  server = ShimStackInterface(stack_str=shim_str)
  client = ShimStackInterface(stack_str=shim_str)

  ip = getmyip()
  port = 41264


  def main():

      handle = server.waitforconn(ip, port, new_msg)

      data = "some data to send"
      sock = client.openconn(ip, port)
      while data:
          # The following method actually sends all the data, so socket.send() 
          # won't be called again.
          sent = sock.send(data)
          s = s[sent:]

      sock.close()



  def new_msg(remoteip, remoteport, sock, thiscommhandle, listencommhandle):

      msg = ''

      while True:
          buf = sock.recv(128)
          msg += buf
          if len(s) < 128:
              sock.close()
              break

      print msg

As future work, we should fix the problems above to turn this into a real shim.

Written by: Danny Y. Huang (yh1@williams.edu)


"""
import zlib



class CompressionShim(BaseShim):

  def __init__(self, next_shim=None, optional_args=None):

    BaseShim.__init__(self, next_shim, optional_args)
    self._logger = ShimLogger('CompressionShim')

    # A dictionary that maps a socket to its receive queue, a string which
    # temporarily holds received TCP stream that has been decompressed.
    self._recv_dict = {}

    # Lock to guard the receive stream queue
    self._recv_lock = getlock()
    



  # ..................................................
  # TCP
  # ..................................................


  def _shim_socket_send(self, socket, longmsg):
    """
    Compresses stream and sends the entire message, guaranteed. Returns the
    length of the original message. For the purpose of the SIGCOMM paper, this
    method cannot be invoked more than once, or else the CRC of the compression
    will be invalidated.

    """
    # Compress the entire message
    shortmsg = zlib.compress(longmsg)

    # Send the entire short message
    while shortmsg:
      sent_length = self.shim_stack.socket_send(socket, shortmsg)
      shortmsg = shortmsg[sent_length : ]

    return len(longmsg)
                                       




  def _shim_socket_recv(self, socket, bytes): 
    """ 
    Receives and decompresses stream as much as possible. Since the decompressed
    stream is long than the number of bytes requested, we temporarily hold it
    into a queue and return only the requested length.

    """
   
    try:

      # To maintain the consistency of the receive queue, we do not allow much
      # concurrency here. 
      self._recv_lock.acquire()

      # Create an entry in the dictionary that maps this socket to the receive
      # queue and decompressor.
      if not str(socket) in self._recv_dict:
        self._recv_dict[str(socket)] = ''

      recv_queue = self._recv_dict[str(socket)]

      # Read as much as possible from network only if we have an empty receive queue
      if len(recv_queue) == 0:

        shortmsg = ''
        while True:
          buf = self.shim_stack.socket_recv(socket, 128)
          shortmsg += buf
          if len(buf) < 128:
            break

        longmsg = zlib.decompress(shortmsg)

      # Otherwise, nothing to read from network.
      else:
        longmsg = ''

      # Stick the decompressed content into the queue, regardless of its length.
      recv_queue += longmsg

      # Remove the extracted portion from the queue
      self._recv_dict[str(socket)] = recv_queue[bytes : ]

      # Return only the requested length from the queue.
      return recv_queue[0 : bytes]

    finally:
      self._recv_lock.release()






  def copy(self):
    return CompressionShim()


  def get_advertisement_string(self):
    return '(CompressionShim)' + self.shim_stack.get_advertisement_string()







  # ..................................................
  # UDP
  # ..................................................

  def sendmess(self,host,port,longmsg,localhost=None,localport=None):
    shortmsg = zlib.compress(longmsg, 9)
    shortlength = self.shim_stack.sendmess(host,port,shortmsg,localhost,localport)

    if shortlength == len(shortmsg):
      return len(longmsg)
    else:
      return 0


  def recvmess(self,host,port,callback):

    # Inline closure to avoid race conditions
    def recvmess_callback(rip,rport,longmsg,handle):
      shortmsg = zlib.decompress(longmsg)
      callback(rip, rport, shortmsg, handle)

    return self.shim_stack.recvmess(host, port, recvmess_callback)


"""
Compression and decompression shim for both TCP and UDP.

Written by: Danny Y. Huang (yh1@williams.edu)

"""
import zlib


class CompressionShim(BaseShim):

  def __init__(self, next_shim=None, optional_args=None):

    BaseShim.__init__(self, next_shim, optional_args)
    self._logger = ShimLogger('CompressionShim')

    # A dictionary that maps a socket to its receive buffer, a string which
    # temporarily holds received TCP stream that has been decompressed.
    self._recv_buffer_dict = {}

    # Lock to guard the receive stream queue
    self._recv_lock = getlock()
    



  # ..................................................
  # TCP
  # ..................................................


  def _shim_socket_send(self, socket, long_chunk):
    """
    Compresses the original chunk and sends it in its entirety, guaranteed. The
    compressed chunk is prepended with with its length and a comma.

    """
    # Compress the entire message
    short_chunk = zlib.compress(long_chunk)

    # Prepend a header to the short chunk
    short_chunk = str(len(short_chunk)) + ',' + short_chunk

    # Send the entire short chunk
    while short_chunk:
      sent_length = self.shim_stack.socket_send(socket, short_chunk)
      short_chunk = short_chunk[sent_length : ]

    return len(long_chunk)
                                       


  def _get_next_chunk(self, socket):
    """
    Helper method for _shim_socket_recv. Receives as much as possible until
    encountering the first comma. The value before the comma is the length we
    should read next. We then read the subsequent trunk of the given
    length. Finally, we decompress the trunk and returrn it as a string.

    """
    trunk = ''
    trunk_header = ''
    char = ''

    # Read one character at a time until comma.
    while char != ',':
      trunk_header += char
      char = self.shim_stack.socket_recv(socket, 1)

    # Parse the header and obtain the length of the trunk.
    remaining_length = int(trunk_header)

    # Read up to trunk_length, up to 1024 bytes at a time
    while remaining_length > 0:

      if remaining_length >= 1024:
        to_read = 1024
      else:
        to_read = remaining_length

      data = self.shim_stack.socket_recv(socket, to_read)
      remaining_length -= len(data)
      trunk += data

    # Decompress trunk and return it
    return zlib.decompress(trunk)



  def _shim_socket_recv(self, socket, bytes): 
    """ 
    Reads the next trunk and sticks it into the receive buffer until the receive
    buffer is at least 'bytes' long, or the socket is closed. If the receive
    buffer is still empty, we know that nothing has been read and we raise an
    Exception that the socket has been closed.

    """
    try:
      self._recv_lock.acquire()

      # Initialize the receive buffer if not already done so.
      if str(socket) not in self._recv_buffer_dict:
        self._recv_buffer_dict[str(socket)] = ''
      recv_buf = self._recv_buffer_dict[str(socket)]

      # Keep reading the next trunk into the receive buffer, until the receive
      # buffer has at least the requested number of bytes, or until we get a
      # socket-closed exception.
      while len(recv_buf) < bytes:
        try:
          recv_buf += self._get_next_chunk(socket)
        except Exception, err:
          if 'Socket closed' in str(err):
            break
          else:
            raise Exception(err)

      # If the receive buffer is still empty, we haven't read anything from the
      # network. Apparently, the application has read more than it should. We
      # raise an exception.
      if len(recv_buf) == 0:
        raise Exception("Socket closed")

      # Return up to bytes from the receive buffer
      ret_msg = recv_buf[0:bytes]
      self._recv_buffer_dict[str(socket)] = recv_buf[bytes:]
      return ret_msg

    finally:
      self._recv_lock.release()



  def copy(self):
    return CompressionShim()


  def get_advertisement_string(self):
    return '(CompressionShim)' + self.shim_stack.get_advertisement_string()







  # ..................................................
  # UDP
  # ..................................................

  def sendmess(self,host,port,longmsg,localhost=None,localport=None):
    shortmsg = zlib.compress(longmsg, 9)
    shortlength = self.shim_stack.sendmess(host,port,shortmsg,localhost,localport)

    if shortlength == len(shortmsg):
      return len(longmsg)
    else:
      return 0


  def recvmess(self,host,port,callback):

    # Inline closure to avoid race conditions
    def recvmess_callback(rip,rport,longmsg,handle):
      shortmsg = zlib.decompress(longmsg)
      callback(rip, rport, shortmsg, handle)

    return self.shim_stack.recvmess(host, port, recvmess_callback)


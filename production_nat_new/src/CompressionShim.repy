"""
Compression and decompression shim for both TCP and UDP.

Written by: Danny Y. Huang (yh1@williams.edu)

"""
import zlib

# How many bytes should we receive every time we call socket.recv
RECV_BUFFER_SIZE = 1024

class CompressionShim(BaseShim):

  def __init__(self, next_shim=None, optional_args=None):

    BaseShim.__init__(self, next_shim, optional_args)
    self._logger = ShimLogger('CompressionShim')

    # A dictionary that maps a socket to its receive buffer, a string which
    # temporarily holds received TCP stream that has been decompressed.
    self._recv_buffer_dict = {}

    # Lock to guard the receive stream queue
    self._recv_lock = getlock()
    
    # The extra byte read when we called _get_next_chunk() the previous
    # time. See the _get_next_chunk() method for why we need to read one extra
    # byte.
    self._recv_previous_extra_byte_dict = {}


  # ..................................................
  # TCP
  # ..................................................


  def _shim_socket_send(self, socket, long_chunk):
    """
    Compresses the original chunk and sends it in its entirety, guaranteed. The
    compressed chunk is prepended with with its length and a comma.

    """
    # Compress the entire message
    short_chunk = zlib.compress(long_chunk)

    # Prepend a header to the short chunk
    short_chunk = str(len(short_chunk)) + ',' + short_chunk

    # Send the entire short chunk
    while short_chunk:
      sent_length = self.shim_stack.socket_send(socket, short_chunk)
      short_chunk = short_chunk[sent_length : ]

    return len(long_chunk)
                                       


  def _get_next_chunk(self, socket):
    """
    Helper method for _shim_socket_recv. Receives as much as possible until
    encountering the first comma. The value before the comma is the length we
    should read next. We then read the subsequent chunk of the given
    length. Finally, we decompress the chunk and returrn it as a string.

    This method returns a tuple (chunk, next_chunk_available), where chunk is a
    decompressed string, and next_chunk_available indicates if there is another
    chunk that follows the current one.

    """
    chunk = ''
    chunk_header = ''

    # Whether the current chunk is followed by another one.
    next_chunk_available = True

    # We initialize char as the extra byte we obtained when we called this
    # method the last time. If this is the first invocation, we set char as an
    # empty character.
    if str(socket) not in self._recv_previous_extra_byte_dict:
      self._recv_previous_extra_byte_dict[str(socket)] = ''
    char = self._recv_previous_extra_byte_dict[str(socket)]

    # Read one character at a time until comma.
    while char != ',':
      chunk_header += char
      char = self.shim_stack.socket_recv(socket, 1)

    # Parse the header and obtain the length of the chunk.
    remaining_length = int(chunk_header)

    # Read up to chunk_length, up to RECV_BUFFER_SIZE bytes at a time
    while remaining_length > 0:

      if remaining_length >= RECV_BUFFER_SIZE:

        # We are reading exactly the RECV_BUFFER_SIZE
        data = self.shim_stack.socket_recv(socket, RECV_BUFFER_SIZE)

      else:

        # We read one more byte past the end of the chunk
        data = self.shim_stack.socket_recv(socket, remaining_length + 1)

        # If we can successfully read this extra byte, there is still something
        # to receive. We will store this extra byte into the dictionary.
        if len(data) == remaining_length + 1:
          self._recv_previous_extra_byte_dict[str(socket)] = data[len(data) - 1]
          data = data[0 : len(data) - 1]

        # Otherwise, there aren't any chunks that follow the current one.
        else:
          next_chunk_available = False
          
      # end-if remaining_length

      remaining_length -= len(data)
      chunk += data

    # end-while

    # Decompress chunk and return it
    return (zlib.decompress(chunk), next_chunk_available)



  def _shim_socket_recv(self, socket, bytes): 
    """ 
    Reads the next trunk and sticks it into the receive buffer until the receive
    buffer is at least 'bytes' long, or the socket is closed. If the receive
    buffer is still empty, we know that nothing has been read and we raise an
    Exception that the socket has been closed.

    """
    try:
      self._recv_lock.acquire()

      # Initialize the receive buffer if not already done so.
      if str(socket) not in self._recv_buffer_dict:
        self._recv_buffer_dict[str(socket)] = ''
      recv_buf = self._recv_buffer_dict[str(socket)]

      # Whether there are more chunks to read
      next_chunk_available = True

      # Keep reading the next trunk into the receive buffer, until the receive
      # buffer has at least the requested number of bytes, or until we get a
      # socket-closed exception, or there are no more chunks to read.
      while len(recv_buf) < bytes and next_chunk_available:
        try:
          (data, next_chunk_available) = self._get_next_chunk(socket)
          recv_buf += data
        
        except Exception, err:
          if 'Socket closed' in str(err):
            break
          else:
            raise Exception(err)

      # If the receive buffer is still empty, we haven't read anything from the
      # network. Apparently, the application has read more than it should. We
      # raise an exception.
      if len(recv_buf) == 0:
        raise Exception("Socket closed")

      # Return up to bytes from the receive buffer
      ret_msg = recv_buf[0:bytes]
      self._recv_buffer_dict[str(socket)] = recv_buf[len(ret_msg):]
      return ret_msg

    finally:
      self._recv_lock.release()



  def copy(self):
    return CompressionShim()


  def get_advertisement_string(self):
    return '(CompressionShim)' + self.shim_stack.get_advertisement_string()







  # ..................................................
  # UDP
  # ..................................................

  def sendmess(self,host,port,longmsg,localhost=None,localport=None):
    shortmsg = zlib.compress(longmsg, 9)
    shortlength = self.shim_stack.sendmess(host,port,shortmsg,localhost,localport)

    if shortlength == len(shortmsg):
      return len(longmsg)
    else:
      return 0


  def recvmess(self,host,port,callback):

    # Inline closure to avoid race conditions
    def recvmess_callback(rip,rport,longmsg,handle):
      try:
        shortmsg = zlib.decompress(longmsg)

      except zlib.error, err:
        # Unable to decompress. Bad packet. We drop it.
        return

      callback(rip, rport, shortmsg, handle)

    return self.shim_stack.recvmess(host, port, recvmess_callback)


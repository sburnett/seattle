#include local_lookup_methods.repy
include advertise.repy

# Caches the lookup results from the DHT. For use in openconn.
local_lookup_cache = {}

# TODO For TCP-based connections only. Coordinating for UDP won't be that hard
# once this is done.
class CoordinationShim(BaseShim):

  name = 'CoordinationShim'

  # We will do a lookup on the DHT for at most the following number of times.
  _lookup_attempts = 4

  # Number of seconds to re-advertise the shim stack to refresh DHT
  _advertise_wait_interval = 60

  # Override
  def copy(self):
    return CoordinationShim()

  def __init__(self, next_shim=None, optional_args=None):
    BaseShim.__init__(self, next_shim, optional_args)

  def get_advertisement_string(self):
    return '(CoordinationShim)' + self.shim_stack.get_advertisement_string()


  # ===========================================================================
  # SERVER METHODS
  # ===========================================================================

  def _coord_waitforconn_callback_wrapper(self, remoteip, remoteport, socket, thiscommhandle, listencommhandle):
    # Copy the current shim stack
    shimstack = self.shim_stack
    socketptr = socket
    while (shimstack.top_shim is not None) and isinstance(socketptr, ShimSocketWrapper):
      socketptr._shim = shimstack.top_shim.copy()
      socketptr = socketptr._socket
      shimstack = shimstack.top_shim.shim_stack

    self._coord_waitforconn_callback(remoteip, remoteport, socket, thiscommhandle, listencommhandle)



  def _shim_waitforconn(self, hostkey, port, callback):

    # Save the callback for later use
    self._coord_waitforconn_callback = callback

    # Traverse through the stack and build the general stack, which is shared
    # for all incoming connections.
    handle = self.shim_stack.waitforconn(hostkey, port, self._coord_waitforconn_callback_wrapper)

    # Now that the stack has been built, we can advertise its content.
    advertise_key = str(hostkey) + "," + str(port) + ",TCP"
    advertise_value = self.shim_stack.get_advertisement_string()
    self._listener_active = True
    
    # We advertise the contents of the shim stack at its first creation.
    # Subsequent changes are on a per-connection basis (using negotiation) and
    # are irrelevant for coordination.
    settimer(0, self._advertise_thread, [advertise_key, advertise_value])

    return handle


  def _advertise_thread(self, advertise_key, advertise_value):
    while self._listener_active:
      try:
        for shim_stack_str in self._expand_shim_stack_str(advertise_value):
          advertise_announce(advertise_key, shim_stack_str, 120)
      except Exception, e:
        # Silently drops all errors because the advertisement service can be
        # flaky at times
        pass

      sleep(self._advertise_wait_interval)


  def _expand_shim_stack_str(self, stack_str):
    retlist = []

    # Find the branch statement, which is enclosed in a pair of square
    # brackets. The statement consists of a series of shim names separated by
    # the or-operator "||". An example of a brach statement is
    # "[(ShimA)||(ShimB)||]". It means that the shim can be ShimA, ShimB, or
    # no-op.
    left_bracket_pos = stack_str.find('[')
    right_bracket_pos = stack_str.find(']')

    if right_bracket_pos > left_bracket_pos > 0:
      branch_statement = stack_str[left_bracket_pos + 1 : right_bracket_pos]
      shim_list = branch_statement.split('||')

      for shim in shim_list:
        new_stack_str = stack_str.replace('[%s]' % branch_statement, shim)
        retlist.append(new_stack_str)

    else:
      retlist.append(stack_str)

    return retlist





  # ===========================================================================
  # NON-SERVER METHODS
  # ===========================================================================


  # Uses a lookup service to coordinate the construction of the client shim
  # stack. Returns a list of available shim stack string representations. If
  # use_cache is set to True, then we are only doing a lookup on a local
  # cache. Otherwise, we will do a lookup remotely and any local cache
  # associated with the same key will be overwritten.
  def _get_shimstack_strings(self, hostkey, port, use_cache=True):
    lookup_results = []
    lookup_key = str(hostkey)+','+str(port)+',TCP'

    # Search the cache if use_cache is True. If cache returns empty, use the
    # remote lookup service.
    if use_cache and local_lookup_cache.has_key(lookup_key):
      lookup_results = local_lookup_cache[lookup_key]
      if lookup_results:
        return lookup_results[:]

    # Contact the remote lookup service
    for count in range(self._lookup_attempts):
      lookup_results = advertise_lookup(lookup_key)
      if len(lookup_results) > 0:
        break
      sleep(1)

    # Remove duplicates or else we would be trying the same non-working shim
    # stacks multiple times.
    self._remove_duplicates(lookup_results)

    # Add to local cache.
    local_lookup_cache[lookup_key] = lookup_results
    return lookup_results[:]


  def _shim_openconn(self, hostkey, port, localhost=None, localport=None, timeout=5):

    exception_list = ''
    sock = None

    # TODO Get all shims in the current stack (below the coordintor), including those
    # marked as do_not_advertise. We want to preserve the original shim stack,
    # and adding new ones to the bottom. 
    existing_shim_stack = "" # TODO

    # Indicates whether we have tried using the remote lookup services
    # (e.g. DHT) to locate the shim stack strings of the server.
    tried_using_remote_lookup = False

    # First, obtain the shim stack string from cache, or if not, from the DHT.
    shimstackstr_list = self._get_shimstack_strings(hostkey, port)

    # Try to do openconn for every possible shim stack string
    while len(shimstackstr_list) > 0:

      shimstackstr = shimstackstr_list.pop()
      port_num = port

      # Extract the port number if the stack string contains "{port_num}"
      left_curly_braces = shimstackstr.find('{')
      right_curly_braces = shimstackstr.find('}')
      if right_curly_braces > left_curly_braces > 0:
        port_num = int(shimstackstr[left_curly_braces+1 : right_curly_braces])
        shimstackstr = shimstackstr[:left_curly_braces]+shimstackstr[right_curly_braces+1:]

      # Append the new shims to the back of the existing stack
      shim_stack = ShimStack(existing_shim_stack + shimstackstr)

      try:
        sock = shim_stack.openconn(hostkey,port_num,localhost,localport,timeout)

      except ShimExceptionStackRejected, e:
        # It is possible that some of my shims below me don't like this stack,
        # so they raise this exception. We drop the exception and keep trying
        # other shim stacks.
        pass

      except Exception,e:
        exception_list +=' Exception: '+str(e)+' for stack '+shimstackstr

      else:
        # Success in openconn. We won't try the rest of the shimstack strings.
        break

      if len(shimstackstr_list) == 0 and not tried_using_remote_lookup:
        # All possible shim stack strings are consumed and we still haven't
        # found a workable one. We want to lookup the shim stack strings using
        # the remote services, instead of the local cache.
        shimstackstr_list = self._get_shimstack_strings(hostkey, port, use_cache=False)
        tried_using_remote_lookup = True

      if len(shimstackstr_list) == 0 and tried_using_remote_lookup:      
        # All possible shim stack strings are consumed. We haven't found a
        # workable one after lookups on both the local cache and the remote
        # services. We raise our arms and shall surrender.
        break

    # end while

    # If all things fail, we will connect without the shim interface. This
    # provides backward compatibility for older servers.
    if sock is None:
      print "DEBUG: Trying to connect without using the shim interface."
      try:
        sock = openconn(hostkey,port_num,localhost,localport,timeout)
      except Exception,e:
        exception_list +=' Exception: '+str(e)+' for stack '+result

    # At this point, we've exhausted all our means.
    if sock is None:
      # TODO raise correct type of exception
      raise Exception(exception_list)
    else:
      self.shim_stack = shim_stack
      return sock






  def _shim_stopcomm(self, handle):
    self._listener_active = False
    return self.shim_stack.stopcomm(handle)


  # Remove the duplicates in the input list. The input list is modified.
  def _remove_duplicates(self, inlist):
    listindex = 0

    while listindex < len(inlist):
      # If the current item appears in the rest of the list, remove it.
      currentitem = inlist[listindex]
      if currentitem in inlist[listindex+1:]:
        del inlist[listindex]
      else:
        listindex += 1


      

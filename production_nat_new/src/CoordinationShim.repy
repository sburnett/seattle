include local_lookup_methods.repy


# TODO For TCP-based connections only. Coordinating for UDP won't be that hard
# once this is done.
class CoordinationShim(BaseShim):


  name = 'CoordinationShim'

  # We will do a lookup on the DHT for at most the following number of times.
  _lookup_attempts = 4

  # Number of seconds to re-advertise the shim stack to refresh DHT
  _advertise_wait_interval = 600


  def __init__(self, next_shim=None, optional_args=None):
    BaseShim.__init__(self, next_shim, optional_args)

    # Never advertise the coordination shim
    self.do_not_advertise = True

 


  # ===========================================================================
  # SERVER METHODS
  # ===========================================================================

  def _coord_waitforconn_callback_wrapper(self, remoteip, remoteport, socket, thiscommhandle, listencommhandle):
    # TODO Comment. Crucial.
    shimstack = ShimStack(self.shim_stack.get_shims(True))
    socketptr = socket
    while shimstack.top_shim is not None:
      socketptr._shim = shimstack.top_shim
      socketptr = socketptr._socket
      shimstack = shimstack.top_shim.shim_stack

    self._coord_waitforconn_callback(remoteip, remoteport, socket, thiscommhandle, listencommhandle)



  def _shim_waitforconn(self, hostkey, port, callback):

    # Save the callback for later use
    self._coord_waitforconn_callback = callback

    # Traverse through the stack and build the general stack, which is shared
    # for all incoming connections.
    handle = self.shim_stack.waitforconn(hostkey, port, self._coord_waitforconn_callback_wrapper)

    # Now that the stack has been built, we can advertise its content.
    advertise_key = str(hostkey) + "," + str(port) + ",TCP"
    advertise_value = self.shim_stack.get_shims()
    self._listener_active = True
    
    # We advertise the contents of the shim stack at its first creation.
    # Subsequent changes are on a per-connection basis (using negotiation) and
    # are irrelevant for coordination.
    settimer(0, self._advertise_thread, [advertise_key, advertise_value])

    return handle


  def _advertise_thread(self, advertise_key, advertise_value):
    while self._listener_active:
      try:
        external_advertise(advertise_key, advertise_value)
      except Exception, e:
        print "CoordinationShim: Advertise error."

      sleep(self._advertise_wait_interval)




  # ===========================================================================
  # SOCKET-BASED METHODS. Each implements its own shim stack.
  # ===========================================================================


  def _shim_socket_close(self, socket):
    return self.shim_stack.socket_close(socket)



  def _shim_socket_send(self, socket, msg):
    return self.shim_stack.socket_send(socket, msg)



  def _shim_socket_recv(self, socket, bytes): 
    return self.shim_stack.socket_recv(socket, bytes)
  







  # ===========================================================================
  # NON-SERVER METHODS
  # ===========================================================================


  def _shim_openconn(self, hostkey, port, localhost=None, localport=None, timeout=5):

    # use a lookup service to coordinate the shim stack
    lookup_results = []
    for count in range(self._lookup_attempts):
      lookup_results = external_lookup(str(hostkey)+','+str(port)+',TCP')
      if len(lookup_results) > 0:
        break
      sleep(1)

    if len(lookup_results) < 1:
      raise Exception("host could not be found by coordiantion layer")

    exception_list = ''
    sock = None
    shim_stack = None

    # Get all shims in the current stack (below the coordintor), including those
    # marked as do_not_advertise. We want to preserve the original shim stack,
    # and adding new ones to the bottom. 
    existing_shim_stack = self.shim_stack.get_shims(True) 

    # TODO The first lookup_result is always the latest. What if the latest
    # result is not really the latest? For each key in the DHT, the values are
    # added sequentially and there may be duplicates. Should we assign a session
    # id to avoid such duplicates? Right now there is no need in our ideal
    # experimental environment.
    for result in lookup_results:
      
      # Append the new shims to the back of the existing stack
      shim_stack = ShimStack(existing_shim_stack + result)

      try:
        sock = shim_stack.openconn(hostkey,port,localhost,localport,timeout)
      except Exception,e:
        exception_list +=' Exception: '+str(e)+' for stack '+result
      else:
        break

    if sock is None:
      # TODO raise correct type of exception
      raise Exception(exception_list)
    else:
      self.shim_stack = shim_stack
      return sock





  def _shim_stopcomm(self, handle):
    self._listener_active = False
    return self.shim_stack.stopcomm(handle)



    




shimstack_reg_layer('CoordinationShim', {'class':CoordinationShim})

"""
<Program>
  CoordinationShim.repy

<Author>
  Danny Huang, Yuxing.Huang@williams.edu
  Monzur Muhammad, monzum@cs.washington.edu

<Purpose>
  To coordinate the shims. Transfer the hostname of local machines
  as well to announce all the shims that are being used.
"""

#include local_lookup_methods.repy
include advertise.repy
include session.repy


# TODO For TCP-based connections only. Coordinating for UDP won't be that hard
# once this is done.
class CoordinationShim(BaseShim):

  name = 'CoordinationShim'
  
  # When we first establish a TCP connection, the client sends over its 
  # hostname as the first message. This message has a special header 
  # character. We define the character here.
  hostname_header = "hostname@@@"
  UDP_tag = ":::UDP_TAG:::"  


  # We will do a lookup on the DHT for at most the following number of times.
  _lookup_attempts = 4

  # Number of seconds to re-advertise the shim stack to refresh DHT
  _advertise_wait_interval = 60

  # Override
  def copy(self):
    return CoordinationShim()

  def __init__(self, next_shim=None, optional_args=None):
    self._localhost = mycontext['localhost']
    BaseShim.__init__(self, next_shim, optional_args)
    self._logger = ShimLogger('CoordinationShim')



  def get_advertisement_string(self):
    return '(CoordinationShim)' + self.shim_stack.get_advertisement_string()


  # ===========================================================================
  # SERVER METHODS - TCP
  # ===========================================================================

  def _shim_listener_callback(self, remoteip, remoteport, socket, thiscommhandle, listencommhandle):
    self._logger.log('listener_callback: new client from %s:%s' % (remoteip, remoteport))

    # The first message that is received is the hostname that is associated with the remote
    # node.
    try:
      received_message = session_recvmessage(socket)
    except SessionEOF, err:
      self._logger.log("Session closed before receiving remote hostname.")
      raise
    except Exception, err:
      self._logger.log("Exception occured in listener_callback " + str(err))
      raise

    
    # Make sure that the first message that we received is in the correct
    # format and has the hostname in the message.
    if self.hostname_header in received_message:
      remote_hostname = received_message.split(self.hostname_header)[1]
      self._logger.log("Registered remote hostname as %s" % remote_hostname)
      remoteip = remote_hostname      
  
    # This is the case where the first message did not include the hostname
    # header. It should never get here.
    else:
      self._logger.log("The client did not send the hostname across the connection.")
      socket.close()
      raise Exception("Could not resolve a hostname from the client node!")
 

    return (remoteip, remoteport, socket, thiscommhandle, listencommhandle)




  def _shim_waitforconn(self, hostkey, port, callback):

    # Traverse through the stack and build the general stack, which is shared
    # for all incoming connections.
    handle = self.shim_stack.waitforconn(hostkey, port, callback)

    # Now that the stack has been built, we can advertise its content.
    advertise_key = str(hostkey) + "," + str(port) + ",TCP"
    advertise_value = self.shim_stack.get_advertisement_string()

    # We advertise the contents of the shim stack at its first creation.
    # Subsequent changes are on a per-connection basis (using negotiation) and
    # are irrelevant for coordination.
    self._listener_active = True
    settimer(0, self._advertise_thread, [advertise_key, advertise_value])
    self._logger.log('waitforconn: Listening. About to advertise <"%s","%s">' % (advertise_key, advertise_value))

    return handle


  
  def _advertise_thread(self, advertise_key, advertise_value):
    while self._listener_active:
      try:
        # We're prepending an '@' sign to the shim stack string because of a
        # flaw in the advertisement service, which returns a list of an empty
        # string upon unsuccessful lookup. We want to distinguish that case with
        # an empyt stack string.
        advertise_announce(str(advertise_key), "@" + str(advertise_value), 120)
      except Exception, e:
        # Silently drops all errors because the advertisement service can be
        # flaky at times
        pass

      sleep(self._advertise_wait_interval)




  # ===========================================================================
  # SERVER METHODS - UDP
  # ===========================================================================

  def _shim_recvmess_callback_wrapper(self, remoteip, remoteport, message, commhandle):
    """
    <Purpose>
      This is more of a wrapper function for the recvmess callback function.
      For the puspose of shim, we need to send some extra info across the 
      connection. Mainly the hostname of the client node.

    <Arguments>
      The same arguments as the callback function for recvmess() for Repy v1.

    <Exceptions>
      Exception raised if the UDP message received is not in the right
      format. If the client side is using Coordination Shim, then this
      shouldn't be a problem.

    <Side Effects>
      The raw message received gets changed before its passed
      to the callback function.

    <Return>
      None.
    """

    # The UDP message is sent in a certain format. The format
    # is the hostname tag followed by the remote hostname, followed
    # by the UDP message tag, followed by the actual message sent
    # by the client.
    try:
      hostname_tag, udp_message = message.split(self.UDP_tag)  
    except:
      self._logger.log("Invalid format of UDP message received.")
      raise Exception("Invalid format of UDP message received.")

    # Extract the remote hostname from the message.
    remote_hostname = hostname_tag.split(self.hostname_header)[1]

    # Call the callback function provided, with the right arguments.
    self._recvmess_callback_function(remote_hostname, remoteport, udp_message, commhandle)
  




  def _shim_recvmess(self, host, port, callback):
    """
    <Purpose>
      This is the recvmess function for this shim level. We have to extract
      some information from the UDP message received before we can call the
      callback function.

    <Arguments>
      Same as the arguments for recvmess() for Repy v1

    <Side Effects>
      None.

    <Exceptions>
      None.

    <Return>
      A commhandle
    """

    self._recvmess_callback_function = callback

    # We want to pass it the modified callback function.
    return self.shim_stack.recvmess(host, port, self._shim_recvmess_callback_wrapper)
    


  # ===========================================================================
  # CLIENT METHODS - UDP
  # ===========================================================================

  def _shim_sendmess(self, host, port, msg, localhost=None, localport=None):
    """
    <Purpose>
      This is the sendmess() function for this layer of shim. It modifies the
      message slightly befor sending it across.

    <Arguments>
      Same as the arguments for sendmess() for Repy v1.

    <Exceptions>
      socket.error when communication errors happen

    <Side Effects>
      The message we send across the network is slightly modified.

    <Return>
      The number of bytes sent across the network.
    """

    # We want to append the hostname and the UDP tag along with the message.
    msg_to_send = self.hostname_header + self._localhost + self.UDP_tag + msg

    # Call the shimstacks sendmess()
    bytesent = self.shim_stack.sendmess(host, port, msg_to_send, localhost, localport)

    # If we were unsuccessful at sending message, that is if the value returned
    # was not the expected value, then we return the bytesent value.
    if bytesent <= 0:
      return bytesent

    # Since we added extra tags in front of the message, we want to take that into
    # account, and make sure that the application layer doesn't know about it. So
    # we need to adjust the message length value that we return.
    message_size = bytesent - (len(msg_to_send) - len(msg))

    return message_size
      




  # ===========================================================================
  # NON-SERVER METHODS
  # ===========================================================================


  # Uses a lookup service to coordinate the construction of the client shim
  # stack. Returns a list of available shim stack string representations. If
  # use_cache is set to True, then we are only doing a lookup on a local
  # cache. Otherwise, we will do a lookup remotely. Helper for the openconn
  # operation.
  def _get_shimstack_strings(self, hostkey, port, timeout, use_cache=True):
    start_time = getruntime()
    # Initializes the local cache so we don't have to contact the remote
    # services all the time.
    if mycontext.has_key('shim_stack_string_cache_lock'):
      mycontext['shim_stack_string_cache_lock'].acquire()
    else:
      mycontext['shim_stack_string_cache_lock'] = getlock() 
      mycontext['shim_stack_string_cache_lock'].acquire()
      mycontext['shim_stack_string_cache'] = {}

    lookup_results = []
    lookup_key = str(hostkey)+','+str(port)+',TCP'
    local_lookup_cache = mycontext['shim_stack_string_cache']

    # Search the cache if use_cache is True. If cache returns empty, use the
    # remote lookup service.
    if use_cache and local_lookup_cache.has_key(lookup_key):
      lookup_results = local_lookup_cache[lookup_key][:]
      if lookup_results:
        mycontext['shim_stack_string_cache_lock'].release()
        return lookup_results

    # Contact the remote lookup service
    for count in range(self._lookup_attempts):
      # If we have exceeded the timeout time, then
      # there is no point in doing a lookup.
      if (getruntime() - start_time) > timeout:
        return lookup_results

      lookup_results = advertise_lookup(lookup_key, graceperiod=0.5, timeout=2)
      
      if len(lookup_results) > 0 and lookup_results[0]:
        break
      print lookup_results
      sleep(1)

    # Add to local cache.
    if local_lookup_cache.has_key(lookup_key):
      local_lookup_cache[lookup_key] += lookup_results[:]
    else:
      local_lookup_cache[lookup_key] = lookup_results[:]

    # Remove duplicates or else we would be trying the same non-working shim
    # stacks multiple times.
    self._remove_duplicates(local_lookup_cache[lookup_key])

    # Return a copy so that others won't be able to mess with our internal
    # cache.
    lookup_results = local_lookup_cache[lookup_key][:]

    mycontext['shim_stack_string_cache_lock'].release()

    return lookup_results


  def _shim_openconn(self, hostkey, port, localhost=None, localport=None, timeout=5):
    """
    <Purpose>
      This is the openconn function for the Coordination Shim. It is responsible
      for finding out which shims the server is using and connecting to it. It also
      sends its localhostname to the server, so the server knows what hostname to use
      to contact back this node.

    <Exception>
      - Exception raised if we are unable to send the local hostname across the connection.
      - Any socket.connect exceptions are raised.
      - Socket timeout raised, if the timeout is less then the time it takes to do all the 
        shim work.

    <Side Effects>
      None.

    <Return>
      socket like object for the connection, if successful.
    """
    start_time = getruntime()

    exception_str = ''
    sock = None

    # Indicates whether we have tried using the remote lookup services
    # (e.g. DHT) to locate the shim stack strings of the server.
    tried_using_remote_lookup = False

    # First, obtain the shim stack string from cache, or if not, from the DHT.
    shimstackstr_list = self._get_shimstack_strings(hostkey, port, timeout, use_cache=True)
    
    # Try to do openconn for every possible shim stack string
    while len(shimstackstr_list) > 0:

      try:
        # Remove the preceding @ sign in the shim stack string
        # The first character in the string is @, which is why
        # we take [1:] portion of the string.
        shimstackstr = shimstackstr_list.pop()[1:]
        shim_stack = ShimStack(shimstackstr)
      except Exception, e:
        errmsg = "Unable to parse shim stack string '%s' because '%s'." % (shimstackstr, e)
        self._logger.log("openconn: " + errmsg)
        raise Exception(errmsg)
      
      try:
        # We have to take into account that some time was wasted retrieving the shim list,
        # so we have to modify the timeout.
        timeout = timeout - (getruntime() - start_time)

        if timeout <= 0:
          raise Exception("Connection timed out!")
        
        sock = shim_stack.openconn(hostkey,port,localhost,localport,timeout)
        
      except Exception,e:
        exception_str +=' || Exception: '+str(e)+' for stack '+shimstackstr
        exception_str +=' while connecting to %s:%s' % (hostkey, port)
        raise Exception(exception_str)
      else:
        # Success in openconn. We won't try the rest of the shimstack strings.
        # Now that we have made a connection, the first message we are going 
        # to send over is the localhostname.
        hostname_message = self.hostname_header + self._localhost

        # Send the hostname across the connection. If we fail, raise an error.
        try:
          session_sendmessage(sock, hostname_message)
        except Exception, err:
          self._logger_log("openconn: Unable to send hostname across connection. " + 
                           str(err))
          sock.close()
          raise 

        # Break out of whileloop because everything was successful.
        break


      if len(shimstackstr_list) == 0 and not tried_using_remote_lookup:
        # All possible shim stack strings are consumed and we still haven't
        # found a workable one. We want to lookup the shim stack strings using
        # the remote services, instead of the local cache.
        
        shimstackstr_list = self._get_shimstack_strings(hostkey, port, timeout, use_cache=False)
        tried_using_remote_lookup = True

      if len(shimstackstr_list) == 0 and tried_using_remote_lookup:      
        # All possible shim stack strings are consumed. We haven't found a
        # workable one after lookups on both the local cache and the remote
        # services. We raise our arms and shall surrender.
        break

    # end while

    # If all things fail, we will connect without the shim interface. This
    # provides backward compatibility for older servers.
    if sock is None:
      self._logger.log("openconn: Trying to connect to %s:%s without using the shim interface." % (hostkey, port))
      try:
        # We have to take into account that some time was wasted retrieving the shim list,
        # so we have to modify the timeout.
        timeout = timeout - (getruntime() - start_time)

        if timeout <= 0:
          raise Exception("Connection timed out!")

        sock = openconn(hostkey,port,localhost,localport,timeout)
      except Exception,e:
        exception_str +=' || Unable to connect without using shims becase %s.' % e

    # At this point, we've exhausted all our means.
    if sock is None:
      exception_str = 'CoordinationShim error: ' + exception_str
      self._logger.log("CoordinationShim: " + exception_str)
      raise Exception(exception_str)
    else:
      self.shim_stack = shim_stack
      return sock





  def _shim_stopcomm(self, handle):
    self._listener_active = False
    return self.shim_stack.stopcomm(handle)


  # Remove the duplicates in the input list. The input list is modified. Helper
  # method for self._get_shimstack_strings.
  def _remove_duplicates(self, inlist):
    listindex = 0

    while listindex < len(inlist):
      # If the current item appears in the rest of the list, remove it.
      currentitem = inlist[listindex]
      if currentitem in inlist[listindex+1:]:
        del inlist[listindex]
      else:
        listindex += 1


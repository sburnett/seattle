

# A wrapper for listener handles with their corresponding shim stacks.
class NatBranchingShimHandle:
  def __init__(self, handle_stack_map):
    # A dict that maps handle to shim stack. We use the object's built-in hash
    # function, which calculates the hash value based on its memory address.
    self.handle_stack_map = handle_stack_map

  def get_map(self):
    return self.handle_stack_map

  def get_stack(self, handle):
    try:
      return self.handle_stack_map[handle]
    except KeyError:
      raise Exception('NatBranchShimHandle.getstack: invalid handle "%s"' % handle)



class NatBranchingShim(BaseShim):

  name = 'NatBranchingShim'

  def __init__(self, next_shim=None, optional_args=None):
    self._listen_handle = None
    BaseShim.__init__(self, next_shim, optional_args)




  def copy(self):
    mycopy = NatBranchingShim()
    return mycopy


  # The coordinator recognizes '[(ShimA)||(ShimB)]' as a branch statement and
  # will automatically expand it appropriately. The alternative port number is
  # enclosed in curly braces.
  def get_advertisement_string(self):
    return '(NatBranchingShim)' + self.shim_stack.get_advertisement_string()

  
  # Server listener callback
  def _branch_waitforconn_cb_wrapper(self, rip, rport, sock, th, lh):
    # busy-waiting until handle is ready
    while not self._listen_handle:
      sleep(0.5)

    # rebuild stack below this shim
    shimstack = self._listen_handle.get_stack(lh)
    socketptr = sock
    while shimstack.top_shim is not None:
      socketptr._shim = shimstack.top_shim.copy()
      socketptr = socketptr._socket
      shimstack = shimstack.top_shim.shim_stack

    # Now that the socket contains a copy of the shim stack below, we can pass
    # the socket to the callback.
    self._branch_waitforconn_cb(rip, rport, sock, th, self._listen_handle)


  # Create two separate shim stacks. Return a wrapper of both handles when both
  # shim stacks return.
  def _shim_waitforconn(self, host, port, callback):

    # Build both shims
    noopstack = self.shim_stack.copy()
    natstack = self.shim_stack.copy()
    natstack.push(NatForwardingShim())

    # Create callback wrapper so that the callback function receives our
    # customized listen handle
    self._branch_waitforconn_cb = callback

    # create handle
    print 'zzzz NatBranchingShim: Constructing noop shim stack.'
    noophandle = noopstack.waitforconn(host, port, self._branch_waitforconn_cb_wrapper)
    print 'zzzz NatBranchingShim: Constructing nat shim stack.'
    nathandle = natstack.waitforconn(host, port, self._branch_waitforconn_cb_wrapper)
    handle_stack_map = {noophandle: noopstack, nathandle: natstack}
    self._listen_handle = NatBranchingShimHandle(handle_stack_map)

    return self._listen_handle



  # Stop both listeners.
  def _shim_stopcomm(self, listen_handle):
    # check handle
    if not isinstance(listen_handle, NatBranchingShimHandle):
      # TODO Should return false here
      raise Exception('Incorrect listen_handle type.') 

    result = True
    for handle in listen_handle.get_map().keys():
      stack = listen_handle.get_map()[handle]
      ret = stack.stopcomm(handle)
      result = result and ret

    return result
    
 
    

  def _shim_openconn(self, host, port, localhost=None, localport=None, timeout=5):
    # Let us try direct connection first
    try:
      print "zzzz NatBranchingShim: Trying direct connection."
      sock = self.shim_stack.openconn(host, port, localhost, localport, timeout)

      if randomfloat() < 0.5:
        raise Exception('Testing: Try using Nat with 0.5 probability.')


      print "zzzz NatBranchingShim: Direct connection works."
      return sock

    except Exception, e:
      print "zzzz NatBranchingShim: Direct connection failed because '%s'." % e
      print "zzzz NatBranchingShim: Trying Nat."
      self.shim_stack.push(NatForwardingShim())
      sock = self.shim_stack.openconn(host, port, localhost, localport, timeout)
      print "zzzz NatBranchingShim: Nat works."
      return sock

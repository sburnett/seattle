"""

Main entry point for all applications that use shim. Provides a wrapper for the
shim stack object for easy instantiation. Also catches any exceptions that are
not consistant with the API semantics. Provides logging capabilities.


"""

include ShimSocketWrapper.repy
include ShimStack.repy
include ShimException.repy
include DummyDNS.repy
include ShimLogger.repy


# Include all shims in the world

include BaseShim.repy
include CoordinationShim.repy
include NatForwardingShim.repy
include NatDeciderShim.repy
include SimpleEncryptionShim.repy
include LogShim.repy
include RSAShim.repy
include NatBranchingShim.repy
include RSABranchingShim.repy
include ReverseShim.repy
include NoopShim.repy
include FECShim.repy
include LZWShim.repy



# Register all shims in the world

register_shim('BaseShim', BaseShim)
register_shim('CoordinationShim', CoordinationShim)
register_shim('NatForwardingShim', NatForwardingShim)
register_shim('NatDeciderShim', NatDeciderShim)
register_shim('SimpleEncryptionShim', SimpleEncryptionShim)
register_shim('LogShim', LogShim)
register_shim('RSAShim', RSAShim)
register_shim('NatBranchingShim', NatBranchingShim)
register_shim('RSABranchingShim', RSABranchingShim)
register_shim('ReverseShim', ReverseShim)
register_shim('NoopShim', NoopShim)
register_shim('FECShim', FECShim)
register_shim('LZWShim', LZWShim)



# =============================================================================
# TODO for debugging
#

debugging = True

def debugprint(string):
  if debugging:
    print "zzzz NatBranchingShim: " + str(string)



mycontext['debug_free_ports'] = [12346, 12347]
# For the purpose of debugging only
def getFreePort():
  try:
    return mycontext['debug_free_ports'].pop()
  except IndexError:
    raise Exception('No more free ports')

def getRandomIP():
  ip = '127'
  for section in range(3):
    randint = random_int_below(256)
    ip += '.' + str(randint)
  return ip
  

#
# =============================================================================




class ShimStackInterface:

  def __init__(self, stack_str='', autoCoordinationShim=True):
    self._stack_str = stack_str

    if autoCoordinationShim:
      if stack_str.find('CoordinationShim') < 0:
        self._stack_str = '(CoordinationShim)' + self._stack_str

    # Maps handle to stack. Although handle does not have a hash function
    # defined, it is in fact hashed by its memory address. Thus, the keys in our
    # map always reference to unique handles in the memory.
    self._handle_dict = {}

    self._logger = ShimLogger('SHIM')


  def waitforconn(self, host, port, callback):
    shimstack = ShimStack(self._stack_str)

    try:
      handle = shimstack.waitforconn(host, port, callback)
    except Exception, err:
      self._logger.log('waitforconn: Uncaught exception: ' + str(err))
      raise Exception(err)

    self._logger.log('waitforconn on %s:%s' % (host, port))
    self._handle_dict[handle] = shimstack
    return handle


  def stopcomm(self, handle):
    try:
      shimstack = self._handle_dict[handle]
    except KeyError,e:
      raise KeyError(e)
      return False

    try:
      ret = shimstack.stopcomm(handle)
    except Exception, err:
      self._logger.log('stopcomm: Uncaught exception: ' + str(err))
      raise Exception(err)

    return ret
 

  def openconn(self,host,port,localhost=None,localport=None,timeout=5):
    shimstack = ShimStack(self._stack_str)

    try:
      socket = shimstack.openconn(host,port,localhost,localport,timeout)
    except Exception, err:
      self._logger.log('openconn: on %s:%s uncaught exception: %s' % (host, port, err))
      raise Exception(err)

    self._logger.log('openconn: success on %s:%s' % (host, port))

    return socket


  def sendmess(self,host,port,msg,localhost=None,localport=None):
    shimstack = ShimStack(self._stack_str)
    return shimstack.sendmess(host,port,msg,localhost,localport)

 

  def recvmess(self, host, port, callback):
    shimstack = ShimStack(self._stack_str)
    handle = shimstack.recvmess(host, port, callback)
    self._handle_dict[handle] = shimstack
    return handle


mycontext['shim_stack_interface_imported'] = True

"""

Main entry point for all applications that use shim. Provides a wrapper for the
shim stack object for easy instantiation. Also catches any exceptions that are
not consistant with the API semantics. Provides logging capabilities.


"""

include ShimSocketWrapper.repy
include ShimStack.repy
include ShimException.repy



# Include all shims in the world

include BaseShim.repy
include CoordinationShim.repy
include NatForwardingShim.repy
include NatDeciderShim.repy
include SimpleEncryptionShim.repy
include LogShim.repy
include RSAShim.repy
include NatBranchingShim.repy
include RSABranchingShim.repy
include ReverseShim.repy




# Register all shims in the world

register_shim('BaseShim', BaseShim)
register_shim('CoordinationShim', CoordinationShim)
register_shim('NatForwardingShim', NatForwardingShim)
register_shim('NatDeciderShim', NatDeciderShim)
register_shim('SimpleEncryptionShim', SimpleEncryptionShim)
register_shim('LogShim', LogShim)
register_shim('RSAShim', RSAShim)
register_shim('NatBranchingShim', NatBranchingShim)
register_shim('RSABranchingShim', RSABranchingShim)
register_shim('ReverseShim', ReverseShim)


# =============================================================================
# TODO for debugging
#

#begin include random.repy 
#already included random.repy 
#end include random.repy 
debugging = True

def debugprint(string):
  if debugging:
    print "zzzz NatBranchingShim: " + str(string)


# Pretend that some host is behind the nat
def pretendToHaveNat(hostkey, hostport):
  if not mycontext.has_key('nat_cheat'):
    mycontext['nat_cheat'] = []
  mycontext['nat_cheat'].append(hostkey + str(hostport))



mycontext['debug_free_ports'] = [12346, 12347]
# For the purpose of debugging only
def getFreePort():
  try:
    return mycontext['debug_free_ports'].pop()
  except IndexError:
    raise Exception('No more free ports')

def getRandomIP():
  ip = '127'
  for section in range(3):
    randint = random_int_below(256)
    ip += '.' + str(randint)
  return ip
  

#
# =============================================================================


class ShimStackInterface:

  def __init__(self, stack_str=''):
    self._stack_str = stack_str
    if stack_str.find('CoordinationShim') < 0:
      self._stack_str = '(CoordinationShim)' + self._stack_str

    # Maps handle to stack. Although handle does not have a hash function
    # defined, it is in fact hashed by its memory address. Thus, the keys in our
    # map always reference to unique handles in the memory.
    self._handle_dict = {}


  def _interface_listener_cb_wrapper(self, sock, rip, rport, th, lh):
    try:
      self._interface_listener_cb(sock, rip, rport, th, lh)
    except Exception, e:
      # TODO log
      print "ShimStackInterface: Exception at acceptance of connection: '%s'." % e


  def waitforconn(self, host, port, callback):
    shimstack = ShimStack(self._stack_str)

    self._interface_listener_cb = callback
    handle = shimstack.waitforconn(host, port, self._interface_listener_cb_wrapper)

    self._handle_dict[handle] = shimstack
    return handle


  def stopcomm(self, handle):
    try:
      shimstack = self._handle_dict[handle]
    except KeyError:
      return False

    return shimstack.stopcomm(handle)
 

  def openconn(self,host,port,localhost=None,localport=None,timeout=5):
    shimstack = ShimStack(self._stack_str)
    socket = shimstack.openconn(host,port,localhost,localport,timeout)
    return socket


  def sendmess(self,host,port,msg,localhost=None,localport=None):
    shimstack = ShimStack(self._stack_str)
    return shimstack.sendmess(host,port,msg,localhost,localport)

 

  def recvmess(self, host, port, callback):
    shimstack = ShimStack(self._stack_str)
    handle = shimstack.recvmess(host, port, callback)
    self._handle_dict[handle] = shimstack
    return handle




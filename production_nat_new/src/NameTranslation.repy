"""
Provides a translation service for host keys.

"""

class NameTranslationError(Exception):
  pass




def initialize_hostkey_ip_translation(tolock=True):
  """
  Initializes the name translator. Can be called multiple times but only the
  first call actually initializaes the translator. In this method and the ones
  below, you indicate whether you want them to be thread-safe or not by
  specifying the boolean tolock. Set tolock to False here when you're holding
  the hostkey_to_ip_map_lock from an caller method. This lock is not a reentrant
  lock.

  """
  if not mycontext.has_key('hostkey_to_ip_map_lock'):
    mycontext['hostkey_to_ip_map_lock'] = getlock()

  if tolock:
    mycontext['hostkey_to_ip_map_lock'].acquire()

  if not mycontext.has_key('hostkey_to_ip_map'):
    mycontext['hostkey_to_ip_map'] = {}
  
  if tolock:
    mycontext['hostkey_to_ip_map_lock'].release()




def set_ip_to_hostkey(hostkey, ipstr, tolock=True):
  """
  Associates an IP address with a host key.

  """
  initialize_hostkey_ip_translation(tolock)

  if tolock:
    mycontext['hostkey_to_ip_map_lock'].acquire()

  if not mycontext.has_key('hostkey_to_ip_map'):
    mycontext['hostkey_to_ip_map'] = {}

  mycontext['hostkey_to_ip_map'][hostkey] = ipstr

  if tolock:
    mycontext['hostkey_to_ip_map_lock'].release()




def get_ip_from_hostkey(hostkey, tolock=True):
  """
  Returns the IP address string associated with the host key supplied.

  """
  try:
    if tolock:
      mycontext['hostkey_to_ip_map_lock'].acquire()
  except KeyError, e:
    raise NameTranslationError('No hostkey-IP pair has been created yet.')

  try:
    return mycontext['hostkey_to_ip_map'][hostkey]
  except KeyError, e:
    raise NameTranslationError('Invalid hostkey %s.' % hostkey)
  finally:
    if tolock:
      mycontext['hostkey_to_ip_map_lock'].release()




def is_ip_address(ipstr):
  """
  Returns True if ipstr is a valid IP address. Checks if each of the four
  segments of an IP address is an integer between 0 and 255 inclusive.

  """
  ip_segment_list = ipstr.split('.')
  if len(ip_segment_list) != 4:
    return False

  for ip_segment_str in ip_segment_list:
    try:
      ip_segment_int = int(ip_segment_str)
    except ValueError, e:
      return False

    if not (0 <= ip_segment_int < 256):
      return False

  return True

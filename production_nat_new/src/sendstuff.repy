include ShimStackInterface.repy



msgsizes = [50, 100, 200, 500, 1000, 2000, 5000, 10000]


def main(shimstr):

  mycontext['sendshim'] = ShimStackInterface(shimstr)
  mycontext['recvshim'] = ShimStackInterface(shimstr)

  # read from command line
  try:
    port = int(callargs[0])
    packetcount = int(callargs[1])
  except:
    print 'Argument: [GENIPort] [number of packets]'
    return

  # get peer ip
  try:
    f = open('config.txt')
  except Exception, err:
    print 'Cannot open config file:', str(err)
    return

  localtest = 'local' in callargs
  if localtest:
    print '\nLOCAL TEST MODE'
  else:
    print '\nNEW TEST'

  peerlist = []
  myip = getmyip()

  for line in f:
    peerip = line.strip()
    if myip != peerip or localtest: 
      peerlist.append(peerip)

  f.close()

  # initialize results table
  mycontext['packets_received'] = {}
  for size in msgsizes:
    mycontext['packets_received'][size] = 0

  # start listening
  handle = mycontext['recvshim'].recvmess(myip, port, recv_callback)

  # get sample contents
  if localtest:
    f = open('out.sendstuff.repy')
  else:
    f = open('sendstuff.repy')
  msg = f.read(max(msgsizes))
  f.close()
  print 'Original message size:', len(msg), '; Peers:', len(peerlist),
  print '; Total messages to send per msg size:', packetcount ,
  print '; Shim Stack:', shimstr
  print 'Message size list:',
  for msgsize in msgsizes:
    print msgsize,
  print ''

  sleep(2)

  # start sending
  for peerip in peerlist:
    settimer(0, sendpackets, [peerip, port, packetcount, msg])

  # display results when they haven't changed for 2 times (one minute)
  prevresult = ''
  nochangecount = 0
  print " > Percent packets received per 30 seconds:",
  while nochangecount < 2:
    resultdict = mycontext['packets_received']

    if str(resultdict) == prevresult:
      nochangecount += 1
    else:
      progress = int(sum(resultdict.values()) * 100 / len(msgsizes) / len(peerlist) / packetcount)
      print progress,
      if progress == 100: break
      prevresult = str(resultdict)
      nochangecount = 0
    
    if localtest:
      sleep(5)
    else:
      sleep(30)

  # stop listening
  mycontext['recvshim'].stopcomm(handle)

  # present result
  resultstr = '\n > Packets received: '
  for msgsize in msgsizes:
    resultstr += '%d ' % resultdict[msgsize]
  print resultstr


def recv_callback(rip, rport, msg, handle):
  resultdict = mycontext['packets_received']
  msgsize = len(msg)
  if msgsize in resultdict.keys():
    resultdict[msgsize] += 1
  else:
    print 'Invalid msgsize', msgsize



def sendpackets(ip, port, packetcount, msg):
  packetleft = {}
  for msgsize in msgsizes:
    packetleft[msgsize] = packetcount

  while sum(packetleft) > 0:
    # pick a msg size to send
    thismsgsize = msgsizes[random_int_below(len(msgsizes))]
    if packetleft[thismsgsize] == 0:
      continue

    thismsg = msg[0:thismsgsize]
    sentbytes = mycontext['sendshim'].sendmess(ip, port, thismsg)
    if sentbytes == len(thismsg):
      # successful sent
      packetleft[thismsgsize] -= 1



if callfunc == 'initialize':
  for shimstr in ['', '(FECShim)', '(LZWShim)', '(LZWShim)(FECShim)']:
    main(shimstr)

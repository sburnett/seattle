
openconn(ip,port,localIP=None,localPort=None,timeout=) 


  summary:

    returns a socketlikeobj that has the calls send(), recv(), and close() 
    which exactly matches the semantics defined by the repy api OR throws 
    an exception indicating the connection failed

  argument semantics:  (not currently tested)
  
    ip is a string, if not a TyperError should be thrown (no test)
    port is an int, if not a TypeError should be thrown (no test)
    (same for localIP and localPort) (no test)
    if one of localIP / localPort is specified and not the other  
      exception
    if localIP specified is not your ip??
    timeout is an int, in not typeError
    timeout is greater than 0, if not ValueError
    
    the local port or local ip is not allowed Exception (ResouceNotAllowed)


  behavioral semantics:

 1. openconn called with a localip that is not its localip?   
      (no test)  - not sure what i want to do with this/ can we even test for this?
 
 2. if the timeout specified runs out before the connection is made
      timeout exception is thrown 
      (no test) -  ...how to test timeout issues??
 
 3. an openconn is done but there is no one waiting for a connection at the
      IP,Port specified
        exception is thrown
        (tested - test_openconn_no_listener.py)
     ##need more exhaustive testing here, for example try to do openconns to
       other socket connections or to ip/port used by recvmess()
    

 4.  openconn is called with localIP and Port that is used by a waitfor conn
        Address Already in Use exception (look for equivalent in our hierchy)
        (tested - test_openconn_same_port_as_waitforconn_1.py )

      
 5. a waitforconn is called on localIP / localPort, then stopcomm is called
    then an openconn is performed 
      should connect without exception 
      (tested - test_openconn_after_stopcomm.py)

    
 6. an openconn is called, the connection returned is then closed 
      then an identical openconn is called.

      replicated by a test_close_blocks.py

 7. an openconn is called then the local socket is closed, but the other side of
      the connection is kept open, then an identical openconn is performed
      no exception is thrown, a new connection is established
      (tested - test_openconn_local_socket_close)

    
 8. an openconn is called then the remote socket is closed, but the local socket
      is kept open, then an identical openconn is performed
      causes exception
      (tested - test_openconn_remote_socket_close)  


 9. openconn is called twice with the same 4-tuple
      exception (address in use) 
      (tested by -  test_openconn_duplicate_4tuple.py)

10. openconn is called any number of times with a unique 4 tuple each time
      no exception should work each time 

         different remote ports (tested - .._differnt_remote_ports.py)
         different local ports  (tested - .._differnt_local_ports.py)
         different local ip     (no test)  ??how to test this?? does seattle support?
         different remote ip    (remote tested - echo_server.py and ...
                                 test_openconn_different_remote_ip.py)
 
11. openconn is called and then a waitforconn is called with the same local
    ip and port
      the sock reutnred by openconn should have no trouble but the waitforconn
      should throw exception 
      
      (tested - test_openconn_waitforconn.py)   half Fails, the socket
       contines working, but the waitforconn does not fail, this failure is
       on waitforconn and not openconn though.  I think 

  
12. two remote nodes call openconn to connect to each other
      should connect without exception 
      (no test) 
      ? is this possible for all systems, or should we define it such that
      this is not allowed for better portability?

      (tried to test locally but connection failed. probably due to timing
       will try harder)
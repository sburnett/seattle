""" 
Author: Justin Cappos

Module: Node Manager API.   This processes an already checked request.
    In almost all cases this means that no security checks are done here as
    a result.

Start date: September 1st, 2008

The design goals of this version are to be secure, simple, and reliable (in 
that order).   

The individual functions in here are called from nmrequesthandler.   The 
functions are listed in the API_dict.
"""

# used to persist data...
import persist

# used to do resource arithmatic magic...
import nmresourcemath

# Is this the same as nmrequesthandler.BadRequest?  (the expected type of 
# exception)
class BadRequest(Exception):
  pass

# used to check file names in addfiletovessel, retrievefilefromvessel, and
# deletefileinvessel
from emulfile import assert_is_allowed_filename

# needed for path.exists and remove
import os 

# needed for copy
import shutil

import threading

import subprocess

import time

# used in startvessel and stopvessel
import statusstorage

# used to check file size restrictions...
import misc

# need this to check uploaded keys for validity
include rsa.repy
# MIX: fix with repy <-> python integration changes
import random
randomfloat = random.random()

offcutfilename = "resources.offcut"

# The node information (reported to interested clients)
nodename = ""
nodepubkey = ""
nodeversion = ''

# the maximum size the logging buffer can be
# NOTE: make sure this is equal to the maxbuffersize in logging.py
logmaxbuffersize = 16*1024

# the maximum length of the ownerstring
maxownerstringlength = 256


# The vesseldict is the heart and soul of the node manager.   It keeps all of 
# the important state for the node.   The functions that change this must 
# persist it afterwards.
# The format of an entry is:
#   'vesselname':{'userkeys':[key1, key2, ...], 'ownerkey':key, 
#   'oldmetadata':info, 'stopfilename':stopfile, 'logfilename':logfile, 
#   'advertise':True, 'ownerinformation':'...', 'status':'Fresh',
#   'resourcefilename':resourcefilename, 'statusfilename':statusfilename}
#
# The 'status' field is updated by the status monitor.   This thread only 
# reads it.
# 
# The 'advertise' field is read by the advertise thread.   This thread updates
# the value.
#
# The stopfilename is always the vesselname+'.stop', the logfilename is always 
# the vesselname+'.log', and the resourcefilename is 'resources.'+vesselname
# However, these are listed in the dictionary rather than derived when needed
# for clarity / ease of future changes.
#
# No item that is modified by an API call requires persistant updates to
# anything except the vesseldict.   The vesseldict must always be the
# last thing to be updated.   Since all actions that are performed on existing
# files are either atomic or read-only, there is no danger of corruption of
# the disk state.
vesseldict = {}


def initialize(name, pubkey, version):
  # Need to set the node name, etc. here...
  global nodename
  global nodepubkey
  global nodeversion
  global vesseldict
  

  nodename = name
  nodepubkey = pubkey

  nodeversion = version 

  # load the vessel from disk
  vesseldict = persist.restore_object('vesseldict')

  return vesseldict


def getvessels():
  # Returns vessel information
  # start with the node name, etc.
  vesselstring = "Version: "+nodeversion+"\n"
  vesselstring = "Nodename: "+nodename+"\n"
  vesselstring = "Nodekey: "+str(nodepubkey)+"\n"
  
  # for each vessel add name, status ownerkey, ownerinfo, userkey(s)
  for vesselname in vesseldict:
    vesselstring = vesselstring+"Name: "+vesselname+"\n"
    vesselstring = vesselstring+"Status: "+vesseldict[vesselname]['status']+"\n"
    vesselstring = vesselstring+"Advertise: "+str(vesseldict[vesselname]['advertise'])+"\n"
    vesselstring = vesselstring+"OwnerKey: "+str(vesseldict[vesselname]['ownerkey'])+"\n"
    vesselstring = vesselstring+"OwnerInfo: "+vesseldict[vesselname]['ownerinformation']+"\n"
    for userkey in vesseldict[vesselname]['userkeys']:
      vesselstring = vesselstring+"UserKey: "+str(userkey)+"\n"

  vesselstring = vesselstring + "\nSuccess"
  return vesselstring


def getvesselresources(vesselname):

  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"

  # return the resources file...
  resourcefo = open(vesseldict[vesselname]['resourcefilename'])
  resourcedata = resourcefo.read()
  resourcefo.close()
  resourcedata = resourcedata + "\nSuccess"
  return resourcedata

def getoffcutresources():
  # return the resources file...
  resourcefo = open(offcutfilename)
  resourcedata = resourcefo.read()
  resourcefo.close()
  resourcedata = resourcedata + "\nSuccess"
  return resourcedata


allowedchars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890.-_ "

def startvessel(vesselname, argstring):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"

  if vesseldict[vesselname]['status'] == 'Started':
    raise BadRequest("Vessel has already been started")

  # remove any prior stop file so that we can start
  if os.path.exists(vesseldict[vesselname]['stopfilename']):
    os.remove(vesseldict[vesselname]['stopfilename'])

  for char in argstring:
    if char not in allowedchars:
      raise BadRequest("Character '"+char+"' not allowed in arguments")
 
  commandstring = "python repy.py --logfile "+vesseldict[vesselname]['logfilename']+" --stop "+vesseldict[vesselname]['stopfilename']+" --status "+vesseldict[vesselname]['statusfilename']+" "+vesseldict[vesselname]['resourcefilename']+" "+vesselname+'/'+argstring

  # BUG: there is a bit of oddness with starting experiments.   
  # The command needs to be run in another thread or else Windows refuses to 
  # close the socket.   I also need to wait long enough that the socket has
  # had a chance to close...

#  tobj = threading.Timer(10.0, start_task, (commandstring,))
#  tobj.start()
#  return "\nSuccess (will start in 10 seconds)"

  # I'm going to capture the status and timestamp and then check the see if
  # the timestamp is updated...
  oldstatus, oldtimestamp = statusstorage.read_status(vesseldict[vesselname]['statusfilename'])
  start_task(commandstring)

  starttime = time.time()

  # wait for 10 seconds for it to start (else return an error)
  while time.time()-starttime < 10:
    newstatus, newtimestamp = statusstorage.read_status(vesseldict[vesselname]['statusfilename'])
    # Great!   The timestamp was updated...   The new status is the result of 
    # our work.   Let's tell the user what happened...
    if newtimestamp != oldtimestamp:
      break

    # sleep while busy waiting...
    time.sleep(.5)

  else:
    return "Possible Error: Did not start in a timely manner"

  # BUG: Hmm, the status thread may not have noticed this yet.   This means
  # that we would report something different than the status thread if a 
  # GetVessels call occurs.   Do we care?   Is this important?
  return newstatus+"\nSuccess"



# A helper for startvessel.   private to this module
def start_task(command):
 
  # Should I use call here?
  subprocess.Popen(command, shell=True)


def stopvessel(vesselname):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"

  # this is broken out to prevent a race between checking the status and 
  # reporting the error
  currentstatus = vesseldict[vesselname]['status'] 
  # It must be started for us to stop it...
  if currentstatus != 'Started':
    raise BadRequest("Cannot stop vessel with status '"+currentstatus+"'")
  
  # create the stop file
  open(vesseldict[vesselname]['stopfilename'],"w").close()

  starttime = time.time()

  # wait for up to 10 seconds for it to stop (else return an error)
  while time.time()-starttime < 10:
    if vesseldict[vesselname]['status'] != 'Started':
      break

    # sleep while busy waiting...
    time.sleep(.5)

  else:
    return "Possible Error: May not have stopped in a timely manner"
  
  return vesseldict[vesselname]['status']+"\nSuccess"
  


# Create a file in the vessel
def addfiletovessel(vesselname,filename, filedata):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"

  # get the current amount of data used by the vessel...
  currentsize = misc.compute_disk_use(vesselname+"/")
  # ...and the allowed amount
  resourcedata = nmresourcemath.read_resources_from_file(vesseldict[vesselname]['resourcefilename'])

  # If the current size + the size of the new data is too large, then deny
  if currentsize + len(filedata) > resourcedata['diskused']:
    raise BadRequest("Not enough free disk space")
  
  try:
    assert_is_allowed_filename(filename)
  except TypeError, e:
    raise BadRequest(str(e))

  writefo = open(vesselname+"/"+filename,"w")
  writefo.write(filedata)
  writefo.close()

  return "\nSuccess"
  


# Return a file from the vessel
def retrievefilefromvessel(vesselname,filename):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"

  try:
    assert_is_allowed_filename(filename)
  except TypeError, e:
    raise BadRequest(str(e))

  try:
    readfo = open(vesselname+"/"+filename)
  except IOError, e:
    # file not found!   Let's detect and re-raise
    if e[0] == 2:
      return "Error, File Not Found"
    
    # otherwise re-raise the error
    raise

  filedata = readfo.read()
  readfo.close()

  return filedata + "\nSuccess"
  


# Delete a file in the vessel
def deletefileinvessel(vesselname,filename):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  
  try:
    assert_is_allowed_filename(filename)
  except TypeError, e:
    raise BadRequest(str(e))

  if not os.path.exists(vesselname+"/"+filename):
    raise BadRequest("File not found")

  os.remove(vesselname+"/"+filename)

  return "\nSuccess"
  

# Read the log file for the vessel
def readvessellog(vesselname):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  # copy the files, read the files, delete the copies.   
  # BUG: I don't believe there is a way to do this without any possibility for
  # race conditions (since copying two files is not atomic) without modifying
  # the sandbox to coordinate locking with the node manager
  

  # I'll use this to track if it fails or not.   This flag is used (instead of
  # doing the actual work) to minimize the time between copy calls.
  firstOK=False
  try:
    shutil.copy(vesseldict[vesselname]['logfilename']+'.old', "tmplog")
  except IOError, e:
    if e[0] == 2:
      # No such file or directory, we should ignore (we likely interrupted an 
      # non-atomic move)...
      pass
    else:
      raise
  else:
    firstOK = True


  secondOK = False
  # I have this next so that the amount of time between copying the files is 
  # minimized (I'll read both after)
  try:
    shutil.copy(vesseldict[vesselname]['logfilename']+'.new', "tmplog.new")
  except IOError, e:
    if e[0] == 2:
      # No such file or directory, we should ignore (we likely interrupted an 
      # non-atomic move)...
      pass
    else:
      raise
  else:
    secondOK = True


  # the log from the vessel
  readstring = ""

  # read the data and remove the files.
  if firstOK:
    readfo = open("tmplog")
    readstring = readstring + readfo.read()
    readfo.close()
    os.remove("tmplog")
    
  # read the data and remove the files.
  if secondOK:
    readfo = open("tmplog.new")
    readstring = readstring + readfo.read()
    readfo.close()
    os.remove("tmplog.new")

  # return only the last 16KB (hide the fact more may be stored)
  # BUG: Not a bug, but should we return more?   We have more data...
  return readstring[-logmaxbuffersize:]+"\nSuccess"
  


def changeowner(vesselname, newkeystring):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  try:
    newkey = rsa_string_to_publickey(newkeystring)
  except ValueError:
    raise BadRequest("Invalid Key String")
    
  # check the key 
  if not rsa_is_valid_publickey(newkey):
    raise BadRequest("Invalid Key")

  vesseldict[vesselname]['ownerkey'] = newkey 

  persist.commit_object(vesseldict, "vesseldict")
  return "\nSuccess"
  

def changeusers(vesselname, listofkeysstring):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  newkeylist = []

  # check the keys
  for keystring in listofkeysstring.split('|'):
    try:
      newkey = rsa_string_to_publickey(keystring)
    except ValueError:
      raise BadRequest("Invalid Key String '"+keystring+"'")

    if not rsa_is_valid_publickey(newkey):
      raise BadRequest("Invalid Key '"+keystring+"'")
    
    newkeylist.append(newkey)

  vesseldict[vesselname]['userkeys'] = newkeylist
    
  persist.commit_object(vesseldict, "vesseldict")
  return "\nSuccess"

def changeownerinformation(vesselname, ownerstring):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  if len(ownerstring) > maxownerstringlength:
    raise BadRequest("String Too Long")

  if '\n' in ownerstring:
    raise BadRequest("String may not contain newline character")

  vesseldict[vesselname]['ownerinformation'] = ownerstring

  persist.commit_object(vesseldict, "vesseldict")
  return "\nSuccess"
  


# BUG: Should this be something other than True / False (perhaps owner / user /
# none?)
def changeadvertise(vesselname, setting):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  if setting == 'True':
    vesseldict[vesselname]['advertise'] = True
  elif setting == 'False':
    vesseldict[vesselname]['advertise'] = False
  else: 
    raise BadRequest("Invalid advertisement setting '"+setting+"'")

  persist.commit_object(vesseldict, "vesseldict")
  return "\nSuccess"


lastusednumber = None

# private.   A helper function that returns an unused vessel name
def get_new_vessel_name():
  global lastusednumber
  if lastusednumber == None:
    # let's look at the dictionary and figure something out
    maxval = 0
    for vesselname in vesseldict:
      # I'm assuming naming is done by 'v'+number
      assert(vesselname[0] == 'v')
      maxval = max(maxval, int(vesselname[1:]))
  
    lastusednumber = maxval

  lastusednumber = lastusednumber + 1
  return 'v'+str(lastusednumber)


# Private.   Creates a new vessel's state in the dictionary and on disk
def setup_vessel(vesselname, examplevessel):
  if vesselname in vesseldict:
    raise Exception, "Internal Error, setting up vessel '"+vesselname+"' already in vesseldict"

  # Set the invariants up...
  item = {}
  item['stopfilename'] = vesselname+".stop"
  item['logfilename'] = vesselname+".log"
  item['resourcefilename'] = "resource."+vesselname
  item['status'] = 'Fresh'
  item['statusfilename'] = vesselname+".status"

  # first the easy stuff...   Set up the vesseldict dictionary
  if examplevessel == None:
    item['userkeys'] = []
    item['ownerkey'] = {}
    item['oldmetadata'] = None
    item['advertise'] = True
    item['ownerinformation'] = ''

  else:
    if examplevessel not in vesseldict:
      raise Exception, "Internal Error, examplevessel '"+examplevessel+"' not in vesseldict"

    item['userkeys'] = vesseldict[examplevessel]['userkeys']
    item['ownerkey'] = vesseldict[examplevessel]['ownerkey']
    item['oldmetadata'] = vesseldict[examplevessel]['oldmetadata']
    item['advertise'] = vesseldict[examplevessel]['advertise']
    item['ownerinformation'] = vesseldict[examplevessel]['ownerinformation']

  # create the directory on the file system
  os.mkdir(vesselname)

  # now we're ready to add the entry to the table (so other threads can use it)
  vesseldict[vesselname] = item

    

# Private
# BUG: What about a running vessel?
def destroy_vessel(vesselname):
  if vesselname not in vesseldict:
    raise Exception, "Internal Error, destroying a non-existant vessel '"+vesselname+"'"

  # remove the entry first so other threads aren't confused
  item = vesseldict[vesselname]
  del vesseldict[vesselname]

  if item['status'] == 'Started':
    raise BadRequest("Attempting to destroy a running vessel")

  shutil.rmtree(vesselname)
  if os.path.exists(item['logfilename']):
    os.remove(item['logfilename'])
  if os.path.exists(item['logfilename']+".new"):
    os.remove(item['logfilename']+".new")
  if os.path.exists(item['logfilename']+".old"):
    os.remove(item['logfilename']+".old")

  if os.path.exists(item['stopfilename']):
    os.remove(item['stopfilename'])

  if os.path.exists(item['resourcefilename']):
    os.remove(item['resourcefilename'])



def splitvessel(vesselname, resourcedata):
  if vesselname not in vesseldict:
    raise BadRequest, "No such vessel"
  
  # get the new name
  newname1 = get_new_vessel_name()
  newname2 = get_new_vessel_name()

  resourcefo = open("resource.temp","w")
  resourcefo.write(resourcedata)
  resourcefo.close()
  
  try:
    nmresourcemath.split(vesseldict[vesselname]['resourcefilename'], "resource.temp", offcutfilename, "resource."+newname1)

  except nmresourcemath.ResourceParseError, e:
    os.remove("resource.temp")
    raise BadRequest(str(e))

  os.rename("resource.temp","resource."+newname2)
  setup_vessel(newname1, vesselname)
  setup_vessel(newname2, vesselname)
  destroy_vessel(vesselname)
    
  persist.commit_object(vesseldict, "vesseldict")
  return "\nSuccess"

    
  
  

def joinvessels(vesselname1, vesselname2):
  if vesselname1 not in vesseldict:
    raise BadRequest, "No such vessel '"+vesselname1+"'"
  if vesselname2 not in vesseldict:
    raise BadRequest, "No such vessel '"+vesselname2+"'"

  if vesseldict[vesselname1]['ownerkey'] != vesseldict[vesselname2]['ownerkey']:
    raise BadRequest("Vessels must have the same owner")
  
  
  # get the new name
  newname = get_new_vessel_name()

  nmresourcemath.combine(vesseldict[vesselname1]['resourcefilename'], vesseldict[vesselname2]['resourcefilename'], offcutfilename, "resource."+newname)

  setup_vessel(newname, vesselname1)
  destroy_vessel(vesselname1)
  destroy_vessel(vesselname2)
    
  persist.commit_object(vesseldict, "vesseldict")
  return "\nSuccess"

    






<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>


<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<base target="_top">
<style type="text/css">
  

/* default css */

table {
  font-size: 1em;
  line-height: inherit;
  border-collapse: collapse;
}


tr {
  
  text-align: left;
  
}


div, address, ol, ul, li, option, select {
  margin-top: 0px;
  margin-bottom: 0px;
}

p {
  margin: 0px;
}


pre {
  font-family: Courier New;
  white-space: pre-wrap;
  margin:0;
}

body {
  margin: 6px;
  padding: 0px;
  font-family: Verdana, sans-serif;
  font-size: 10pt;
  background-color: #ffffff;
}


img {
  -moz-force-broken-image-icon: 1;
}

@media screen {
  html.pageview {
    background-color: #f3f3f3 !important;
  }

  

  body {
    min-height: 1100px;
    
    counter-reset: __goog_page__;
  }
  * html body {
    height: 1100px;
  }
  .pageview body {
    border-top: 1px solid #ccc;
    border-left: 1px solid #ccc;
    border-right: 2px solid #bbb;
    border-bottom: 2px solid #bbb;
    width: 648px !important;
    margin: 15px auto 25px;
    padding: 40px 50px;
  }
  /* IE6 */
  * html {
    overflow-y: scroll;
  }
  * html.pageview body {
    overflow-x: auto;
  }
  /* Prevent repaint errors when scrolling in Safari. This "Star-7" css hack
     targets Safari 3.1, but not WebKit nightlies and presumably Safari 4.
     That's OK because this bug is fixed in WebKit nightlies/Safari 4 :-). */
  html*#wys_frame::before {
    content: '\A0';
    position: fixed;
    overflow: hidden;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
  }
  
  

  
    .writely-callout-data {
      display: none;
      *display: inline-block;
      *width: 0;
      *height: 0;
      *overflow: hidden;
    }
    .writely-footnote-marker {
      background-image: url('MISSING');
      background-color: transparent;
      background-repeat: no-repeat;
      width: 7px;
      overflow: hidden;
      height: 16px;
      vertical-align: top;

      
      -moz-user-select: none;
    }
    .editor .writely-footnote-marker {
      cursor: move;
    }
    .writely-footnote-marker-highlight {
      background-position: -15px 0;
      -moz-user-select: text;
    }
    .writely-footnote-hide-selection ::-moz-selection, .writely-footnote-hide-selection::-moz-selection {
      background: transparent;
    }
    .writely-footnote-hide-selection ::selection, .writely-footnote-hide-selection::selection {
      background: transparent;
    }
    .writely-footnote-hide-selection {
      cursor: move;
    }

    
    .editor .writely-comment-yellow {
      background-color: #FF9;
      background-position: -240px 0;
    }
    .editor .writely-comment-yellow-hover {
      background-color: #FF0;
      background-position: -224px 0;
    }
    .editor .writely-comment-blue {
      background-color: #C0D3FF;
      background-position: -16px 0;
    }
    .editor .writely-comment-blue-hover {
      background-color: #6292FE;
      background-position: 0 0;
    }
    .editor .writely-comment-orange {
      background-color: #FFDEAD;
      background-position: -80px 0;
    }
    .editor .writely-comment-orange-hover {
      background-color: #F90;
      background-position: -64px 0;
    }
    .editor .writely-comment-green {
      background-color: #99FBB3;
      background-position: -48px 0;
    }
    .editor .writely-comment-green-hover {
      background-color: #00F442;
      background-position: -32px 0;
    }
    .editor .writely-comment-cyan {
      background-color: #CFF;
      background-position: -208px 0;
    }
    .editor .writely-comment-cyan-hover {
      background-color: #0FF;
      background-position: -192px 0;
    }
    .editor .writely-comment-purple {
      background-color: #EBCCFF;
      background-position: -144px 0;
    }
    .editor .writely-comment-purple-hover {
      background-color: #90F;
      background-position: -128px 0;
    }
    .editor .writely-comment-magenta {
      background-color: #FCF;
      background-position: -112px 0;
    }
    .editor .writely-comment-magenta-hover {
      background-color: #F0F;
      background-position: -96px 0;
    }
    .editor .writely-comment-red {
      background-color: #FFCACA;
      background-position: -176px 0;
    }
    .editor .writely-comment-red-hover {
      background-color: #FF7A7A;
      background-position: -160px 0;
    }

    .editor .writely-comment-marker {
      background-image: url('MISSING');
      background-color: transparent;
      padding-right: 11px;
      background-repeat: no-repeat;
      width: 16px;
      height: 16px;
      -moz-user-select: none;
    }

    .editor .writely-comment-hidden {
      padding: 0;
      background: none;
    }
    .editor .writely-comment-marker-hidden {
      background: none;
      padding: 0;
      width: 0;
    }
    .editor .writely-comment-none {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
    .editor .writely-comment-none-hover {
      opacity: .2;
      filter:progid:DXImageTransform.Microsoft.Alpha(opacity=20);
      -moz-opacity: .2;
    }
  


  
  .br_fix br:not(:-moz-last-node):not(:-moz-first-node) {
    
    position:relative;
    
    left: -1ex
    
  }
  
  .br_fix br+br {
    position: static !important
  }
}

h6 { font-size: 8pt }
h5 { font-size: 8pt }
h4 { font-size: 10pt }
h3 { font-size: 12pt }
h2 { font-size: 14pt }
h1 { font-size: 18pt }

blockquote {padding: 10px; border: 1px #DDD dashed }

a img {border: 0}

.pb {
  border-width: 0;
  page-break-after: always;
  /* We don't want this to be resizeable, so enforce a width and height
     using !important */
  height: 1px !important;
  width: 100% !important;
}

.editor .pb {
  border-top: 1px dashed #C0C0C0;
  border-bottom: 1px dashed #C0C0C0;
}

div.google_header, div.google_footer {
  position: relative;
  margin-top: 1em;
  margin-bottom: 1em;
}


/* Table of contents */
.editor div.writely-toc {
  background-color: #f3f3f3;
  border: 1px solid #ccc;
}
.writely-toc > ol {
  padding-left: 3em;
  font-weight: bold;
}
ol.writely-toc-subheading {
  padding-left: 1em;
  font-weight: normal;
}
/* IE6 only */
* html writely-toc ol {
  list-style-position: inside;
}
.writely-toc-none {
  list-style-type: none;
}
.writely-toc-decimal {
  list-style-type: decimal;
}
.writely-toc-upper-alpha {
  list-style-type: upper-alpha;
}
.writely-toc-lower-alpha {
  list-style-type: lower-alpha;
}
.writely-toc-upper-roman {
  list-style-type: upper-roman;
}
.writely-toc-lower-roman {
  list-style-type: lower-roman;
}
.writely-toc-disc {
  list-style-type: disc;
}

/* Ordered lists converted to numbered lists can preserve ordered types, and
   vice versa. This is confusing, so disallow it */
ul[type="i"], ul[type="I"], ul[type="1"], ul[type="a"], ul[type="A"] {
  list-style-type: disc;
}

ol[type="disc"], ol[type="circle"], ol[type="square"] {
  list-style-type: decimal;
}

/* end default css */


  /* default print css */
  
  @media print {
    body {
      padding: 0;
      margin: 0;
    }

    div.google_header, div.google_footer {
      display: block;
      min-height: 0;
      border: none;
    }

    div.google_header {
      flow: static(header);
    }

    /* used to insert page numbers */
    div.google_header::before, div.google_footer::before {
      position: absolute;
      top: 0;
    }

    div.google_footer {
      flow: static(footer);
    }

    /* always consider this element at the start of the doc */
    div#google_footer {
      flow: static(footer, start);
    }

    span.google_pagenumber {
      content: counter(page);
    }

    span.google_pagecount {
      content: counter(pages);
    }


    callout.google_footnote {
      
      display: prince-footnote;
      footnote-style-position: inside;
      /* These styles keep the footnote from taking on the style of the text
         surrounding the footnote marker. They can be overridden in the
         document CSS. */
      color: #000;
      font-family: Verdana;
      font-size: 10.0pt;
      font-weight: normal;
    }

    /* Table of contents */
    #WritelyTableOfContents a::after {
      content: leader('.') target-counter(attr(href), page);
    }

    #WritelyTableOfContents a {
      text-decoration: none;
      color: black;
    }
  }

  @page {
    @top {
      content: flow(header);
    }
    @bottom {
      content: flow(footer);
    }
    @footnotes {
      border-top: solid black thin;
      padding-top: 8pt;
    }
  }
  /* end default print css */


/* custom css */


/* end custom css */

/* ui edited css */

body {
  font-family: Verdana;
  
  font-size: 10.0pt;
  line-height: normal;
  background-color: #ffffff;
}
/* end ui edited css */


/* editor CSS */
.editor a:visited {color: #551A8B}
.editor table.zeroBorder {border: 1px dotted gray}
.editor table.zeroBorder td {border: 1px dotted gray}
.editor table.zeroBorder th {border: 1px dotted gray}


.editor div.google_header, .editor div.google_footer {
  border: 2px #DDDDDD dashed;
  position: static;
  width: 100%;
  min-height: 2em;
}

.editor .misspell {background-color: yellow}

.editor .writely-comment {
  font-size: 9pt;
  line-height: 1.4;
  padding: 1px;
  border: 1px dashed #C0C0C0
}


/* end editor CSS */

</style>

  
  <title>network API Semantics</title>

</head>

<body 
    
    >
    
    
    
<div style=MARGIN-LEFT:40px>
  <br>
</div>
<font size=5><u><b>openconn(ip,port,localIP=None,localPort=None,timeout=) </b></u></font><br>
<br>
&nbsp;<br>
<font size=3><u>Interacts with</u>:</font><br>
<br>
socketlikeobj.close()<br>
openconn()<br>
getmyip()<br>
<div style=MARGIN-LEFT:40px>
  <br>
</div>
<font size=3><u>Argument semantics:&nbsp; (not currently tested)</u></font><br>
&nbsp;<br>
IP / localIP is a string or a TypeError is thrown.<br>
<br>
Port / localPort is an int between 1 and 65535 (inclusive), or a TypeError is thrown.<br>
<br>
Timeout is an int and is greater than zero or is none, or a TypeError is thrown.<br>
<br>
Both localPort and localIP are specified, or both are none, or an exception is thrown<br>
&nbsp;&nbsp;<br>
If localIP and localPort are specified, the IP is checked against the allowed IP /interface list.&nbsp; If the IP specified is in th elist an attempt to bind to the port is made.&nbsp; If the IP is not in the allowed list an exception is thrown.<br>
<br>
If localIP and localPort are not specified, the IP that would be returned from getmyip() is used.&nbsp;<b> The port is the lowest port without an open connection with this (remoteIP, remoteport, localIP, localport) tuple.</b><br>
<br>
<div style=MARGIN-LEFT:40px>
  <br>
</div>
<u><font size=3>Behavioral Semantics:<br>
</font><br>
<br>
</u>1<br>
<u>Action</u>: The timeout specified expires prior to a successful connection being made or some other exception occurring.<br>
<u>Result</u>:&nbsp; An exception is thrown.<br>
<span style=BACKGROUND-COLOR:#ffffff>(tested - openconn_timeout.py, run with echo_server.py deployed on 3 WAN nodes)</span><br style=BACKGROUND-COLOR:#ffffff>
<span style=BACKGROUND-COLOR:#ffffff><u>Test Snippet</u>:<br>
<br>
</span>
<div style=MARGIN-LEFT:40px>
  <span style=BACKGROUND-COLOR:#ffffff>try:<br>
  &nbsp; openconn(ip,port,timeout=1)<br>
  except:<br>
  &nbsp; pass<br>
  else:<br>
  &nbsp; test_fail()<br>
  <br>
  <br>
  </span>
</div>
2<br>
<u>Action</u>:&nbsp; An openconn is performed with a port and IP specified at which there is no listener to receive the connection.<br>
<div>
  <u>Result</u>:&nbsp; An exception is thrown.<br>
  (tested - openconn_no_listener1.py&nbsp; AND openconn_no_listener2.py AND openconn_no_listnener3.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    try:<br>
    &nbsp; openconn(ip,waitport)<br>
    except Exception:<br>
    &nbsp; pass<br>
    else:<br>
    &nbsp; fail_test()<b> &nbsp;&nbsp; </b><br>
  </div>
  <br>
  3<br>
  &nbsp;<u>Action</u>:&nbsp; openconn is called with localIP and localPort that is currently used by a waitforconn<br>
  &nbsp;<u>Result</u>:&nbsp; No exception should occur.<br>
  &nbsp;(tested - openconn_same_port_as_waitforconn.py )<br>
  <span style=BACKGROUND-COLOR:#ff0000>&nbsp;</span><b><span style=BACKGROUND-COLOR:#ff0000>TEST FAILS</span><br>
  &nbsp;</b><u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    handle_local = waitforconn(ip,waitport,do_nothing)<br>
  </div>
  <div style=MARGIN-LEFT:40px>
    sock = openconn(remoteip,remoteport,ip,waitport)&nbsp;&nbsp;
  </div>
  <br>
  &nbsp;<br>
  4<br>
  <u>Action:</u>&nbsp; openconn is called, then close() is called on the returned socket, then openconn is called with identical arguments.<br>
  <u>Result</u>:&nbsp; no exception occurs.<br>
  <span style=BACKGROUND-COLOR:#ff0000>replicated by close_blocks.py&nbsp;&nbsp; </span><b style=BACKGROUND-COLOR:#ff0000>(fails)</b><br>
  <u>Test Snippet</u>:<br>
  <div style=MARGIN-LEFT:80px>
    <br>
  </div>
  <div style=MARGIN-LEFT:40px>
    sock = openconn(ip,port)<br>
    sock.close()<br>
    sock2 =openconn(ip,port)<br>
  </div>
  <br>
  5<br>
  <u>Action</u>: openconn is called, then another openconn is called with identical arguments (where localIP and localPort are specified).<br>
  <u>Result:</u> an exception occurs.<br>
  (tested by -&nbsp; openconn_duplicate_4tuple.py)<br>
  <u>Test Snippet:</u><br>
  <br>
  <div style=MARGIN-LEFT:40px>
    sock1 = openconn(ip,port,ipA,portA)<br>
    try:<br>
    &nbsp; sock2 = openconn(ip,port,ipA,portA)<br>
    except Exception:<br>
    &nbsp;&nbsp; pass<br>
    else:<br>
    &nbsp;&nbsp; test_fail()<br>
  </div>
  <div style=MARGIN-LEFT:80px>
    <br>
  </div>
  <br>
  6<br>
  <u>Action:</u>&nbsp; openconn is called any number of times with a unique 4 tuple each time.<br>
  <u>Result:</u>&nbsp; no exception occurs.<br>
  (tested - .._diff_remote_ports.py)<br>
  (tested - .._diff_local_ports.py)<br>
  <span style=BACKGROUND-COLOR:#ffffff>(tested - .._diff_local_ip.py)</span><br>
  (tested - echo_server.py and ... openconn_diff_remote_ip_2SERVERS.py,&nbsp; (tested across a network))<br>
  <u>Test Snippet:</u><br>
  <div style=MARGIN-LEFT:40px>
    <br>
  </div>
  <div style=MARGIN-LEFT:40px>
    sock1 = openconn(A,B,C,D)<br>
    sock2 = openconn(E,B,C,D)<br>
    etc....<br>
  </div>
  <div style=MARGIN-LEFT:80px>
    <br>
    <br>
  </div>
  <br>
  7<br>
  <u>Action</u>:&nbsp; openconn is called simultaneously in two separate events.<br>
  <u>Result</u>:&nbsp; Events will behave as if the two calls had executed in some serial order.<br>
  <span style=BACKGROUND-COLOR:#ffffff>(no test)</span><br>
  <b><br>
  <u><br>
  <font size=5><br>
  waitforconn(localip, localport, function)</font></u></b><br>
  <u><font size=3><br>
  <br>
  Interacts with:<br>
  <br>
  </font></u><font size=3><font size=2>stopcomm()<br>
  waitforconn()<br>
  </font></font><u><font size=3><br>
  <br>
  Argument semantics:&nbsp; (not currently tested)</font></u><br>
  <br>
  The localIP specified is a string or an Exception occurs.<br>
  <br>
  The localPort specified is an int in the range between 1 and 65535 (inclusive) or an Exception occurs.<br>
  <br>
  The function specified is the name of the call back function and has arguments (remoteip,remoteport,socklikeobj,thiscommhandle,listencommhandle) or an Exception occurs.<br>
  <br>
  <br>
  <font size=3><u>Behavioral Semantics:</u></font><br>
  <br>
  1<br>
  <u>Action</u>:&nbsp; waitforconn is called on an unused port with a valid function.<br>
  <u>Result</u>:&nbsp; a listener is registered.<br>
  (tested- waitforconn_basic.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    handle = waitforconn(ip,port,callback)<br>
  </div>
  <br>
  <u><br>
  2<br>
  Action</u>:&nbsp; waitforconn is called on a port being used by another waitforconn<br>
  <u>Result</u>:&nbsp; No exception occurs, the callback function is replaced.&nbsp;<br>
  (tested - waitforconn_used_port1.py)&nbsp;&nbsp; <u><br>
  Test Snippet</u>:&nbsp;<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    waitforconn(ip,port,callback1)<br>
    waitforconn(ip,port,callback2)<br>
    performcallbacktest()<br>
    <br>
    <br>
  </div>
  <br>
  3<br>
  <u>Action</u>:&nbsp; A waitforconn is called, and the replaced by a newer waitforconn.&nbsp; Stopcomm is called on the original commhandle.<br>
  <u>Result</u>: Nothing.&nbsp; The waitforconn remains active.<br>
  (tested - waitforconn_unique_handle.py)&nbsp;&nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff0000>FAILS</span><br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    old_handle = waitforconn(ip,port,old_func)<br>
    new_handle= waitforconn(ip,port,new_func)<br>
    stopcomm(old_handle)<br>
    test_new_func()<br>
  </div>
  <div style=MARGIN-LEFT:40px>
    <br>
  </div>
  <br>
  <br>
  4<br>
  <u>Action</u>:&nbsp; waitforconn is called on a port being used by a socket (openconn).<br>
  <u>Result</u>:&nbsp; no exception occurs<br>
  (tested - waitforconn_used_port2.py)<br>
  <u>Test Snippet</u><b>:<br>
  <br>
  </b>
  <div style=MARGIN-LEFT:40px>
    openconn(remote_ip,remote_port,ip,port)<br>
    waitforconn(ip,port,callback)&nbsp;&nbsp;
  </div>
  <br>
  <br>
  5<br>
  <u>Action</u>:&nbsp; waitforconn is called successfully, then stopcomm is called on "thiscommhandle" from the call back arguments.<br>
  <u>Result</u>:&nbsp; The corresponding socketlikeobj is closed, the listener remains active<br>
  (tested - waitforconn_stop_thiscommhandle.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    callback(remoteip,remoteport,sock,thiscommhandle,listencommhandle):<br>
    stopcomm(thiscommhandle)<br>
    <br>
  </div>
  <br>
  <br>
  6<br>
  <u>Action</u>:&nbsp; waitforconn is called successfully, then a stopcomm is called on the returned comm handle or the listencommhandle from the callback arguments.<br>
  <u>Result</u>:&nbsp; The listener is stopped and further connections are not accepted.&nbsp; Connections being processed continue unaffected.<br>
  (tested - waitforconn_stopcomm1.py&nbsp; AND&nbsp;&nbsp; - waitforconn_stopcomm2.py )&nbsp;&nbsp;&nbsp; &nbsp;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    handle = waitforconn(ip,port,callback)&nbsp;&nbsp;<br>
    stopcomm(handle)<br>
    try:<br>
    &nbsp; sock = openconn(ip,port)<br>
    except Exception:<br>
    &nbsp; pass<br>
    else:<br>
    &nbsp; test_fail()<br>
    <br>
  </div>
  <br>
  <br>
  7<br>
  <u>Action</u>:&nbsp; waitforconn is called successfully, then a stopcomm is called on the returned comm handle. Then an identical waitforconn is called.<br>
  <u>Result</u>:&nbsp; No exception occurs. The listener functions.<br>
  (tested - waitforconn_after_stopcomm.py)<br style=BACKGROUND-COLOR:#ff0000>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    handle = waitforconn(ip,port,func)<br>
    stopcomm(handle)<br>
    handle = waitforconn(ip,port,func)<br>
  </div>
  <br>
  <br>
  <br>
  8<br>
  <u>Action</u>:&nbsp; A connection is made to the waitforconn, while the first connection is being processed another connection is made.<br>
  <u>Result</u>:&nbsp; No exception occurs, another event is used to call the callback function and process the new connection.<br>
  (tested - waitforconn_multievents.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    handle = waitforconn(ip,port,func)&nbsp;&nbsp; #func is a long running routine<br>
    sock1 = openconn(ip,port)<br>
    sock2 = openconn(ip,port)<br>
    <br>
  </div>
  <br>
  <br>
  9<br>
  <u>Action</u>:&nbsp; There are no free events available and a connection is made to a port with an active listener (waitforconn was called)<br>
  <u>Result</u>: &nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ffffff>The callback function is called when a event becomes available</span><br>
  (tested - waitforconn_max_events_1SERVER.py ,&nbsp; works in conjunction with echo_server.py)<br>
  <u>Test Snippet</u>:<br>
  &nbsp;<br>
  <div style=MARGIN-LEFT:40px>
    #open connections to consume all available events on the echo server<br>
    settimer(3,free_an_event,[])&nbsp; #closes a socket to free an event<br>
    settimer(10,fail_test,[]) #timeout if the event is never processed<br>
    sock = openconn(ip,port)<br>
    sock.send('ping')<br>
    msg = sock.recv()<br>
    if an_event_was_not_freed:<br>
    &nbsp; fail_test()<br>
  </div>
  <br>
  <br>
  10<br>
  <u>Action</u>:&nbsp; All free events are consumed and a call to waitforconn is made.<br>
  <u>Result</u>: An exception occurs.<br>
  (tested test_waitforconn_no_free_events.py)&nbsp; <span style=BACKGROUND-COLOR:#ff0000>FAILS, waitforconn is blocking until an event is free</span><br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    #consume all free events<br>
    handle = settimer(5,fail_test,[])<br>
    try:<br>
    &nbsp; waitforconn(ip,port,func)<br>
    except:<br>
    &nbsp; canceltimer(handle)<br>
    else:<br>
    &nbsp; print 'no exception occurs'<br>
  </div>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
  <br>
  11<br>
  <u>Action</u>:&nbsp; waitforconn is called simultaneously in two separate events.<br>
  <u>Result</u>:&nbsp; Each event behaves as if the two calls were performed in a serial order.<br>
  <span style=BACKGROUND-COLOR:#ffffff>(no test)</span><br>
  <u>Test Snippet</u>:<br>
  <font size=5><b><br>
  <br>
  <u>Socket like object&nbsp; -&nbsp; Send(message)</u><br>
  </b></font><br>
  <br>
  <font size=3><u>Interacts with:<br>
  </u><font size=2><br>
  socketlikeobj.close()<br>
  <br>
  </font></font><br>
  <u><font size=3>Argument semantics:&nbsp; (not currently tested)</font></u><br>
  &nbsp;<br>
  The message provided is a string or an exception occurs.<br>
  <br>
  <u><font size=3><br>
  Behavioral Semantics</font></u><br>
  <br>
  1<br>
  <u>Action</u>:&nbsp; A call to sock.send(msg) is made, where msg is smaller than free space in internal buffers.<br>
  <u>Result</u>:&nbsp; The message is copied to internal buffers and send returns the number of characters sent. (non-blocking)<br>
  (tested - send_not_blocking.py) <span style=BACKGROUND-COLOR:#ffff00><br>
  <span style=BACKGROUND-COLOR:#ffffff><u>Test Snippet</u>:<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h = settimer(1,test_fail,[])<br>
  </span></span>
  <div style=MARGIN-LEFT:40px>
    <span style=BACKGROUND-COLOR:#ffff00><span style=BACKGROUND-COLOR:#ffffff>length = sock.send(msg)<br>
    canceltimer(h)<br>
    if length != len(msg):<br>
    &nbsp; test_fail()<br>
    </span></span>
  </div>
  <br>
  2<br>
  <u>Action</u>:&nbsp; A call to sock.send(msg) is made, where msg is larger than free space in internal buffers.<br>
  <u>Result</u>:&nbsp; The call to send blocks and does not return until there is enough free buffer space for the entire message.<br>
  (tested - send_blocks.py)&nbsp;<br>
  <u>Test Snippet</u>:<br>
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #send eventually blocks and the timer ends the test, otherwise the test fails<br>
  <div style=MARGIN-LEFT:40px>
    &nbsp;timerhandle = settimer(12,stop_test,[handle,sock])<br>
    &nbsp; for i in range(1024):&nbsp;&nbsp; #send until eventually it blocks<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sock.send(file_data)<br>
    &nbsp; print 'exited for loop without send blocking'<br>
    <br>
  </div>
  <br>
  3&nbsp;&nbsp;&nbsp;<br>
  <u>Action</u>:&nbsp; A call to send is made after close() is called.<br>
  <u>Result</u>:&nbsp; An exception occurs.<br>
  (tested - send_self_close.py )<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    sock.close()<br>
    try:<br>
    &nbsp; sock.send(msg)<br>
    except Exception:<br>
    &nbsp; pass<br>
    else:<br>
    &nbsp; test_fail()<br>
  </div>
  &nbsp;<br>
  <br>
  4<br>
  <u>Action</u>:&nbsp; A call to send is made after close() has been called on the peer socket.<br>
  <u>Result</u>:&nbsp; Behavior is timing dependent.&nbsp; If sufficient time has elapsed an exception occurs indicating that the connection is closed.<br>
  (tested - send_peer_close1.py,<span style=BACKGROUND-COLOR:#ff0000> FAILS<br>
  </span>(tested- test<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    #remote connection is closed then..<br>
    sleep(3) #ensure sufficient time elapsed<br>
    try:<br>
    &nbsp; sock.send(msg)<br>
    except Exception:<br>
    &nbsp; pass<br>
    else:<br>
    &nbsp; test_fail()<br>
  </div>
  <br>
  <br>
  5<br>
  <u>Action</u>:&nbsp; Internal buffers are full and a call to send is made, which results in a blocking operation.&nbsp; While the call is blocking close is called on the peer socket.<br>
  <u>Result</u>:&nbsp; An exception occurs.<br>
  (tested - send_peer_close2.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    try:<br>
    &nbsp; sock.send(hugemsg)&nbsp;&nbsp; #close is called on peer socket while this call is blocking<br>
    except Exception:<br>
    &nbsp; pass<br>
    &nbsp;else:<br>
    &nbsp;&nbsp;&nbsp; test_fail()<br>
  </div>
  <br>
  6<br>
  <u>Action</u>:&nbsp; Two or more calls to send are made simultaneously in separate events.<br>
  <u>Result</u>:&nbsp; Behavior is as if all calls were performed in some serial order.&nbsp; Strings sent from separate events are NOT interleaved.&nbsp; Ordering of calls is no defined.<br>
  <span style=BACKGROUND-COLOR:#ffffff>(no test)</span><br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <b><br>
  <u><font size=5>socketlikeobj.recv(int length)</font></u></b><br>
  <font size=3><u><br>
  Interacts with:<br>
  <br>
  </u><font size=2>socketlikeobj.close()<br>
  <br>
  </font><u><br>
  Argument Semantics: (not tested)</u></font><br>
  &nbsp;<br>
  The length provided is an int and is greater than 0, or an Exception occurs.<br>
  <br>
  <br>
  <u><font size=3>Behavioral Semantics:<br>
  <br>
  <br>
  </font></u><font size=3><font size=2>1</font></font><u><font size=3><br>
  <font size=2>Action</font></font></u><font size=2>:&nbsp; The internal buffer is empty and recv is called.<br>
  <u>Result</u>:&nbsp; The call blocks until some characters arrive in the buffer.</font><br>
  (tested - recv_blocks.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    settimer(5,pass_test,[])<br>
    msg = sock.recv()<br>
    fail_test()<br>
  </div>
  <br>
  <br>
  2<br>
  <u>Action</u>:&nbsp; There are bytes ready to be read and recv(N) is called.<br>
  <u>Result</u>:&nbsp; Some number of bytes &lt;= N will .<br>
  (tested - recv_some.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    msg = sock.recv(n)<br>
    if len(msg) &gt; n:<br>
    &nbsp; test_fail()<br>
  </div>
  <br>
  <div style=MARGIN-LEFT:40px>
    <br>
  </div>
  <br>
  <br>
  3<br>
  <u>Action</u>:&nbsp; There are no characters in the internal buffer and a call to recv is performed.&nbsp; Sometime later a string of length N is received by the buffer.<br>
  <u>Result</u>:&nbsp; Some number of characters that is less than or equal to N is returned.<br>
  (tested - test_recv_while_blocking.py)<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    msg = recv(5)&nbsp;&nbsp; #buffer is empty, the call blocks, then "hello" is sent by the peer<br>
    if len(msg) &gt; 5:<br>
    &nbsp; test_fail()<br>
  </div>
  <br>
  <br>
  <br>
  4<br>
  <u>Action</u>:&nbsp; close() is called on the peer socketobj, and then recv is called on the local socketobj.<br>
  <u>Result</u>: Characters remaining in the buffer are returned as if close() had not been called.&nbsp; When there are no characters remaining the<span style=BACKGROUND-COLOR:#ffffff> an exception is thrown.</span><br>
  (tested recv_peer_close.py)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff0000>FAILS</span><br>
  (tested recv_peer_close2.py)&nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff0000>FAILS</span><br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    # peer connection&nbsp; calls close()<br>
    msg ='a'<br>
    h = settimer(2,test_fail,[])<br>
    while msg is not '':<br>
    &nbsp; msg = sock.recv(n)<br>
    canceltimer(h)<br>
  </div>
  <div style=MARGIN-LEFT:40px>
    <br>
    Note: this&nbsp; test shows that eventually '' is returned, and no exceptions are thrown.&nbsp; These are the necessary conditions to implement this semantic requirement.<br>
    <br>
  </div>
  <br>
  5<br>
  <u>Action</u>:&nbsp; close is called on a socketobj, and then recv is called.<br>
  <u>Result</u>:&nbsp; an exception occurs<br>
  (tested - recv_self_close.py&nbsp; not blocking call,&nbsp; tested - test_recv_after_self_close_2.py&nbsp; blocking call to recv) &nbsp;<br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    sock.close()<br>
    try:<br>
    &nbsp; sock.recv(n)<br>
    except Exception:<br>
    &nbsp; pass<br>
    else:<br>
    &nbsp; test_fail()<br>
  </div>
  <br>
  <br>
  6<br>
  <u>Action</u>:&nbsp; recv is called simultaneously in two more more events.<br>
  <u>Result</u>:&nbsp; Behavior in each event is as if each call to recv was performed in some serial order.&nbsp; The exact ordering which will occur is not defined.<br>
  <span style=BACKGROUND-COLOR:#ffffff>(no test)</span><br>
  <u>Test Snippet</u>:<br>
  <br>
  <br>
  <font size=5>&nbsp;&nbsp;<br>
  <u><b>socketlikeobj.close()</b></u></font><br>
  <br>
  <u><font size=3>Interacts with:</font></u><br>
  <br>
  openconn()<br>
  socket.send()<br>
  socket.recv()<br>
  <br>
  <u><font size=3>Argument Semantics:</font></u><br>
  &nbsp; None<br>
  <u><font size=3><br>
  Behavioral Semantics:</font></u><br>
  <br>
  <br>
  1<br>
  <u>Action</u>:&nbsp; close() is called on an unopen connection<br>
  <u>Result</u>:&nbsp; No exception occurs, False is returned.<br>
  (tested - close_closed.py)&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS DUE TO NO RETURN VALUE</span><br>
  <u>Test Snippet</u>:<br>
  <br>
  <div style=MARGIN-LEFT:40px>
    sock = openconn(...)&nbsp;<br>
    sock.close()<br>
    value = sock.close()<br>
    if value is not False:<br>
    &nbsp; fail_test()<br>
    <br>
  </div>
  2<br>
  <u>Action</u>:&nbsp; A call to close is performed<br>
  <u>Result</u>:&nbsp; The call blocks until the connection is closed and the ip/port used can be successfully reused.&nbsp; True is returned<br>
  (tested close_blocks.py )&nbsp; <span style=BACKGROUND-COLOR:#ff0000> FAILS call does not block, and no return value</span><br>
  <u>Test Snippet</u>:&nbsp;<br>
  &nbsp;<br>
  <div style=MARGIN-LEFT:40px>
    sock=openconn(ip,port)<br>
    value = sock.close()<br>
    sock =openconn(ip,port)<br>
    if value is not True:<br>
    &nbsp; fail_test()<br>
    <br>
  </div>
  <br>
  3<br>
  <u>Action</u>:&nbsp; close() is called simultaneously in more than one thread.<br>
  <u>Result</u>:&nbsp; Each thread will behave is if it closed the connection<br>
  <span style=BACKGROUND-COLOR:#ffffff>(no test) </span><br>
  <br>
  <u><b><font size=5><br>
  <br>
  <br>
  <br>
  stopcomm(commhandle)</font></b></u><br>
  <br>
  <br>
</div>
<u><font size=3>Interacts With</font></u><font size=3>:<br>
</font><br>
waitforconn(..)<br>
<br>
<u><font size=3>Argument Semantics</font></u>:<br>
<br>
The commhandle specified is a commhandle or an exception occurs.<br>
<font size=3><u><br>
Behavioral Semantics</u></font>:<br style=BACKGROUND-COLOR:#ffff00>
<br>
1<br>
<u>Action</u>: Stopcomm is called on a valid commhandle.<br>
<u>Resul</u>t: The listener associated with the commhandle is stopped.&nbsp; Stopcomm returns True.<br>
(tested - stopcomm_basic.py)&nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS, due to return value only<br>
</span>(tested - stopcomm_basic2.py)&nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS, due to return value only</span><br>
<u>Test Snippet</u>:&nbsp;<br>
<br>
<div style=MARGIN-LEFT:40px>
  handle = waitforconn(ip,port,func)<br>
  stopped = stopcomm(handle)<br>
  if stopped is not True:<br>
  &nbsp; test_fail()<br>
  test_callback_is_stopped()<br>
  <br>
</div>
2<br>
<u>Action</u>: Stopcomm is called twice on the same commhandle.<br>
<u>Result</u>: No exception occurs, stopcomm returns False on the second attempt.<br>
(tested - stopcomm_duplicate.py) &nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS, due to no return value<br>
</span>(tested - stopcomm_duplicate2.py)&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS, due to no return value</span><br>
<u>Test Snippet:<br>
<br>
</u>
<div style=MARGIN-LEFT:40px>
  handle = waitforconn(ip,port,func)<br>
  stopcomm(handle)<br>
  stopped = stopcomm(handle)<br>
  if stopped is not False:<br>
  &nbsp; test_fail()<br>
  <br>
</div>
<br>
3<br>
<u>Action</u>:&nbsp; Stopcomm is called on&nbsp; an invalid commhandle (a newer waitforconn has replaced it).<br>
<u>Result</u>:&nbsp; No exception occurs, stopcomm returns False.<br>
(tested - stopcomm_invalid_handle.py)&nbsp; &nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS, due to no return value<br>
</span>(tested - stopcomm_invalid_handle2.py)&nbsp;&nbsp; <span style=BACKGROUND-COLOR:#ff9900>FAILS, due to no return value</span><br>
<u>Test Snippet:</u><br>
<br>
<div style=MARGIN-LEFT:40px>
  &nbsp; handle = waitforconn(ip,waitport,echo)<br>
  &nbsp; new_handle = waitforconn(ip,waitport,do_nothing)<br>
  &nbsp; stopped = stopcomm(handle)<br>
  &nbsp; if (stopped is not False):<br>
  &nbsp;&nbsp;&nbsp; print 'Stopcomm did not return False' &nbsp;<br>
  &nbsp;<br>
  <br>
</div>
4<br>
<u>Action</u>:&nbsp; Stopcomm is called simultaneously in multiple events.<br>
<u>Result</u>:&nbsp; Behaves as if each call occured in some serial order.<br>
<span style=BACKGROUND-COLOR:#ffffff>(no test)</span><br>
<br>
<u><font size=5><br>
<br>
<br>
<br>
gethostbyname_ex(name)</font></u><br>
<br>
<u><font size=3>Interacts With</font></u>:<br>
<br>
None<br>
<br>
<font size=3><u>Argument Semantics</u></font>:<br>
<br>
The name specified is a string or an exception occurs.<br>
<br>
<u><font size=3>Behavioral Semantics</font></u>:<br>
<br>
<br>
1<br>
<u>Action</u>:&nbsp; A call is made to get hostbyname_ex(name)&nbsp; with a valid host name.<br>
<u>Result</u>:&nbsp; A tuple containing information about the host name is returned, or a netowork error occurs.<br>
(tested - gethost_basic.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  (one,two,three) = gethostbyname_ex(host)<br>
</div>
<br>
<br>
2<br>
<u>Action</u>:&nbsp; A call is made to get hostbyname with an invalid host name.<br>
<u>Result</u>:&nbsp; An exception occurs.<br>
(tested - gethost_invalid.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  try:<br>
  &nbsp; gethosbyname_ex(invalid_host)<br>
  except:<br>
  &nbsp; pass<br>
  else:<br>
  &nbsp; fail()<br>
</div>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<u><font size=5>getmyip()</font></u><br>
<br>
<u><font size=3>Interacts With</font></u>:<br>
<br>
openconn<br>
sendmess<br>
<br>
<u><font size=3>Argument Semantics</font></u>:<br>
<br>
None<br>
<br>
<u><font size=3>Behavioral Semantics</font></u>:<br>
<br>
<br>
<u>Action</u>:&nbsp; A call to getmyip() is made while the perferred IP or interface is attached to a network.<br>
<u>Result</u>:&nbsp; The IP (or the IP of the perferred interface) is returned and can be used to communicate over the network.<br>
(tested - getmyip_basic.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  #run the echo_serever on another node<br>
  openconn(rip,geniport,getmyip(),geniport)<br>
  #verify connection<br>
</div>
<br>
<br>
<br>
<u>Action</u>:&nbsp; A call to getmyip() is made while not connected to a network.<br>
<u>Result</u>:&nbsp; An exception occurs.<br>
(tested - getmyip_no_connection.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  #run while not connected to a network<br>
  try:<br>
  &nbsp; getmyip()<br>
  except:<br>
  &nbsp; pass<br>
  else:<br>
  &nbsp; fail()<br>
</div>
<br>
<a href=https://seattle.cs.washington.edu/wiki/RepyLibrary#gethostbyname_exname></a><br>
<u>Action</u>:&nbsp; getmyip() is called while the prefered interface/IP is not connected to the network, but other connections from the allowed list are connected to the network.<br>
<u>Result</u>:&nbsp; getmyip() returns the first connected interface/IP in the list, and will continue to reutrn this IP for the duration of the program or until it becomes invalid.<br>
<span style=BACKGROUND-COLOR:#ffffff>(NOT TESTED)</span><br>
<br>
<u><font size=5><br>
<br>
<br>
<br>
recvmess(localip,localport,function)</font></u><br>
<br>
<u><font size=3>Interacts With</font></u>:<br>
<br>
recvmess(..)<br>
stopcomm<br>
<br>
<u><font size=3>Argument Semantics</font></u>:<br>
<br>
The locaip specified is a string or an exception occurs.<br>
The localport specified is an int between 1 and 65535 (inclusive), of an exception occurs.<br>
<font size=3><font size=2>The function specified is a function with arguments (remoteip, remoteport,message,commhandle)or an exception occurs)</font><br>
</font><u><font size=3><br>
<br>
Behavior Semantics</font></u>:<br>
<br>
1<br>
<u>Action</u>:&nbsp; A recvmess has been called and a UDP message arrives at the specified port.<br>
<u>Result</u>:&nbsp; As soon as an event becomes free the call back function specified is executed and the message is processed.<br>
(test&nbsp; - tested recvmess_basic.py)<br>
<u>Test Snippet</u>:<br>
&nbsp;<br>
<div style=MARGIN-LEFT:40px>
  recvmess(ip,port,func)<br>
  sendmess(ip,port,msg)<br>
  test_msg_proccessed()<br>
</div>
<br>
<br>
2<br>
<u>Action</u>:&nbsp; A recvmess has been called on the same ip / port as a waitforconn, and A TCP message arrives.<br>
<u>Result</u>:&nbsp; The recvmess callback function is not executed.<br>
(tested - recvmess_waitforconn1.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  recvmess(ip,port,func)<br>
  sock.send(msg)<br>
  test_msg_not_processed()<br>
</div>
<br>
<br>
3<br>
Action:&nbsp; A recvmess has been called on the same ip/port as a waitforconn, and a UDP message arrives.<br>
Result:&nbsp; The recvmess callback function is executed and the message is processed.<br>
(tested - recvmess_waitforconn2.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  waitforconn(ip,port,foo)<br>
</div>
<div style=MARGIN-LEFT:40px>
  recvmess(ip,port,func)<br>
  sendmess(ip,port,msg)<br>
  test_msg_processed()<br>
</div>
<br>
<br>
4<br>
<u>Action</u>: Recvmess is called on the same ip / port as a previous recvmess.<br>
<u>Result</u>: The call back function is replaced and a new commhandle is returned.<br>
(tested - recvmess_duplicate1.py, this tests that the callback function is replaced)<br>
(tested - recvmess_duplicate2.py, this tests that the commhandle returned is uniqe)&nbsp; <font size=2 style=BACKGROUND-COLOR:#ff0000>FAILS</font><br>
<u>Test Snippet</u>:<br>
<div style=MARGIN-LEFT:40px>
  <br>
  (test 1)<br>
</div>
<div style=MARGIN-LEFT:40px>
  recvmess(ip,port,old)<br>
  recmess(ip,port,new)<br>
  sendmess(ip,port,msg)<br>
  test_msg_processed()<br>
  <br>
  (test 2)<br>
  old_handle = recvmess(ip,port,old)<br>
  new_handle = recvmess(ip,port,new)<br>
  stopcomm(old_handle)<br>
  sendmess(ip,port,msg)<br>
  test_msg_processed()<br>
</div>
<br>
<br>
<br>
5<br>
<u>Action</u>:&nbsp; Stopcomm has been called on the recvmess commhandle and a UDP message is recivied.<br>
<u>Result</u>:&nbsp; The message is not processed.<br>
(tested recvmess_stopcomm.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  handle = recvmess(ip,port,fail_test)<br>
  stopcomm(handle)<br>
  sendmess(ip,port,msg)<br>
  <br>
</div>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<u><font size=5>sendmess(desthost,destport,message,localip=None,localport=None)</font></u><br>
<u><font size=3><br>
<br>
Interacts With</font></u>:<br>
<br>
None<br>
<br>
<u><font size=3>Argument Semantics</font></u>:<br>
<br>
<br>
The desthost/localip specified is a string, or an exception occurs.&nbsp; (can be an ip address or valid host name)<br>
<br>
The destport/localport specified is an int between 1 and 65535 (inclusive), of an exception occurs.<br>
<br>
The message sepcified is a string or an exception occurs.<br>
<br>
If localIP and localPort are not specified, the IP that would be returned from getmyip() is used.&nbsp;<b> The port is the lowest port avaiable.</b><br>
<br>
<br>
<u><font size=3>Behavioral Semantics:</font></u><br>
<br>
1<br>
<u>Action</u>:&nbsp; The host name specified does not resolve into an address.<br>
<u>Result</u>:&nbsp; An exception occurs.<br>
(tested - sendmess_bad_host.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  try:<br>
  &nbsp;&nbsp;&nbsp; sendmess('notactuallyahost',port,'ping')<br>
  &nbsp; except:<br>
  &nbsp;&nbsp;&nbsp; pass<br>
  &nbsp; else:<br>
  &nbsp;&nbsp;&nbsp; print "using 'notactuallyahost' did not cause exception"<br>
</div>
<br>
<br>
2<br>
<u>Action</u>:&nbsp; A call sendmess completes succsessfully.<br>
<u>Result</u>:&nbsp; The number of bytes sent are returned.&nbsp;<br>
(tested sendmess_returns.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  &nbsp;x = sendmess('127.0.0.1',12345,"ping")<br>
  &nbsp;if x != 4:<br>
  &nbsp;&nbsp;&nbsp; print 'sendmess did not return correct value'<br>
</div>
<br>
<br>
3<br>
<u>Action</u>:&nbsp; Sendmess is called with a 4-tuple that is identical to an open socket connection.<br>
<u>Result</u>:&nbsp; There is no conflict, no exception occurs.<br>
(tested - sendmess_socket.py)<br>
<u>Test Snippet</u>:<br>
<br>
<div style=MARGIN-LEFT:40px>
  sock = openconn(ip,waitport,ip,port)<br>
  sendmess(ip,waitport,'ping',localip=ip,localport=port)<br>
</div>
<br>
<br>
4<br>
<u>Action</u>:&nbsp; Duplicate sendmess calls are made in seperate threads of execution<br>
<u>Result</u>:&nbsp; Behavior will be as if the calls were made in some serial order.<br>
(not tested)<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></body>
</html>
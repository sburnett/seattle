"""
<Program>
  builder.py

<Author>
  Jason Chen
  jchen@cs.washington.edu

<Started>
  September, 2009
  
<Purpose>
  Contains functions that are related to, or 
  directly involved with the building of the installers.
  
  This code is shared among the HTML and XMLRPC views of the custom installer creator service.
"""

import hashlib
import os
import sys
import subprocess
import shutil
import time

from django.http import HttpResponse
from django.core.servers.basehttp import FileWrapper

from custom_installer_website import settings
from custom_installer_website.common import validations

from seattle import repyhelper
from seattle import repyportability

repyhelper.translate_and_import("rsa.repy")

def _state_key_file_to_publickey_string(key_file_name):
  """
  Read a public key file from the the state keys directory and return it in
  a key string format.
  """
  fullpath = os.path.join(settings.STATE_KEYS_DIR, key_file_name)
  return rsa_publickey_to_string(rsa_file_to_publickey(fullpath))

KEY_GENERATION_BITSIZE = 1024
SEATTLE_OWNER_PUBKEY = "22599311712094481841033180665237806588790054310631222126405381271924089573908627143292516781530652411806621379822579071415593657088637116149593337977245852950266439908269276789889378874571884748852746045643368058107460021117918657542413076791486130091963112612854591789518690856746757312472362332259277422867 12178066700672820207562107598028055819349361776558374610887354870455226150556699526375464863913750313427968362621410763996856543211502978012978982095721782038963923296750730921093699612004441897097001474531375768746287550135361393961995082362503104883364653410631228896653666456463100850609343988203007196015297634940347643303507210312220744678194150286966282701307645064974676316167089003178325518359863344277814551559197474590483044733574329925947570794508677779986459413166439000241765225023677767754555282196241915500996842713511830954353475439209109249856644278745081047029879999022462230957427158692886317487753201883260626152112524674984510719269715422340038620826684431748131325669940064404757120601727362881317222699393408097596981355810257955915922792648825991943804005848347665699744316223963851263851853483335699321871483966176480839293125413057603561724598227617736944260269994111610286827287926594015501020767105358832476708899657514473423153377514660641699383445065369199724043380072146246537039577390659243640710339329506620575034175016766639538091937167987100329247642670588246573895990251211721839517713790413170646177246216366029853604031421932123167115444834908424556992662935981166395451031277981021820123445253"
# The key used as the state key for new donations.
ACCEPTDONATIONS_STATE_PUBKEY = _state_key_file_to_publickey_string("acceptdonation.publickey")

# Path to the customize_installers.py. In this case, it's in the same directory
# as this views.py file.
PATH_TO_CUSTOMIZE_INSTALLER_SCRIPT = os.path.join(os.path.dirname(__file__), 
                                                  "customize_installers.py")

# *** DO NOT CHANGE THE FOLLOWING FLAGS, THEY ARE USED BY TESTS ONLY ***
TEST_LOCK_RELEASE_DELAY = 0      # How long (sec) to wait before releasing the access lock.
TEST_RETURN_CHECK_RET = False    # Return cache check return code instead of sending a file

def prepare_installer(vessel_list, key_dict, build_id):
  """
  <Purpose>
    Prepares an installer build by setting up the necessary 
    directory structure and required vesselinfo file.
  
  <Arguments>
    vessel_list:
      A list of vessel dictionaries, each dict representing a defintion
      of a vessel. Follows the format:
      [ {owner, percentage, [users]}, {owner, percentage, [users]} ... ]
    
    key_dict:
      A dictionary whose keys are usernames, and whose 
      values are key dicts (pubkey & privkey). Follows the format:
      { 'user1' : {'pubkey':pubkey, 'privkey':privkey}, 'user2' ... } 
    
    build_id:
      A build_id, specific to the vessel list/key dict combination;
      generated by generate_build_id().
      
  <Returns>
    Nothing.
  """
  
  prefix = os.path.join(settings.USER_INSTALLERS_DIR, build_id)
  temp_installinfo_dir = os.path.join(prefix, "install_info")
  
  # first check if installer instance already exists
  if (os.path.isdir(prefix)):
    return
  
  # remove and recreate the prefix dir
  shutil.rmtree(prefix, True)

  # create install dir
  os.mkdir(prefix)
 
  # create the install_info dir, a temporary directory where the vesselinfo
  # will reside right before it gets added into the install package by installer_creator
  os.mkdir(temp_installinfo_dir)

  # strip out the privkeys from the key_dict, we won't need them for building the vesselinfo file
  pubkey_dict = {}
  for user in key_dict:
    pubkey_dict[user] = {'pubkey':key_dict[user]['pubkey']}
  
  # prepare & write out the vesselinfo file
  vessel_info_str = _generate_vessel_info(vessel_list, pubkey_dict)

  
  f = open((temp_installinfo_dir + "/vesselinfo"), 'w')
  f.write(vessel_info_str)
  f.close()
  
  print("vesselinfo file preparation done.")



def check_if_need_new_installers(installer_id):
  """
  <Purpose>
    Checks if the current user installers exist. If they don't, this function
    will try and rebuild them if it can find the vesselinfo file for the specified
    install. 
    
    Also, checks if the current base installers are newer than the already 
    built installers. If so, rebuild the installers with the newer, more current base 
    installers.
  
  <Returns>
    -1 if base installers are missing or unreadable.
     0 if installers are up to date, and do not require rebuilding.
     1 if installers should be rebuilt using newest base installers.
  """
  user_installer_missing = False
  need_rebuild = False
  win_base_mtime = 0
  linux_base_mtime = 0
  mac_base_mtime = 0
  
  try:
    win_stat_buf = os.stat(os.path.join(settings.BASE_INSTALLERS_DIR, "seattle_win.zip"))
    linux_stat_buf = os.stat(os.path.join(settings.BASE_INSTALLERS_DIR, "seattle_linux.tgz"))
    mac_stat_buf = os.stat(os.path.join(settings.BASE_INSTALLERS_DIR, "seattle_mac.tgz"))
  except Exception:
    return -1
  else:
    win_base_mtime = win_stat_buf.st_mtime
    linux_base_mtime = linux_stat_buf.st_mtime
    mac_base_mtime = mac_stat_buf.st_mtime
  
  dist_folder = os.path.join(settings.USER_INSTALLERS_DIR, installer_id)
  
  try:
    win_user_stat_buf = os.stat(os.path.join(dist_folder, "seattle_win.zip"))
    linux_user_stat_buf = os.stat(os.path.join(dist_folder, "seattle_linux.tgz"))
    mac_user_stat_buf = os.stat(os.path.join(dist_folder, "seattle_mac.tgz"))
  except Exception:
    user_installer_missing = True
  else:
    win_user_mtime = win_user_stat_buf.st_mtime
    linux_user_mtime = linux_user_stat_buf.st_mtime
    mac_user_mtime = mac_user_stat_buf.st_mtime
    
  # rebuild installers if base installers newer or user installers missing
  if user_installer_missing:
    need_rebuild = True
  else:  
    if (win_base_mtime > win_user_mtime) or (linux_base_mtime > linux_user_mtime) or (mac_base_mtime > mac_user_mtime):
      need_rebuild = True
  
  if not need_rebuild:
    #print "no rebuild needed!"
    return 0
  
#  # try to remove existing installers (even though they might not exist)
#  try:
#    os.remove(os.path.join(dist_folder, "seattle_win.zip"))
#  except Exception:
#    print "no win user installer to remove"
#    pass
#  else:
#    print "removed win user installer"
#  
#  try:
#    os.remove(os.path.join(dist_folder, "seattle_linux.tgz"))
#  except Exception:
#    print "no linux user installer to remove"
#    pass
#  else:
#    print "removed linux user installer"
#  
#  try:
#    os.remove(os.path.join(dist_folder, "seattle_mac.tgz"))
#  except Exception:
#    print "no mac user installer to remove"
#    pass
#  else:
#    print "removed mac user installer"
  
  #print "about to call customize"
  #_run_customize_installer(installer_id)
  return 1


  
def generate_keypair():
  (pubkeydict, privkeydict) = rsa_gen_pubpriv_keys(KEY_GENERATION_BITSIZE)

  pubkeystring = rsa_publickey_to_string(pubkeydict)
  privkeystring = rsa_privatekey_to_string(privkeydict)
  
  return {'pubkey' : pubkeystring, 'privkey' : privkeystring}



def generate_build_id(vessel_list, key_dict):
  """
  <Purpose>
    Generates a build_id used to identify a specific installer build.
    The generated id is a sha1 of the various vessel & key elements. 
  """
  
  prehash_str = ''
  
  for vessel in vessel_list:
    prehash_str += str(vessel['owner']) + ":" + str(vessel['percentage']) + ":"
    
    for user in vessel['users']:
      prehash_str += str(user) + ","
    
    prehash_str += "|"
  
  for key in key_dict:
    prehash_str += str(key_dict[key]['pubkey']) + ","
  
  build_id = hashlib.sha1(prehash_str).hexdigest()
  return build_id



def dl_installer(request, installer_id, installer_name):
  """
  <Purpose>
    This method is invoked when a client requests an installer via the installer url.
    We perform cache-checking at this point, and if needed, make a call to rebuild
    the installers. Finally, the installers will be read off disk, and served as an
    attachment via the HTTP response.
  
  <Arguments>
    The arguments are inferred from the URL itself.
  
  <Returns>
    An HTTP file-attachment response so the user's browser can download the installer.
  """
  
  # check inputs
  # TODO: catch validation exceptions
  validations.assert_str(installer_id)
  validations.assert_str(installer_name)
  
  if (installer_name != "seattle_win.zip" and installer_name != "seattle_linux.tgz" and installer_name != "seattle_mac.tgz"):
    return HttpResponse("Sorry, the installer you requested does not exist.", status=404) 
  
  v_handle = None
  dist_folder = os.path.join(settings.USER_INSTALLERS_DIR, installer_id)
  
  # first check if this installer build exists by trying to read the vesselinfo 
  #print "searching for vesselinfo at: " + os.path.join(dist_folder, "install_info", "vesselinfo")
  try:
    v_handle = open(os.path.join(dist_folder, "install_info", "vesselinfo"), 'rb');
  except IOError:
    # No dist folder for this user: this installer instance doesn't even exist, return error
    return HttpResponse("Sorry, the installer you requested does not exist.", status=404)
  
  # Found the vesselinfo, check if installer is out-of-date 
  #print "Found dist folder, checking if installer is out-of-date"
  v_handle.close()
  
  check_ret = check_if_need_new_installers(installer_id)
  if (check_ret == 1):
    # need to rebuild
    print "[dl_installer]: need to rebuild"
    
    # Entering a critical section (multiple clients could potentially access
    # the same installer_id installer instance). Begin locking.
    lock = FileLock(os.path.join(dist_folder, "lock.file"))
    acquired = False
    timeout = 400
    retrys = 0
    while not acquired:
      if lock.acquire():
        print "[ LOCK ACQUIRED ]"
        acquired = True
      else:
        # couldn't get lock, sleeping then try again
        print "[ LOCK ACQUIRE FAIL. SLEEPING... ]"
        time.sleep(0.1)
        retrys += 1
        if (retrys == timeout):
          # we've exceeded lock timeout. bail out of while loop
          acquired = True
    
    # exceeded lock timeout
    if (retrys == timeout):
      return HttpResponse("<b>Fatal error:</b> lock acquire timeout exceeded for installer instance " + installer_id)
  
    _run_customize_installer(installer_id)
    #print "[dl_installer]: rebuilt."
    
    # End critical section, release lock.
    time.sleep(TEST_LOCK_RELEASE_DELAY)
    print "[ LOCK RELEASED ]"
    lock.release()
  
  if (check_ret == 0):
    # no rebuild needed
    print "[dl_installer]: serving up cached installers." 
  elif (check_ret == 1):
    # installers rebuilt
    print "[dl_installer]: serving up rebuilt, up-to-date installers." 
  else:
    # something went wrong during the check, eg: base installers not found
    print "[dl_installer]: check_and_build returned fatal -1"
    return HttpResponse("<b>Fatal error:</b> check_and_build returned -1", status=500)
  
  # used by test suite to determine cache check return value
  if TEST_RETURN_CHECK_RET:
    return check_ret
  else:
    # read installer off disk and serve
    if (installer_name == "seattle_win.zip"):
      print "[dl_installer]: serving up win installer"
      return _send_file(os.path.join(dist_folder, "seattle_win.zip"))
    elif (installer_name == "seattle_linux.tgz"):
      print "[dl_installer]: serving up linux installer"
      return _send_file(os.path.join(dist_folder, "seattle_linux.tgz"))
    elif (installer_name == "seattle_mac.tgz"):
      print "[dl_installer]: serving up mac installer"
      return _send_file(os.path.join(dist_folder, "seattle_mac.tgz"))
    else:
      # we should never get here, since validations should have caught invalid
      # installer_names. be safe, and just return a generic error message
      return HttpResponse("Sorry, the installer you requested does not exist.", status=404)



def _generate_vessel_info(vessel_list, key_dict):
  """
  <Purpose>
    Generates a formatted vesselinfo string, used in the 
    writing of the vesselinfo file into the installer build area.
  """
  
  lines = []
  for vessel in vessel_list:
    percentage = str(vessel['percentage'] * 10)
    owner_keypair = key_dict[vessel['owner']] 
    owner_pubkey = owner_keypair['pubkey']
    
    lines.append("Percent " + percentage)
    lines.append("Owner " + owner_pubkey)
    for user in vessel['users']:
      user_keypair = key_dict[user]
      user_pubkey = user_keypair['pubkey']
      lines.append("User " + user_pubkey)
  
  # write in our reserved 20%
  lines.append("Percent 20")
  lines.append("Owner " + SEATTLE_OWNER_PUBKEY)
  
  vessel_info_str = '\n'.join(lines)
  return vessel_info_str



def _run_customize_installer(installer_id, dist_str='wml'):
  """
  <Purpose>
    Calls the installer customizer script, which performs the actual
    building and zipping of the installers.
    
    NOTE: This method should ONLY be called after a prepare_installer has 
    finished, as the customizer script expects the installer directory 
    structure (and vesselinfo file) to already exist in the correct location.
  """
  
  prefix = os.path.join(settings.USER_INSTALLERS_DIR, installer_id)
  temp_installinfo_dir = os.path.join(prefix, "install_info")
  
  time.sleep(5)
  
  try:
    subprocess.check_call([sys.executable, PATH_TO_CUSTOMIZE_INSTALLER_SCRIPT, dist_str, 
                           settings.BASE_INSTALLERS_DIR, temp_installinfo_dir, prefix])
  except subprocess.CalledProcessError:
    raise



def _send_file(file_name):
  """  
  <Purpose>                                                                       
    Send a file through Django without loading the whole file into              
    memory at once. The FileWrapper will turn the file object into an           
    iterator for chunks of 8KB.                                    
  """
  filename = file_name                         
  wrapper = FileWrapper(file(filename))
  response = HttpResponse(wrapper, content_type='text/plain')
  response['Content-Length'] = os.path.getsize(filename)
  return response



#class DjangoLock:
#
#    def __init__(self, filename):
#        self.filename = filename
#        # This will create it if it does not exist already
#        self.handle = open(filename, 'w')
#
#    # flock() is a blocking call unless it is bitwise ORed with LOCK_NB to avoid blocking 
#    # on lock acquisition.  This blocking is what I use to provide atomicity across forked
#    # Django processes since native python locks and semaphores only work at the thread level
#    def acquire(self):
#        print self.handle
#        print fcntl.LOCK_EX
#        fcntl.flock(self.handle, fcntl.LOCK_EX)
#
#    def release(self):
#        fcntl.flock(self.handle, fcntl.LOCK_UN)
#
#    def __del__(self):
#        self.handle.close()
        


class FileLock:
    def __init__(self, filename):
        self.filename = filename
        self.fd = None
        self.pid = os.getpid()

    def acquire(self):
        try:
            self.fd = os.open(self.filename, os.O_CREAT|os.O_EXCL|os.O_RDWR)
            # Only needed to let readers know who's locked the file
            os.write(self.fd, "%d" % self.pid)
            return 1    # return ints so this can be used in older Pythons
        except OSError:
            self.fd = None
            return 0

    def release(self):
        if not self.fd:
            return 0
        try:
            os.close(self.fd)
            print "[ removing lockfile. ]"
            os.remove(self.filename)
            return 1
        except OSError:
            return 0

    def __del__(self):
        #self.release()
        pass
